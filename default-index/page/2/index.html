<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true,"scrollpercent":true,"b2t":true},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Get busy living or get busy dying">
<meta property="og:type" content="website">
<meta property="og:title" content="Blog">
<meta property="og:url" content="http://example.com/default-index/page/2/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="Get busy living or get busy dying">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Normal People">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/default-index/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">by Normal People</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">11</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">37</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/18/Statistical_Learning_Methods_Notes/%E7%AC%AC%E4%B9%9D%E7%AB%A0-EM%E7%AE%97%E6%B3%95%E5%8F%8A%E6%8E%A8%E5%B9%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/18/Statistical_Learning_Methods_Notes/%E7%AC%AC%E4%B9%9D%E7%AB%A0-EM%E7%AE%97%E6%B3%95%E5%8F%8A%E6%8E%A8%E5%B9%BF/" class="post-title-link" itemprop="url">第九章 EM算法及推广</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-06-18 16:36:10 / 修改时间：16:35:44" itemprop="dateCreated datePublished" datetime="2021-06-18T16:36:10+08:00">2021-06-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">统计学习方法</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/06/18/Statistical_Learning_Methods_Notes/%E7%AC%AC%E4%B9%9D%E7%AB%A0-EM%E7%AE%97%E6%B3%95%E5%8F%8A%E6%8E%A8%E5%B9%BF/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/06/18/Statistical_Learning_Methods_Notes/%E7%AC%AC%E4%B9%9D%E7%AB%A0-EM%E7%AE%97%E6%B3%95%E5%8F%8A%E6%8E%A8%E5%B9%BF/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>EM算法是一种迭代算法，用于含有<strong>隐变量（hidden variable）</strong>的概率模型参数的极大似然估计，或极大后验概率估计。</p>
<p>EM算法的每次迭代由两步组成：    </p>
<ul>
<li>E步，求<strong>期望（expectation）</strong>；</li>
<li>M步，求<strong>极大（maximization）</strong>。</li>
</ul>
<p>所以这一算法称为<strong>期望极大算法（expectation maximization algorithm）</strong>，简称EM算法。</p>
<h1 id="9-1-EM算法的引入"><a href="#9-1-EM算法的引入" class="headerlink" title="9.1 EM算法的引入"></a>9.1 EM算法的引入</h1><p>概率模型有时既含有<strong>观测变量（observable variable）</strong>，又含有隐变量或<strong>潜在变量（latent variable）</strong>。如果概率模型的变量都是观测变量，那么给定数据，可以直接用极大似然估计发，或贝叶斯估计法估计模型参数。但是，当模型含有隐变量时，就不能简单地使用这些估计方法。EM算法就是含有隐变量的概率模型参数的极大似然估计，或极大后验概率估计。</p>
<h2 id="9-1-1-EM算法"><a href="#9-1-1-EM算法" class="headerlink" title="9.1.1 EM算法"></a>9.1.1 EM算法</h2><p>EM算法与初值的选择有关，选择不同的初值可能得到不同的参数估计值。</p>
<p>一般地，用$Y$表示观测随机变量的数据，$Z$表示隐随机变量的数据。$Y$和$Z$连在一起称为<strong>完全数据（complete-data）</strong>，观测数据$Y$又称为<strong>不完全数据（incomplete-data）</strong>。假设给定观测数据$Y$，其概率分布是$P(Y|\theta)$，其中$\theta$是需要估计的模型参数，那么不完全数据$Y$的似然函数是$P(Y|\theta)$，对数似然函数$L(\theta) = \log P(Y|\theta)$；假设$Y$和$Z$的联合概率分布是$P(Y,Z|\theta)$，那么完全数据的对数似然函数是$\log P(Y,Z|\theta)$。</p>
<p>EM算法通过迭代求$L(\theta) = \log P(Y|\theta)$的极大似然估计。每次迭代都包含两步：E步，求期望；M步，求极大化。</p>
<p><strong>算法 9.1（EM算法）</strong></p>
<p>输入：观测变量数据$Y$，隐变量数据$Z$，联合分布$P(Y,Z|\theta)$，条件分布$P(Z|Y,\theta)$；</p>
<p><strong>输出</strong>：模型参数$\theta$。</p>
<p>​    （1）选择参数的初值$\theta^{(0)}$，开始迭代；</p>
<p>​    （2）E步：记$\theta^{(i)}$为第$i$次迭代参数$\theta$的估计值，在第$i+1$次迭代的E步，计算</p>
<script type="math/tex; mode=display">
Q(\theta,\theta^{(i)}) = E_Z[\log P(Y,Z|\theta)|Y,\theta^{(i)}]</script><script type="math/tex; mode=display">
\ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ =\sum\limits_{Z} \log P(Y,Z|\theta)P(Z|Y,\theta)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (9.9)</script><p>这里，$P(Z|Y,\theta)$是在给定观测数据$Y$和当前的参数估计$\theta^{(i)}$下隐变量数据$Z$的条件概率分布；</p>
<p>​    （3）M步：求使$Q(\theta,\theta^{(i)})$极大化的$\theta$，确定第$i+1$次迭代的参数的估计值$\theta^{(i+1)}$</p>
<script type="math/tex; mode=display">
\theta^{(i+1)} = \arg\max\limits_{\theta}Q(\theta,\theta^{(i)})\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (9.10)</script><p>​    （4）重复第（2）步和第（3）步，直到收敛。</p>
<p>式$(9.9)$的函数$Q(\theta,\theta^{(i)})$是EM算法的核心，称为$Q$<strong>函数（Q function）</strong>。</p>
<p><strong>定义 9.1（</strong>$Q$<strong>函数）</strong>  完全数据的对数似然函数$\log P(Y,Z|\theta)$关于在给定观测数据$Y$和当前参数$\theta^{(i)}$下对未观测数据$Z$的条件概率分布$P(Z|Y,\theta^{(i)})$的期望称为$Q$函数，即</p>
<script type="math/tex; mode=display">
Q(\theta,\theta^{(i)}) = E_Z[\log P(Y,Z|\theta)|Y,\theta^{(i)}]\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (9.11)</script><p>关于EM算法的几点说明：</p>
<ul>
<li><p><strong>步骤（1）</strong> 参数的初值可以任意选择，但需要注意EM算法对初值是敏感的。</p>
</li>
<li><p><strong>步骤（2）</strong> E步求$Q(\theta,\theta^{(i)})$。$Q$函数式中$Z$是未观测数据，$Y$是观测数据。注意，$Q(\theta,\theta^{(i)})$的第一个变元表示要极大化的参数，第二个变元表示参数的当前估计值。每次迭代实际在求$Q$函数及其极大。</p>
</li>
<li><p><strong>步骤（3）</strong> M步求$Q(\theta,\theta^{(i)})$的极大化，得到$\theta^{(i+1)}$，完成一次迭代$\theta^{(i)} \longrightarrow \theta^{(i+1)}$。</p>
</li>
<li><p><strong>步骤（4）</strong>给出停止迭代的条件，一般是对较小的正数$\epsilon_1,\epsilon_2$，若满足</p>
</li>
</ul>
<script type="math/tex; mode=display">
||\theta^{(i+1)} - \theta^{(i)}|| < \epsilon_1\ \ \  或 \ \ \ ||Q(\theta^{(i+1)},\theta^{(i)})-Q(\theta^{(i)},\theta^{(i)})|| < \epsilon_2</script><p>则停止迭代。</p>
<h2 id="9-1-2-EM算法的导出"><a href="#9-1-2-EM算法的导出" class="headerlink" title="9.1.2 EM算法的导出"></a>9.1.2 EM算法的导出</h2><p>对一个含有隐变量的概率模型，目标是极大化观测数据（不完全数据）$Y$关于参数$\theta$的对数似然函数，即极大化</p>
<script type="math/tex; mode=display">
L(\theta) = \log P(Y|\theta) = \log\sum\limits_{Z}P(Y,Z|\theta)</script><script type="math/tex; mode=display">
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ = \log(\sum\limits_{Z} P(Y|Z,\theta)P(Z|\theta))\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (9.12)</script><p>这一极大化的主要困难是式$(9.12)$中有未观测数据并有包含和（或积分）的对数。</p>
<p>事实上，EM算法是通过迭代逐步近似极大化$L(\theta)$的。假设在第$i$次迭代后$\theta$的估计值是$\theta^{(i)}$。我们希望新估计值$\theta$能使$L(\theta)$增加，即$L(\theta) &gt; L(\theta^{(i)})$，并逐步达到极大值。为此，考虑两者的差：</p>
<script type="math/tex; mode=display">
L(\theta) - L(\theta^{(i)}) = \log(\sum\limits_{Z} P(Y|Z,\theta)P(Z|\theta)) - \log P(Y|\theta^{(i)})</script><p>利用$Jensen$不等式（Jensen inequality）得到其下界：</p>
<script type="math/tex; mode=display">
L(\theta) - L(\theta^{(i)}) = \log(\sum\limits_{Z} P(Y|Z,\theta)P(Z|\theta)) - \log P(Y|\theta^{(i)})</script><script type="math/tex; mode=display">
\geq \sum\limits_{Z} P(Z|Y,\theta^{(i)})\log \frac{P(Y|Z,\theta)P(Z|\theta)}{P(Z|Y,\theta^{(i)})}- \log P(Y|\theta^{(i)})</script><script type="math/tex; mode=display">
= \sum\limits_{Z} P(Z|Y,\theta^{(i)})\log \frac{P(Y|Z,\theta)P(Z|\theta)}{P(Z|Y,\theta^{(i)})P(Y|\theta^{(i)})}</script><p>令</p>
<script type="math/tex; mode=display">
B(\theta,\theta^{(i)}) \hat= L(\theta^{(i)}) +\sum\limits_{Z} P(Z|Y,\theta^{(i)})\log \frac{P(Y|Z,\theta)P(Z|\theta)}{P(Z|Y,\theta^{(i)})P(Y|\theta^{(i)})}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (9.13)</script><p>则</p>
<script type="math/tex; mode=display">
L(\theta) \geq B(\theta,\theta^{(i)})\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (9.14)</script><p>即函数$B(\theta,\theta^{(i)})$是$L(\theta)$的一个下界，而且由式$(9.13)$可知，</p>
<script type="math/tex; mode=display">
L(\theta^{(i)}) = B(\theta^{(i)},\theta^{(i)})\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (9.15)</script><p>因此，任何可以使$B(\theta,\theta^{(i)})$增大的$\theta$，也可以使$L(\theta)$增大。为了使$L(\theta)$有尽可能大的增长，选择$\theta^{(i+1)}$使$B(\theta,\theta^{(i)})$达到极大，即</p>
<script type="math/tex; mode=display">
\theta^{(i+1)} = \arg\max\limits_{\theta}B(\theta,\theta^{(i)})\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (9.16)</script><p>现在求$\theta^{(i+1)}$的表达式。省去对$\theta$的极大化而言是常数的项，由式$(9.16)$、式$(9.13)$即式$(9.10)$，有</p>
<script type="math/tex; mode=display">
\theta^{(i+1)} = \arg\max\limits_{\theta}(L(\theta^{(i)}) +\sum\limits_{Z} P(Z|Y,\theta^{(i)})\log \frac{c}{P(Z|Y,\theta^{(i)})P(Y|\theta^{(i)})})</script><script type="math/tex; mode=display">
=\arg\max\limits_{\theta}(\sum\limits_{Z} P(Z|Y,\theta^{(i)})\log P(Y|Z,\theta)P(Z|\theta))</script><script type="math/tex; mode=display">
=\arg\max\limits_{\theta} (\sum\limits_{Z} P(Z|Y,\theta^{(i)})\log P(Y,Z|\theta))</script><script type="math/tex; mode=display">
= \arg\max\limits_{\theta}Q(\theta,\theta^{(i)})\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (9.17)</script><p>式$(9.17)$等价于EM算法的一次迭代，即求$Q$函数及其极大化。EM算法是通过不断求解下界的极大化逼近求解对数似然函数极大化的算法。</p>
<p>EM算法不能保证找到全局最优值。</p>
<h2 id="9-1-3-EM算法在无监督学习中的应用"><a href="#9-1-3-EM算法在无监督学习中的应用" class="headerlink" title="9.1.3 EM算法在无监督学习中的应用"></a>9.1.3 EM算法在无监督学习中的应用</h2><p>EM算法可以用于生成模型的无监督学习。生成模型由联合概率分布$P(X,Y)$表示，可以认为无监督学习训练数据是联合概率分布产生的数据。$X$为观测数据，$Y$为未观测数据。</p>
<h1 id="9-2-EM算法的收敛性"><a href="#9-2-EM算法的收敛性" class="headerlink" title="9.2 EM算法的收敛性"></a>9.2 EM算法的收敛性</h1><p><strong>定理 9.1</strong>  设$P(Y|\theta)$为观察数据的似然函数，$\theta^{(i)}(i=1,2,…)$为EM算法得到的参数估计序列，$P(Y|\theta^{(i)})(i=1,2,…)$为对应的似然函数序列，则$P(Y|\theta^{(i)})$是单调递增的，即</p>
<script type="math/tex; mode=display">
P(Y|\theta^{(i+1)}) \geq P(Y|\theta^{(i)})\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (9.18)</script><p><strong>定理 9.2</strong>  设$L(\theta) = \log P(Y|\theta)$为观测数据的对数似然函数，$\theta^{(i)}(i=1,2,…)$为EM算法得到的参数估计序列，$L(\theta^{(i)})(i=1,2,…)$为对应的对数似然函数序列。    </p>
<p>​    （1）如果$P(Y|\theta)$有上界，则$L(\theta^{(i)}) = \log P(Y|\theta^{(i)})$收敛到某一值$L^*$；</p>
<p>​    （2）在函数$Q(\theta,\theta^{‘})$与$L(\theta)$满足一定条件下，由EM算法得到的参数估计序列$\theta^{(i)}$的收敛值$\theta^{*}$是$L(\theta)$的稳定点。</p>
<p>EM算法的收敛性包含关于对数似然函数序列$L(\theta^{(i)})$的收敛性和关于参数估计序列$\theta^{(i)}$的收敛性两层意思，前者并不蕴含后者。此外，定理只能保证参数估计序列收敛到对数似然函数序列的稳定点，不能保证收敛到极大值点。所以在应用中，初值的选择变得非常重要，常用的办法是选取几个不同的初值进行迭代，然后对得到的各个估计值加以比较，从中选择最好的。</p>
<h1 id="9-3-EM算法在高斯混合模型学习中的应用"><a href="#9-3-EM算法在高斯混合模型学习中的应用" class="headerlink" title="9.3 EM算法在高斯混合模型学习中的应用"></a>9.3 EM算法在高斯混合模型学习中的应用</h1><p>EM算法是学习<strong>高斯混合模型（Gaussian mixture model）</strong>的有效方法。</p>
<h2 id="9-3-1-高斯混合模型"><a href="#9-3-1-高斯混合模型" class="headerlink" title="9.3.1 高斯混合模型"></a>9.3.1 高斯混合模型</h2><p><strong>定义 9.2（高斯混合模型）</strong>   高斯混合模型是指具有如下形式的概率分布模型：</p>
<script type="math/tex; mode=display">
P(y|\theta) = \sum\limits_{k=1}^{K}\alpha_{k}\phi(y|\theta_k)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (9.24)</script><p>其中，$\alpha_k$是系数，$\alpha_k \geq 0$，$\sum\limits_{k=1}^{K}\alpha_{k} = 1$；$\phi(y|\theta_k)$是高斯分布密度，$\theta_k = (\mu_k,\sigma_k^2)$，</p>
<script type="math/tex; mode=display">
\phi(y|\theta_k) = \frac{1}{\sqrt{2\pi}\sigma_k} \exp(-\frac{(y-\mu_k)^2}{2\sigma_k^2})\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (9.25)</script><p>称为第$k$个分模型。</p>
<p>一般混合模型可以由任意概率分布密度代替式$(9.25)$中的高斯分布密度。</p>
<h2 id="9-3-2-高斯混合模型参数估计的EM算法"><a href="#9-3-2-高斯混合模型参数估计的EM算法" class="headerlink" title="9.3.2 高斯混合模型参数估计的EM算法"></a>9.3.2 高斯混合模型参数估计的EM算法</h2><p><strong>算法 9.2（高斯混合模型参数估计的EM算法）</strong></p>
<p><strong>输入</strong>：观测数据$y_1,y_2,…,y_N$，高斯混合模型；</p>
<p><strong>输出</strong>：高斯混合模型参数。</p>
<p>​    （1）取参数的初始值开始迭代；</p>
<p>​    （2）E步：依据当前模型参数，计算分模型$k$对观测数据$y_j$的响应度</p>
<script type="math/tex; mode=display">
\hat \gamma_{jk} = \frac{\alpha_{k}\phi(y_j|\theta_k)}{\sum\limits_{k=1}^{K}\alpha_{k}\phi(y_j|\theta_k)},\ \ \ j=1,2,..,N;\ \ \ k=1,2,...,K</script><p>​    （3）M步：计算新一轮迭代的模型参数</p>
<script type="math/tex; mode=display">
\hat \mu_k = \frac{\sum\limits_{j=1}^{N}\hat \gamma_{jk}y_j}{\sum\limits_{j=1}^{N}\hat \gamma_{jk}},\ \ \ k=1,2,..,K</script><script type="math/tex; mode=display">
\hat \sigma_k^2 = \frac{\sum\limits_{j=1}^{N}\hat \gamma_{jk}(y_i - \mu_k)^2}{\sum\limits_{j=1}^{N}\hat \gamma_{jk}},\ \ \ k=1,2,..,K</script><script type="math/tex; mode=display">
\hat \alpha_k = \frac{\sum\limits_{j=1}^{N}\hat \gamma_{jk}}{N},\ \ \ k=1,2,..,K</script><p>​    （4）重复第（2）步和第（3）步，直到收敛。</p>
<h1 id="9-4-EM算法的推广"><a href="#9-4-EM算法的推广" class="headerlink" title="9.4 EM算法的推广"></a>9.4 EM算法的推广</h1><p>EM算法还可以解释为$F$<strong>函数（F function）</strong>的<strong>极大-极大算法（maximization-maximization algorithm）</strong>，基于这个解释有若干变形与推广，如<strong>广义期望极大（generalized expectation maximization，GEM）</strong>算法。</p>
<h2 id="9-4-1-F-函数的极大-极大算法"><a href="#9-4-1-F-函数的极大-极大算法" class="headerlink" title="9.4.1 $F$函数的极大-极大算法"></a>9.4.1 $F$函数的极大-极大算法</h2><p><strong>定义 9.3（</strong>$F$<strong>函数）</strong>  假设隐变量数据$Z$的概率分布为$\tilde{P}(Z)$，定义分布$\tilde{P}$与参数$\theta$的函数$F(\tilde{P},\theta)$如下：</p>
<script type="math/tex; mode=display">
F(\tilde{P},\theta) = E_{\tilde{P}}[\log P(Y,Z|\theta)] + H(\tilde{P})\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (9.33)</script><p>称为$F$函数。式中$H(\tilde{P}) = - E_{\tilde{P}}\log \tilde{P}(Z)$是分布$\tilde{P}(Z)$的熵。</p>
<hr>
<p><strong>引理 9.1</strong>  对于固定的$\theta$，存在唯一的分布$\tilde{P}_\theta$极大化$F(\tilde{P},\theta)$，这时$\tilde{P}_\theta$由下式给出：</p>
<script type="math/tex; mode=display">
\tilde{P}_\theta(Z) = P(Z|Y,\theta)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (9.34)</script><p>并且$\tilde{P}_\theta$随$\theta$连续变化。</p>
<hr>
<p><strong>引理 9.2</strong>  若$\tilde{P}_\theta(Z) = P(Z|Y,\theta)$，则</p>
<script type="math/tex; mode=display">
F(\tilde{P},\theta) = \log P(Y|\theta)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (9.36)</script><hr>
<p><strong>定理 9.3</strong>  设$L(\theta) = \log P(Y|\theta)$为观测数据的对数似然函数，$\theta^{(i)},i=1,2,…$，为EM算法得到的参数估计序列，函数$F(\tilde{P},\theta)$由式$(9.33)$定义。如果$F(\tilde{P},\theta)$在$\tilde{P}^<em>$和$\theta^</em>$有局部极大值，那么$L(\theta)$也在$\theta^<em>$有局部极大值。类似地，如果$F(\tilde{P},\theta)$在$\tilde{P}^</em>$和$\theta^<em>$达到全局最大值，那么$L(\theta)$也在$\theta^</em>$达到全局最大值。</p>
<hr>
<p><strong>定理 9.4</strong>  EM算法的一次迭代可由$F$函数的极大-极大算法实现。</p>
<p>设$\theta^{(i)}$为第$i$次迭代参数$\theta$的估计，$\tilde{P}^{(i)}$为第$i$次迭代函数$\tilde{P}$的估计。在第$i+1$次迭代的两步为：</p>
<p>​    （1）对固定的$\theta^{(i)}$，求$\tilde{P}^{(i+1)}$使$F(\tilde{P},\theta^{(i)})$极大化；</p>
<p>​    （2）对固定的$\tilde{P}^{(i+1)}$,求$\theta^{(i+1)}$使$F(\tilde{P}^{(i+1)},\theta)$极大化。</p>
<h2 id="9-4-2-GEM算法"><a href="#9-4-2-GEM算法" class="headerlink" title="9.4.2 GEM算法"></a>9.4.2 GEM算法</h2><p><strong>算法 9.3（GEM算法1）</strong></p>
<p><strong>输入</strong>：观测数据，$F$函数；</p>
<p><strong>输出</strong>：模型参数。</p>
<p>​    （1）初始化参数$\theta^{(0)}$，开始迭代。</p>
<p>​    （2）第$i+1$次迭代，第一步：记$\theta^{(i)}$为参数$\theta$的估计值，$\tilde{P}^{(i)}$为函数$\tilde{P}$的估计，求$\tilde{P}^{(i+1)}$使$\tilde{P}$极大化$F(\tilde{P},\theta^{(i)})$；</p>
<p>​    （3）第二步：求$\theta^{(i+1)}$使$F(\tilde{P}^{(i+1)},\theta)$极大化；</p>
<p>​    （4）重复（2）和（3），直到收敛。</p>
<p>在GEM算法1中，有时求$Q(\theta,\theta^{(i)})$的极大化是很困难的。下面介绍GEM算法2和GEM算法3.</p>
<hr>
<p><strong>算法 9.4（GEM算法2）</strong></p>
<p><strong>输入</strong>：观测数据，$Q$函数；</p>
<p><strong>输出</strong>：模型参数。</p>
<p>​    （1）初始化参数$\theta^{(0)}$，开始迭代。</p>
<p>​    （2）第$i+1$次迭代，第一步：记$\theta^{(i)}$为参数$\theta$的估计值，计算</p>
<script type="math/tex; mode=display">
Q(\theta,\theta^{(i)}) = E_Z[\log P(Y,Z|\theta)|Y,\theta^{(i)}]</script><script type="math/tex; mode=display">
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ =\sum\limits_{Z} \log P(Y,Z|\theta)P(Z|Y,\theta)</script><p>​    （3）第二步：求$\theta^{(i+1)}$使</p>
<script type="math/tex; mode=display">
Q(\theta^{(i+1)},\theta^{(i)}) > Q(\theta^{(i)},\theta^{(i)})</script><p>​    （4）重复（2）和（3），直到收敛。</p>
<hr>
<p>当参数的维数为时，可采用一种特殊的GEM算法，它将EM算法的M步分解为次条件极大化，每次只改变参数向量的一个分量，其余分量不改变。</p>
<p><strong>算法 9.5（GEM算法3）</strong></p>
<p><strong>输入</strong>：观测数据，$Q$函数；</p>
<p><strong>输出</strong>：模型参数。</p>
<p>​    （1）初始化参数$\theta^{(0)} = \{\theta^{(0)}_1,\theta^{(0)}_2,…,\theta^{(0)}_d\}$，开始迭代。</p>
<p>​    （2）第$i+1$次迭代，第一步：记$\theta^{(i)} = \{\theta^{(i)}_1,\theta^{(i)}_2,…,\theta^{(i)}_d\}$为参数$\theta = \{\theta_1,\theta_2,…,\theta_d\}$的估计值，计算</p>
<script type="math/tex; mode=display">
Q(\theta,\theta^{(i)}) = E_Z[\log P(Y,Z|\theta)|Y,\theta^{(i)}]</script><script type="math/tex; mode=display">
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ =\sum\limits_{Z} \log P(Y,Z|\theta)P(Z|Y,\theta)</script><p>​    （3）第二步：进行$d$次条件极大化：</p>
<p>首先，在$\theta^{(i)}_2,…,\theta^{(i)}_d$保持不变的条件下求使$Q(\theta,\theta^{(i)}) $达到极大的$\theta_1^{(i+1)}$；然后，在$\theta_1 = \theta_1^{(i+1)},\theta_j = \theta_j^{(i)},j=3,4,..,d$的条件下求使$Q(\theta,\theta^{(i)})$达到极大的$\theta_2^{(i+1)}$；如此继续，经过$d$次条件极大化，得到$\theta^{(i+1)} = \{\theta^{(i+1)}_1,\theta^{(i+1)}_2,…,\theta^{(i+1)}_d\}$使得</p>
<script type="math/tex; mode=display">
Q(\theta^{(i+1)},\theta^{(i)}) > Q(\theta^{(i)},\theta^{(i)})</script><p>​    （4）重复（2）和（3），直到收敛。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/17/Statistical_Learning_Methods_Notes/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8F%90%E5%8D%87%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/17/Statistical_Learning_Methods_Notes/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8F%90%E5%8D%87%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">第八章 提升方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-06-17 21:49:30 / 修改时间：21:48:53" itemprop="dateCreated datePublished" datetime="2021-06-17T21:49:30+08:00">2021-06-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">统计学习方法</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/06/17/Statistical_Learning_Methods_Notes/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8F%90%E5%8D%87%E6%96%B9%E6%B3%95/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/06/17/Statistical_Learning_Methods_Notes/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8F%90%E5%8D%87%E6%96%B9%E6%B3%95/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>提升（boosting）方法</strong>是一种常用的统计学习方法，应用广泛且有效。在分类问题中，它通过改变训练样本的权重，学习多个分类器，并将这些分类器进行线性组合，提高分类的性能。</p>
<h1 id="8-1-提升方法AdaBoost算法"><a href="#8-1-提升方法AdaBoost算法" class="headerlink" title="8.1 提升方法AdaBoost算法"></a>8.1 提升方法AdaBoost算法</h1><h2 id="8-1-1-提升方法的基本思路"><a href="#8-1-1-提升方法的基本思路" class="headerlink" title="8.1.1 提升方法的基本思路"></a>8.1.1 提升方法的基本思路</h2><p>提升方法基于这样一种思想：对于一个复杂任务来说，将多个专家的判断进行适当的综合所得出的判断，要比其中任何一个专家单独的判断好。</p>
<p>在<strong>概率近似正确（probably approximately correct，PAC）</strong>学习框架中，</p>
<ul>
<li><p>一个概念（一个类），如果存在一个多项式的学习算法能够学习它，并且正确率很高，那么就称这个概念是强可学习的；</p>
</li>
<li><p>一个概念，如果存在一个多项式的学习算法能够学习它，学习的正确率仅比随机猜测略好，那么就称这个概念是弱可学习的。</p>
</li>
</ul>
<p>在PAC学习的框架下，一个概念是强可学习的充分必要条件是这个概念是弱可学习的。</p>
<p>提升方法就是从弱学习算法，反复学习，得到一系列弱分类器（又称为基本分类器），然后组合这些弱分类器，构成一个强分类器。大多数的提升方法都是改变训练数据的概率分布（训练数据的权值分布），针对不同的训练数据分布调用弱学习算法学习一系列弱分类器。</p>
<hr>
<p>对于提升方法来说，有两个问题需要回答：</p>
<ul>
<li>在每一轮如何改变训练数据的权值或概率分布；</li>
<li>如何将弱分类器组合成一个强分类器。</li>
</ul>
<p>关于第一个问题，AdaBoost的做法是，提高那些被前一轮弱分类器错误分类样本的权值，而降低那些被正确分类样本的权值。那些没有得到正确分类的数据，由于其权值的加大而受到后一轮的弱分类器的更大关注。于是，分类问题被一系列的弱分类器“分而治之”。</p>
<p>至于第二个问题，即弱分类器的组合，AdaBoost采取加权多数表决的方法。具体地，加大分类误差率小的弱分类器的权值，使其在表决中起较大的作用；减小分类误差率大的弱分类器的权值，使其在表决中起较小的作用。</p>
<h2 id="8-1-2-AdaBoost算法"><a href="#8-1-2-AdaBoost算法" class="headerlink" title="8.1.2 AdaBoost算法"></a>8.1.2 AdaBoost算法</h2><p><strong>算法 8.1（AdaBoost）</strong></p>
<p><strong>输入</strong>：训练数据集$T = \{(x_1,y_1),(x_2,y_2),…,(x_N,y_N)\}$，其中，$x_i \in \chi = R^n, y \in Y = \{+1, -1\}, i=1,2,…,N$；弱学习算法；</p>
<p><strong>输出</strong>：最终分类器$G(x)$。</p>
<p>​    （1）初始化训练数据的权值分布</p>
<script type="math/tex; mode=display">
D_1 = (w_{11},...,w_{1i},...,w_{1N})\ \ \ w_{1i} = \frac{1}{N},\ \ \ i= 1,2,...,N</script><p>​    （2）对$m=1,2,…,M$</p>
<p>​        （a）使用具有权值分布$D_m$的训练数据集学习，得到基本分类器。</p>
<script type="math/tex; mode=display">
G_m(x) : \mathcal{X} \longrightarrow \{-1, +1\}</script><p>​        （b）计算$G_m(x)$在训练数据集上的分类误差率</p>
<script type="math/tex; mode=display">
e_m = \sum\limits_{i = 1}^{N}P(G_m(x_i) \neq y_i) = \sum\limits_{i = 1}^{N}w_{mi}I(G_m(x_i) \neq y_i)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (8.1)</script><p>​        （c）计算$G_m(x)$的系数</p>
<script type="math/tex; mode=display">
\alpha_m = \frac{1}{2}\log\frac{1 - e_m}{e_m}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (8.2)</script><p>这里的对数是自然对数。</p>
<p>​        （d）更新训练数据集的权值分布</p>
<script type="math/tex; mode=display">
D_{m+1} = (w_{m+1,1},...,w_{m+1,i},...,w_{m+1,N})\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (8.3)</script><script type="math/tex; mode=display">
w_{m+1,i} = \frac{w_{mi}}{Z_m}\exp(-\alpha_my_iG_m(x_i)), \ \ \ i= 1,2,...,N \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (8.4)</script><p>这里，$Z_m$是规范化因子</p>
<script type="math/tex; mode=display">
Z_m = \sum\limits_{i = 1}^{N} w_{mi}\exp(-\alpha_my_iG_m(x_i))\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (8.5)</script><p>它使$D_{m+1}$成为一个概率分布。</p>
<p>​    （3）构建基本分类器的线性组合（所有$\alpha_m$之和并不为1）</p>
<script type="math/tex; mode=display">
f(x) =\sum\limits_{i = 1}^{N} \alpha_m G_m(x)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (8.6)</script><p>得到最终分类器</p>
<script type="math/tex; mode=display">
G(x) = sign(f(x)) = sign(\sum\limits_{i = 1}^{N} \alpha_m G_m(x))\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (8.7)</script><p>AdaBoost的特点：</p>
<ul>
<li>不改变所给的训练数据，而不断改变训练数据权值的分布，使得训练数据在基本分类器的学习中起不同的作用；</li>
<li>利用基本分类器的线性组合构建最终分类器。</li>
</ul>
<h1 id="8-2-AdaBoost算法的训练误差分析"><a href="#8-2-AdaBoost算法的训练误差分析" class="headerlink" title="8.2 AdaBoost算法的训练误差分析"></a>8.2 AdaBoost算法的训练误差分析</h1><p>AdaBoost最基本的性质是它能在学习过程中不断减少训练误差，即在训练数据集上的分类误差率。</p>
<p><strong>定理 8.1（AdaBoost的训练误差界）</strong>  AdaBoost算法最终分类器的训练误差界为</p>
<script type="math/tex; mode=display">
\frac{1}{N}\sum\limits_{i = 1}^{N}I(G(x_i) \neq y_i) \leq \frac{1}{N}\sum\limits_{i}\exp(-y_i f(x_i)) = \prod\limits_{m} Z_m\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (8.9)</script><p>这里，$G(x),f(x)$和$Z_m$分别由式$(8.7)$、式$(8.6)$和式$(8.5)$给出。</p>
<p>这一定理说明，可以在每一轮选取适当的$G_m$使得$Z_m$最小，从而使训练误差下降最快。</p>
<hr>
<p><strong>定理 8.2（二类分类问题AdaBoost的训练误差界）</strong></p>
<script type="math/tex; mode=display">
\prod\limits_{m=1}^{M} Z_m = \prod\limits_{m=1}^{M} [2\sqrt{e_m(1-e_m)} ]</script><script type="math/tex; mode=display">
= \prod\limits_{m=1}^{M} \sqrt{(1-4\gamma^2_m)}</script><script type="math/tex; mode=display">
\ \ \ \ \ \ \ \ \ \\ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \ \leq \exp(-1\sum\limits_{m=1}^{M} \gamma_m^2)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (8.10)</script><p>这里，$\gamma_m = \frac{1}{2} - e_m$。</p>
<hr>
<p><strong>推论 8.1</strong>  如果存在$\gamma &gt; 0$，对所有$m$有$\gamma_m \geq \gamma$，则</p>
<script type="math/tex; mode=display">
\frac{1}{N}\sum\limits_{i=1}^{N}I(G(x_i) \neq y_i) \leq \exp(-2M\gamma^2)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (8.12)</script><p>这表明在此条件下AdaBoost的训练误差是以指数速率下降的。</p>
<p>AdaBoost具有适应性，即它能适应弱分类器各自的训练误差率。</p>
<h1 id="8-3-AdaBoost算法的解释"><a href="#8-3-AdaBoost算法的解释" class="headerlink" title="8.3 AdaBoost算法的解释"></a>8.3 AdaBoost算法的解释</h1><p>AdaBoost算法还有另一个解释，即可以认为AdaBoost算法是模型为加法模型、损失函数为指数函数、学习算法为前向分步算法时的二类分类学习方法。</p>
<h2 id="8-3-1-前向分步算法"><a href="#8-3-1-前向分步算法" class="headerlink" title="8.3.1 前向分步算法"></a>8.3.1 前向分步算法</h2><p>考虑<strong>加法模型（additive model）</strong></p>
<script type="math/tex; mode=display">
f(x) = \sum\limits_{m=1}^{M}\beta_m b(x;\gamma_m)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (8.13)</script><p>其中，$b(x;\gamma_m)$为基函数，$\gamma_m$为基函数的参数，$\beta_m$为基函数的系数。</p>
<p>在给定训练数据及损失函数$L(y,f(x))$的条件下，学习加法模型$f(x)$成为经验风险极小化即损失函数极小化问题：</p>
<script type="math/tex; mode=display">
\min\limits_{\beta_m,\gamma_m} \sum\limits_{i=1}^{N} L(y_i,\sum\limits_{m=1}^{M}\beta_m b(x_i;\gamma_m))\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (8.14)</script><p><strong>前向分步算法（forward stagewise algorithm）</strong>求解这一优化问题的想法是：因为学习的是加法模型，如果能够从前向后，每一步只学习一个基函数及其系数，逐步逼近优化目标函数$(8.14)$，那么就可以简化优化的复杂度。具体地，每步只需优化如下损失函数：</p>
<script type="math/tex; mode=display">
\min\limits_{\beta,\gamma} \sum\limits_{i=1}^{N} L(y_i,\beta b(x_i;\gamma))\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (8.15)</script><hr>
<p><strong>算法 8.2（前向分步算法）</strong></p>
<p><strong>输入</strong>：训练数据集$T = \{(x_1,y_1),(x_2,y_2),…,(x_N,y_N)\}$；损失函数$L(y,f(x))$；基函数集$\{b(x;\gamma)\}$；</p>
<p><strong>输出</strong>：加法模型$f(x)$。</p>
<p>​    （1）初始化$f_0(x) = 0$；</p>
<p>​    （2）对$m = 1,2,..,M$</p>
<p>​        （a）极小化损失函数</p>
<script type="math/tex; mode=display">
(\beta_m,\gamma_m) = \arg\min\limits_{\beta,\gamma}\sum\limits_{i=1}^{N} L(y_i,f_{m-1}(x_i)  + \beta b(x_i;\gamma))\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (8.16)</script><p>​    得到参数$\beta_m,\gamma_m$。</p>
<p>​        （b）更新</p>
<script type="math/tex; mode=display">
f_m(x) = f_{m-1}(x) + \beta_m b(x;\gamma_m)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (8.17)</script><p>​    （3）得到加法模型</p>
<script type="math/tex; mode=display">
f(x) = f_M(x) = \sum\limits_{m=1}^{M}\beta_m b(x;\gamma_m)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (8.18)</script><p>这样，前向分步算法将同时求解从$m = 1$到$M$所有参数$\beta_m,\gamma_m$的优化问题简化为逐次求解各个$\beta_m,\gamma_m$的优化问题。</p>
<h2 id="8-3-2-前向分步算法与AdaBoost"><a href="#8-3-2-前向分步算法与AdaBoost" class="headerlink" title="8.3.2 前向分步算法与AdaBoost"></a>8.3.2 前向分步算法与AdaBoost</h2><p><strong>定理 8.3</strong> AdaBoost算法是前向分步加法算法的特例。这时，模型是由基本分类器组成的加法模型，损失函数是指数函数。</p>
<h1 id="8-4-提升树"><a href="#8-4-提升树" class="headerlink" title="8.4 提升树"></a>8.4 提升树</h1><p>提升树是以分类树或回归树为基本分类器的提升方法。</p>
<h2 id="8-4-1-提升树模型"><a href="#8-4-1-提升树模型" class="headerlink" title="8.4.1 提升树模型"></a>8.4.1 提升树模型</h2><p>以决策树为基函数的提升方法称为<strong>提升树（booting tree）</strong>。对分类问题决策树是二叉分类树，对回归问题决策树是二叉回归树。</p>
<p>提升树模型可以表示为决策树的加法模型：</p>
<script type="math/tex; mode=display">
f_M(x) = \sum\limits_{m=1}^{M}T(x;\Theta_m)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (8.24)</script><p>其中，$T(x;\Theta_m)$表示决策树，$\Theta_m$为决策树的参数，$M$为树的个数。</p>
<h2 id="8-4-2-提升树算法"><a href="#8-4-2-提升树算法" class="headerlink" title="8.4.2 提升树算法"></a>8.4.2 提升树算法</h2><p>提升树算法采用前向分步算法。首先确定初始提升树$f_0(x) = 0$，第$m$步的模型是</p>
<script type="math/tex; mode=display">
f_m(x) = f_{m-1}(x) + T(x;\Theta_m)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (8.25)</script><p>其中，$f_{m-1}(x)$为当前模型，通过经验风险极小化确定下一棵决策树的参数$\Theta_m$：</p>
<script type="math/tex; mode=display">
\hat \Theta_m  = \arg\min\limits_{i=1}^{N}L(y_i,f_{m-1}(x_i) + T(x_i;\Theta_m))\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (8.26)</script><p>针对不同问题的提升树学习算法，其主要区别在于使用的损失函数不同。包括用平方误差损失函数的回归问题，用指数损失函数的分类问题，以及用一般损失函数的一般决策问题。</p>
<p>对于二分类问题，提升树算法只需将AdaBoost算法8.1中的基本分类器限制为二类分类树即可，可以说这时的提升树算法是AdaBoost算法的特殊情况。</p>
<hr>
<p>已知一个训练数据集$T = \{(x_1,y_1),(x_2,y_2),…,(x_N,y_N)\}$，其中，$x_i \in \chi = R^n$，$\mathcal{X}$为输入空间，$ y \in Y \subseteq R$，$\mathcal{Y}$为输出空间。如果将输入空间$\mathcal{X}$划分为$J$个互不相交的区域$R_1,R_2,…,R_J$，并且在每个区域上确定输出的常量$c_j$，那么树可表示为</p>
<script type="math/tex; mode=display">
T(x;\Theta) = \sum\limits_{j=1}^{J}c_jI(x \in R_j)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (8.27)</script><p>其中，参数$\Theta = \{(R_1,c_1),(R_2,c_2),…,(R_J,c_J)\}$表示树的区域划分和各区域上的常数。$J$是回归树的复杂度即叶结点个数。</p>
<p>回归问题提升树使用以下前向分步算法：</p>
<script type="math/tex; mode=display">
f_0(x) = 0</script><script type="math/tex; mode=display">
f_m(x) = f_{m-1}(x) + T(x;\Theta_m), \ \ \ m = 1,2,...,M</script><script type="math/tex; mode=display">
f_M(x) = \sum\limits_{m=1}^{M}T(x;\Theta_m)</script><p>在前向分步算法的第$m$步，给定当前模型$f_{m-1}(x)$，需求解</p>
<script type="math/tex; mode=display">
\hat \Theta_m  = \arg\min\limits_{i=1}^{N}L(y_i,f_{m-1}(x_i) + T(x_i;\Theta_m))</script><p>得到$\hat \Theta_m$，即第$m$棵树的参数。</p>
<p>当采用平方误差损失函数时，</p>
<script type="math/tex; mode=display">
L(y,f(x)) = (y-f(x))^2</script><p>其损失变为</p>
<script type="math/tex; mode=display">
L(y,f_{m-1}(x) + T(x;\Theta_m)) = [y- f_{m-1}(x)-T(x;\Theta_m)]^2</script><script type="math/tex; mode=display">
= [r-T(x;\Theta_m)]^2</script><p>这里，</p>
<script type="math/tex; mode=display">
r = y- f_{m-1}(x)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (8.28)</script><p>是更强模型拟合数据的<strong>残差（residual）</strong>。所以，对回归问题的提升树算法来说，只需简单地拟合当前模型的残差。</p>
<p><strong>算法 8.3（回归问题的提升树算法）</strong></p>
<p><strong>输入</strong>：训练数据集$T = \{(x_1,y_1),(x_2,y_2),…,(x_N,y_N)\}$，$x_i \in \chi = R^n$，$ y \in Y \subseteq R$；</p>
<p><strong>输出</strong>：提升树$f_M(x)$。</p>
<p>​    （1）初始化$f_0(x) = 0$。</p>
<p>​    （2）对$m = 1,2,…,M$。</p>
<p>​        （a）按式$(8.28)$计算残差：</p>
<script type="math/tex; mode=display">
r_{mi} = y_i- f_{m-1}(x_i), \ \ \ i=1,2,...,N</script><p>​        （b）拟合残差$r_{mi}$学习一个回归树，得到$T(x;\Theta_m)$。</p>
<p>​        （c）更新$f_m(x) = f_{m-1}(x) + T(x;\Theta_m)$。</p>
<p>​    （3）得到回归问题提升树</p>
<script type="math/tex; mode=display">
f_M(x) = \sum\limits_{m=1}^{M}T(x;\Theta_m)</script><h2 id="8-4-3-梯度提升"><a href="#8-4-3-梯度提升" class="headerlink" title="8.4.3 梯度提升"></a>8.4.3 梯度提升</h2><p>对于一般损失函数而言，往往每一步优化并不那么容易。针对这一问题，Freidman提出了<strong>梯度提升（gradient boosting）</strong>算法。这是利用最速下降法的近似方法，其关键是利用损失函数的负梯度在当前模型的值</p>
<script type="math/tex; mode=display">
-[\frac{\partial L(y,f(x_i))}{\partial f(x_i)}]_{f(x)=f_{m-1}(x)}</script><p>作为回归问题提升树算法中的残差近似值，拟合一个回归树。</p>
<p><strong>算法 8.4（梯度提升算法）</strong></p>
<p><strong>输入</strong>：训练数据集$T = \{(x_1,y_1),(x_2,y_2),…,(x_N,y_N)\}$，$x_i \in \chi = R^n$，$ y \in Y \subseteq R$；</p>
<p><strong>输出</strong>：提升树$\hat f(x)$。</p>
<p>​    （1）初始化</p>
<script type="math/tex; mode=display">
f_0(x) = \arg\min\limits_{c}\sum\limits_{i=1}^{N}L(y_i,c)</script><p>​    （2）对$m = 1,2,…,M$</p>
<p>​        （a）对$i=1,2,…,N$，计算</p>
<script type="math/tex; mode=display">
r_{mi} = -[\frac{\partial L(y_i,f(x_i))}{\partial f(x_i)}]_{f(x)=f_{m-1}(x)}</script><p>​        （b）对$r_{mi}$拟合一个回归树，得到第$m$棵树的叶结点区域$R_{mj},j=1,2,…,J$。</p>
<p>​        （c）对$j=1,2,…,J$，计算</p>
<script type="math/tex; mode=display">
c_{mj} =\arg\min\limits_{c}\sum\limits_{x_i \in R_{mj}}L(y_i,f_{m-1}(x_i) + c)</script><p>​        （d）更新$f_m(x) = f_{m-1}(x) + \sum\limits_{j=1}^{J}c_{mj}I(x \in R_{mj})$</p>
<p>​    （3）得到回归树</p>
<script type="math/tex; mode=display">
\hat f(x) = f_M(x) = \sum\limits_{m=1}^{M}\sum\limits_{j=1}^{J}I(x \in R_{mj})</script><ul>
<li>算法第1步初始化，估计使损失函数极小化的常数值，它是只有一个根结点的树。</li>
<li><p>第2(a)步计算损失函数的负梯度在当前模型的值，将它作为残差的估计。</p>
<ul>
<li>对于平方损失函数，它就是通常所说的残差；</li>
<li>对于一般损失函数他就是残差的近似值。</li>
</ul>
</li>
<li><p>第2(b)步估计回归树叶结点区域，以拟合残差的近似值。</p>
</li>
<li>第2(c)步利用线性搜索估计叶结点区域的值，是损失函数极小化。</li>
<li>第2(d)步更新回归树。</li>
<li>第3步得到输出的最终模型$\hat f(x)$</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/16/Statistical_Learning_Methods_Notes/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/16/Statistical_Learning_Methods_Notes/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/" class="post-title-link" itemprop="url">第七章 支持向量机</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-06-16 20:46:39 / 修改时间：20:46:21" itemprop="dateCreated datePublished" datetime="2021-06-16T20:46:39+08:00">2021-06-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">统计学习方法</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/06/16/Statistical_Learning_Methods_Notes/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/06/16/Statistical_Learning_Methods_Notes/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><p><strong>支持向量机（support vector machines，SVM）</strong>是一种二类分类模型。它的基本模型是定义在特征空间上的间隔最大的线性分类器，间隔最大使它有别于感知机；支持向量机还包括核技巧，这使它成为实质上的非线性分类器。</p>
</li>
<li><p>支持向量机的学习策略就是间隔最大化，可形式化为一个求解<strong>凸二次规划（convex quadratic programming）</strong>的问题，也等价于正则化的合页损失函数的最小化问题。</p>
</li>
<li><p>支持向量机的学习算法是求解凸二次规划的最优化算法。</p>
</li>
</ul>
<p>支持向量机学习方法包含构建由简至繁的模型：</p>
<ul>
<li><p><strong>线性可分支持向量机（linear support vector machine in linearly separable case）</strong></p>
<p>当训练数据线性可分时，通过<strong>硬间隔最大化（hard margin maximization）</strong>，学习一个线性分类器，即线性可分支持向量机，又称为硬间隔支持向量机。</p>
</li>
<li><p><strong>线性支持向量机（linear support vector machine）</strong></p>
<p>当训练数据近似线性可分时，通过<strong>软间隔最大化（soft margin maximization）</strong>，也学习一个线性的分类器，即线性支持向量机，又称为软间隔支持向量机。</p>
</li>
<li><p><strong>非线性支持向量机（non-linear support vector machine）</strong></p>
<p>当训练数据线性不可分时，通过使用<strong>核技巧（kernel trick）</strong>及软间隔最大化，学习非线性支持向量机。</p>
</li>
</ul>
<p>当输入空间为欧式空间或离散集合、特征空间为希尔伯特空间时，<strong>核函数（kernel function）</strong>表示将输入从输入空间映射到特征空间得到的特征向量之间的内积。通过使用核函数可以学习非线性支持向量机，等价于隐式地在高维的特征空间中学习线性支持向量机。</p>
<h1 id="7-1-线性可分支持向量机与硬间隔最大化"><a href="#7-1-线性可分支持向量机与硬间隔最大化" class="headerlink" title="7.1 线性可分支持向量机与硬间隔最大化"></a>7.1 线性可分支持向量机与硬间隔最大化</h1><h1 id="7-1-1-线性可分支持向量机"><a href="#7-1-1-线性可分支持向量机" class="headerlink" title="7.1.1 线性可分支持向量机"></a>7.1.1 线性可分支持向量机</h1><p>假设输入空间与特征空间为两个不同的空间。输入空间为欧式空间或离散集合，特征空间为欧式空间或希尔伯特空间。线性可分支持向量机、线性支持向量机假设这两个空间的元素一一对应，并将输入空间中的输入映射为特征空间中的特征向量。非线性支持向量机利用一个从输入到特征空间的非线性映射将输入映射为特征向量。所以，输入都由输入空间转换到特征空间，支持向量机的学习是在特征空间进行的。</p>
<p>假设给定一个特征空间上的训练数据集</p>
<script type="math/tex; mode=display">
T = \{(x_1,y_1),(x_2,y_2),...,(x_N,y_N)\}</script><p>其中，$x_i \in \chi = R^n, y \in \mathcal{Y} = \{+1, -1\}, i=1,2,…,N$；在假设训练数据集是线性可分的。</p>
<p>学习的目标是：在特征空间中找到一个分离超平面，能将实例分到不同的类。分离超平面对应于方程$\omega · x + b = 0$，它由法向量$\omega$和截距$b$决定，可用$(\omega,b)$来表示。分离超平面将特征空间划分为两部分，一部分是正类，一部分是负类。法向量指向一侧为正类，另一侧为负类。</p>
<p>一般地，当训练数据集线性可分时，存在无穷个分离超平面可将两类数据正确分开。感知机利用误分类最小的策略，求得分离超平面，不过这时的解有无穷多个。线性可分支持向量机利用间隔最大化求最优分离超平面，这时，解是唯一的。</p>
<p><strong>定义 7.1（线性可分支持向量机）</strong>  给定线性可分训练数据集，通过间隔最大化或等价地求解相应的凸二次规划问题学习得到的分离超平面为</p>
<script type="math/tex; mode=display">
\omega^* · x + b^* = 0 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.1)</script><p>以及相应的分类决策函数</p>
<script type="math/tex; mode=display">
f(x) = sign(\omega^* · x + b^*)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.2)</script><p>称为线性可分支持向量机。</p>
<h2 id="7-1-2-函数间隔和几何间隔"><a href="#7-1-2-函数间隔和几何间隔" class="headerlink" title="7.1.2 函数间隔和几何间隔"></a>7.1.2 函数间隔和几何间隔</h2><ul>
<li><p>一般来说，一个点距离分离超平面的远近可以表示分类预测的确信程度。在超平面$\omega · x + b = 0$确定的情况下，$|\omega · x + b|$能够相对地表示点$x$距离超平面的远近。而$\omega · x + b$的符号与类标记$y$的符号是否一致能够表示分类是否正确。所以可用量$y(\omega · x + b)$来表示分类的正确性及确信度，这就是<strong>函数间隔（functional margin）</strong>的概念。</p>
<p><strong>定义 7.2（函数间隔）</strong>  对于给定的训练数据集$T$和超平面$(\omega,b)$，定义超平面$(\omega,b)$关于样本点$(x_i,y_i)$的函数间隔为</p>
<script type="math/tex; mode=display">
\hat \gamma_i = y_i(\omega·x_i+b)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.3)</script><p>定义超平面$(\omega,b)$关于训练数据集$T$的函数间隔为超平面$(\omega,b)$关于$T$中所有样本点$(x_i,y_i)$的函数间隔之最小值，即</p>
<script type="math/tex; mode=display">
\hat \gamma= \min\limits_{i=1,2,...,N}\hat\gamma_i\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.4)</script><p>函数间隔可以表示分类预测的正确性及确信度。</p>
</li>
<li><p>但是选择分离超平面时，只有函数间隔还不够。因为只要成比例地改变$\omega$和$b$，超平面并没有改变，但函数间隔却成为原来的2倍。可以对分离超平面的法向量$\omega$加某些约束，如规范化，$||\omega|| = 1$，这使得间隔是确定的。这时函数间隔成为<strong>几何间隔（geometric margin）</strong>。</p>
<p><strong>定义 7.3（几何间隔）</strong>  对于给定的训练数据集$T$和超平面$(\omega,b)$，定义超平面$(\omega,b)$关于样本点$(x_i,y_i)$的几何间隔为</p>
<script type="math/tex; mode=display">
\gamma_i = y_i(\frac{\omega}{||\omega||}·x_i + \frac{b}{||\omega||})\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.5)</script><p>定义超平面$(\omega,b)$关于训练数据集$T$的几何间隔为超平面$(\omega,b)$关于$T$中所有样本点$(x_i,y_i)$的几何间隔之最小值，即</p>
<script type="math/tex; mode=display">
\gamma= \min\limits_{i=1,2,...,N}\gamma_i\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.6)</script><p>超平面$(\omega,b)$关于样本点$(x_i,y_i)$的几何间隔一般是实例点到超平面的<strong>带符号的距离（signed distance）</strong>，当样本点被超平面正确分类时就是实例点到超平面的距离。</p>
</li>
</ul>
<hr>
<p>从函数间隔和几何间隔的定义可知，函数间隔和几何间隔有下面的关系：</p>
<script type="math/tex; mode=display">
\gamma_i = \frac{\hat\gamma_i}{||\omega||}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.7)</script><script type="math/tex; mode=display">
\gamma = \frac{\hat\gamma}{||\omega||}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.8)</script><p>如果$||\omega|| = 1$，那么函数间隔和几何间隔相等。如果超平面参数$\omega$和$b$成比例地改变（超平面没有改变），函数间隔也按此比例改变，而几何间隔不变。</p>
<h2 id="7-1-3-间隔最大化"><a href="#7-1-3-间隔最大化" class="headerlink" title="7.1.3 间隔最大化"></a>7.1.3 间隔最大化</h2><p>支持向量机学习的基本想法是求解能够正确划分训练数据集并且几何间隔最大的分离超平面。</p>
<p>间隔最大化的直观解释是：对训练数据集找到几何间隔最大的超平面意味着以充分大的确信度对训练数据进行分类。也就是说，不仅将正负实例点分开，而且对最难分的实例点（离超平面最近的点）也有足够大的确信度将它们分开。</p>
<ol>
<li><strong>最大间隔分离超平面</strong></li>
</ol>
<p>考虑如何求得一个几何间隔最大的分离超平面，即最大间隔分离超平面。具体地，这个问题可以表示为下面的约束最优化问题：</p>
<script type="math/tex; mode=display">
\max\limits_{\omega,b} \gamma\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.9)</script><script type="math/tex; mode=display">
s.t.\ \ \ y_i(\frac{\omega}{||\omega||}·x_i + \frac{b}{||\omega||}) \geq \gamma, \ \ \ i=1,2,...,N\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.10)</script><p>即我们希望最大化超平面$(\omega,b)$关于训练数据集的几何间隔$\gamma$，约束条件表示的是超平面$(\omega,b)$关于每个训练样本点的几何间隔至少是$\gamma$。</p>
<p>考虑几何间隔和函数间隔的关系式，可将这个问题改写为</p>
<script type="math/tex; mode=display">
\max\limits_{\omega,b} \frac{\hat\gamma}{||\omega||}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.11)</script><script type="math/tex; mode=display">
s.t.\ \ \ y_i(\omega·x_i+b) \geq \hat\gamma, \ \ \ i=1,2,...,N\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.12)</script><p>函数间隔$\hat\gamma$的取值并不影响最优化问题的解。事实上，假设将$\omega$和$b$按比例改变为$\lambda\omega$和$\lambda b$，这时函数间隔成为$\lambda \hat\gamma$。函数间隔的这一改变对上面最优化问题的不等式约束没有影响，对目标函数的优化也没有影响，也就是说，它产生一个等价的最优化问题。这样，就可以取$\hat\gamma = 1$。将$\hat\gamma = 1$代入上面的最优化问题，注意到最大化$\frac{1}{||\omega||}$和最小化$\frac{1}{2}||\omega||^2$是等价的，于是就得到下面的线性可分支持向量机学习的最优化问题：</p>
<script type="math/tex; mode=display">
\min\limits_{\omega,b}\frac{1}{2}||\omega||^2\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.13)</script><script type="math/tex; mode=display">
s.t.\ \ \ y_i(\omega·x_i+b) - 1 \geq 0, \ \ \ i=1,2,...,N\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.14)</script><p>这是一个凸二次规划（convex quadratic programming）问题。</p>
<p>凸优化问题是指约束最优化问题</p>
<script type="math/tex; mode=display">
\min f(\omega)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.15)</script><script type="math/tex; mode=display">
s.t.\ \ \ g_i(\omega) \leq 0, \ \ \ i=1,2,...,k\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.16)</script><script type="math/tex; mode=display">
h_i(\omega) = 0, \ \ \ i=1,2,...,l\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.17)</script><p>其中，目标函数$f(\omega)$和约束函数$g_i(\omega)$都是$R^n$上的连续可微的凸函数，约束函数$h_i(\omega)$是$R^n$上的仿射函数。</p>
<p>注：$f(x)$称为仿射函数，如果它满足$f(x) = a·x +b,a\in R^n,b \in R^n,x\in R^n$。</p>
<p>当目标函数$f(\omega)$是二次函数且约束函数$g_i(\omega)$是仿射函数时，上述凸最优化问题称为凸二次规划问题。</p>
<p><strong>算法 7.1（线性可分支持向量机学习算法——最大间隔法）</strong></p>
<p><strong>输入</strong>：线性可分训练数据集$T = \{(x_1,y_1),(x_2,y_2),…,(x_N,y_N)\}$，其中，$x_i \in \chi = R^n, y \in \mathcal{Y} = \{+1, -1\}, i=1,2,…,N$；</p>
<p><strong>输出</strong>：最大间隔分离超平面和分类决策函数。</p>
<p>​    （1）构造并求解约束最优化问题：</p>
<script type="math/tex; mode=display">
\min\limits_{\omega,b}\frac{1}{2}||\omega||^2</script><script type="math/tex; mode=display">
s.t.\ \ \ y_i(\omega·x_i+b) - 1 \geq 0, \ \ \ i=1,2,...,N</script><p>求得最优解$\omega^<em>,b^</em>$。</p>
<p>​    （2）由此得到分离超平面：</p>
<script type="math/tex; mode=display">
\omega ^* ·x + b^* = 0</script><p>分类决策函数</p>
<script type="math/tex; mode=display">
f(x) = sign(\omega ^* ·x + b^*)</script><ol>
<li><strong>最大间隔分离超平面的存在唯一性</strong></li>
</ol>
<p><strong>定理 7.1（最大间隔分离超平面的存在唯一性）</strong>  若训练数据集$T$线性可分，则可将训练数据集中的样本点完全正确分开的最大间隔分离超平面存在且唯一。</p>
<ol>
<li><strong>支持向量和间隔边界</strong></li>
</ol>
<p>在线性可分情况下，训练数据集的样本点中与分离超平面距离最近的样本点的实例称为支持向量（support vector）。支持向量是使约束条件式（7.14）等号成立的点，即</p>
<script type="math/tex; mode=display">
y_i(\omega·x_i+ b) -1 = 0</script><p>对$y_i = +1$的正例点，支持向量在超平面</p>
<script type="math/tex; mode=display">
H_1 ：\omega ·x +b = 1</script><p>上，对$y_i = -1$的正例点，支持向量在超平面</p>
<script type="math/tex; mode=display">
H_1 ：\omega ·x +b = -1</script><p>上。</p>
<p>c，并且没有实例点落在它们中间。在$H_1$与$H_2$之间形成一条长带，分离超平面与它们平行且位于它们中央。长带的宽度，即$H_1$与$H_2$之间的距离称为<strong>间隔（margin）</strong>。间隔依赖于分离超平面的法向量$\omega$，等于$\frac{2}{||\omega||}$。$H_1$和$H_2$称为间隔边界。</p>
<p>在决定分离超平面时只有支持向量起作用，而其他实例点并不起作用。</p>
<p>支持向量的个数一般很少，所以支持向量机由很少的“重要的”训练样本确定。</p>
<h2 id="7-1-4-学习的对偶算法"><a href="#7-1-4-学习的对偶算法" class="headerlink" title="7.1.4 学习的对偶算法"></a>7.1.4 学习的对偶算法</h2><p>通过求解<strong>对偶问题（dual problem）</strong>得到<strong>原始问题（primal problem）</strong>的最优解，这就是线性可分支持向量机的<strong>对偶算法（dual algorithm）</strong>。</p>
<p>这样做的优点：</p>
<ul>
<li>对偶问题往往更容易求解；</li>
<li>自然引入核函数，进而推广到非线性分类问题。</li>
</ul>
<p>首先构建拉格朗日函数（Lagrange function）。为此，对每一个不等式约束$(7.14)$引进拉格朗日乘子（Lagrange multiplier）$\alpha_i \geq 0,\ \ \ i = 1,2,…,N$，定义拉格朗日函数：</p>
<script type="math/tex; mode=display">
L(\omega,b,\alpha) = \frac{1}{2}||\omega||^2 - \sum\limits_{i=1}^{N}\alpha_i y_i (\omega·x_i + b) + \sum\limits_{i=1}^{N}\alpha_i\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.18)</script><p>其中，$\alpha = (\alpha_1,\alpha_2,…,\alpha_N)^T$为拉格朗日乘子向量。</p>
<p>根据拉格朗日对偶性，原始为题的对偶问题是极大极小问题：</p>
<script type="math/tex; mode=display">
\max\limits_{\alpha} \min\limits_{\omega,b}L(\omega,b,\alpha)</script><p>所以，为了得到对偶问题的解，需要先求$L(\omega,b,\alpha)$对$\omega,b$的极小，再求对$\alpha$的极大。</p>
<p>对偶最优化问题：</p>
<script type="math/tex; mode=display">
\min\limits_{\alpha} \ \ \ \frac{1}{2}\sum\limits_{i=1}^{N}\sum\limits_{j=1}^{N}\alpha_i \alpha_j y_i y_j (x_i·x_j)\ - \ \sum\limits_{i=1}^{N}\alpha_i\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.22)</script><script type="math/tex; mode=display">
s.t. \ \ \ \sum\limits_{i=1}^{N}\alpha_i y_i = 0\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.23)</script><script type="math/tex; mode=display">
\alpha_i \geq 0, \ \ \ i = 1,2,...,N\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.24)</script><p><strong>定理 7.2</strong>  设$\alpha^<em> = (\alpha^</em>_1,\alpha^<em>_2,…,\alpha^</em>_l)^T$是对偶最优化问题$(7.22)$ ~ $(7.24)$的解，则存在下标$j$，使得$\alpha_j^<em> &gt; 0$，并可按下式求得原始最优化问题$(7.13)$ ~ $(7.14)$的解$\omega^</em>,b^*$</p>
<script type="math/tex; mode=display">
\omega^* =\sum\limits_{i=1}^{N}\alpha_i y_i x_i\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.25)</script><script type="math/tex; mode=display">
b^* = y_j - \sum\limits_{i=1}^{N}\alpha_i y_i (x_i·x_j)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.26)</script><p>由此定理可知，分离超平面可以写成</p>
<script type="math/tex; mode=display">
\sum\limits_{i=1}^{N}\alpha_i^* y_i (x·x_i) + b^* = 0\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.29)</script><p>分类决策函数可以写成</p>
<script type="math/tex; mode=display">
f(x) = sign(\sum\limits_{i=1}^{N}\alpha_i^* y_i (x·x_i) + b^*)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.30)</script><p>这就是说，分类决策函数只依赖于输入$x$和训练样本输入的内积。式$(7.30)$称为线性可分支持向量机的对偶形式。</p>
<p>综上所述，对于给定的线性可分训练数据集，可以首先求对偶问题$(7.22)$ ~ $(7.24)$的解$\alpha^<em>$；再利用式$(7.25)$ ~ $(7.26)$求得原始问题的解$\omega^</em>,b^*$；从而得到分离超平面及分类决策函数。这种算法称为线性可分支持向量机的对偶学习算法，是线性可分支持向量机学习的基本算法。</p>
<p><strong>算法 7.2（线性可分支持向量机学习算法）</strong></p>
<p><strong>输入</strong>：线性可分训练数据集$T = \{(x_1,y_1),(x_2,y_2),…,(x_N,y_N)\}$，其中，$x_i \in \chi = R^n, y \in \mathcal{Y} = \{+1, -1\}, i=1,2,…,N$；</p>
<p><strong>输出</strong>：分离超平面和分类决策函数。</p>
<p>​    （1）构造并求约束最优化问题</p>
<script type="math/tex; mode=display">
\min\limits_{\alpha} \ \ \ \frac{1}{2}\sum\limits_{i=1}^{N}\sum\limits_{j=1}^{N}\alpha_i \alpha_j y_i y_j (x_i·x_j)\ + \ \sum\limits_{i=1}^{N}\alpha_i</script><script type="math/tex; mode=display">
s.t. \ \ \ \sum\limits_{i=1}^{N}\alpha_i y_i = 0</script><script type="math/tex; mode=display">
\alpha_i \geq 0, \ \ \ i = 1,2,...,N</script><p>求得最优解$\alpha^<em> = (\alpha^</em>_1,\alpha^<em>_2,…,\alpha^</em>_N)^T$。</p>
<p>​    （2）计算</p>
<script type="math/tex; mode=display">
\omega^* =\sum\limits_{i=1}^{N}\alpha_i y_i x_i</script><p>并选择$\alpha^<em>$的一个正分量$\alpha_j^</em> &gt; 0 $，计算</p>
<script type="math/tex; mode=display">
b^* = y_j - \sum\limits_{i=1}^{N}\alpha_i y_i (x_i·x_j)</script><p>​    （3）求得分离超平面</p>
<script type="math/tex; mode=display">
\omega^*·x +b^* = 0</script><p>分类决策函数：</p>
<script type="math/tex; mode=display">
f(x) = sign(\omega^*·x +b^*)</script><p>由式$(7.25)$、式$(7.26)$可知，$\omega^<em>$和$b^</em>$只依赖于训练数据中对应于$\alpha_i^<em> &gt; 0$的样本点$(x_i,y_i)$，而其他样本点对$\omega^</em>$和$b^<em>$没有影响。我们将训练数据中对应于$\alpha_i^</em> &gt; 0$的实例点$x_i \in R^n$称为支持向量。</p>
<p><strong>定义 7.4（支持向量）</strong>  考虑原始最优化问题$(7.13)$ ~ $(7.14)$及对偶最优化问题$(7.22)$ ~ $(7.24)$，将训练数据集中对应于$\alpha_i^* &gt; 0$的样本点$(x_i,y_i)$的实例$x_i \in R^n$称为支持向量。</p>
<h1 id="7-2-线性支持向量机与软间隔最大化"><a href="#7-2-线性支持向量机与软间隔最大化" class="headerlink" title="7.2 线性支持向量机与软间隔最大化"></a>7.2 线性支持向量机与软间隔最大化</h1><h2 id="7-2-1-线性支持向量机"><a href="#7-2-1-线性支持向量机" class="headerlink" title="7.2.1 线性支持向量机"></a>7.2.1 线性支持向量机</h2><p>假设给定一个特征空间上的训练数据集</p>
<script type="math/tex; mode=display">
T = \{(x_1,y_1),(x_2,y_2),...,(x_N,y_N)\}</script><p>其中，$x_i \in \chi = R^n, y \in Y = \{+1, -1\}, i=1,2,…,N$，$x_i$为第$i$个特征向量，$y_i$为$x_i$的类标记。再假设训练数据集不是线性可分的。通常情况是，训练数据中有一些<strong>特异点（outlier）</strong>，将这些特异点出去后，剩下大部分的样本点组成的集合是线性可分的。</p>
<p>线性不可分意味着某些样本点$(x_i,y_i)$不能满足函数间隔大于等于1的约束条件$(7.14)$。为了解决这个问题，可以对每个样本点$(x_i,y_i)$引进一个松弛变量$\xi_i \geq 0$，使函数间隔加上松弛变量大于等于1。这样，约束条件变为</p>
<script type="math/tex; mode=display">
y_i(\omega·x_i+b) \geq 1 - \xi_i</script><p>同时，对每个松弛变量$\xi_i$，支付一个代价$\xi_i$。目标函数由原来的$\frac{1}{2}||\omega||^2$变成</p>
<script type="math/tex; mode=display">
\frac{1}{2}||\omega||^2 \ + \ C\sum\limits_{i=1}^N \xi_i\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.31)</script><p>这里，$C&gt;0$称为惩罚参数，一般由应用问题决定，$C$值大时对误分类的惩罚增大，$C$值小时对误分类的惩罚减小。最小化目标函数$(7.31)$包含两层含义：使$\frac{1}{2}||\omega||^2 $尽量小即间隔尽量大，同时使误分类点的个数尽量小，$C$是调和二者的系数。</p>
<p>线性不可分的支持向量机的学习问题变成如下凸二次规划（convex quadratic programming）问题（原始问题）：</p>
<script type="math/tex; mode=display">
\min\limits_{\omega,b,\xi} \ \ \ \frac{1}{2}||\omega||^2 \ + \ C\sum\limits_{i=1}^N \xi_i\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.32)</script><script type="math/tex; mode=display">
s.t.\ \ \ y_i(\omega·x_i+b) \geq 1 - \xi_i \ \ \ i = 1,2,...,N\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.33)</script><script type="math/tex; mode=display">
\xi_i \geq 0,\ \ \ i = 1,2,...,N\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.34)</script><p>原始问题$(7.32)$ ~ $(7.34)$是一个凸二次规划问题，因而关于$(\omega,b,\xi)$的解是存在的。可以证明$\omega$的解是唯一的，但$b$的解可能不唯一，而是存在于一个区间。</p>
<p><strong>定义 7.5（线性支持向量机）</strong>  对于给定的线性不可分的训练数据集，通过求解凸二次规划问题，即软间隔最大化问题$(7.32)$ ~ $(7.34)$，得到的分离超平面为</p>
<script type="math/tex; mode=display">
\omega^* · x + b^* =0\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.35)</script><p>以及相应的分类决策函数</p>
<script type="math/tex; mode=display">
f(x) = sign(\omega^* · x + b^*)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.36)</script><p>称为线性支持向量机。</p>
<p>显然，线性支持向量机包含线性可分支持向量机。</p>
<h2 id="7-2-2-学习的对偶算法"><a href="#7-2-2-学习的对偶算法" class="headerlink" title="7.2.2 学习的对偶算法"></a>7.2.2 学习的对偶算法</h2><p>原始问题$(7.32)$ ~ $(7.34)$的对偶问题是</p>
<script type="math/tex; mode=display">
\min\limits_{\alpha} \ \ \ \frac{1}{2}\sum\limits_{i=1}^{N}\sum\limits_{j=1}^{N}\alpha_i \alpha_j y_i y_j (x_i·x_j)\ - \ \sum\limits_{i=1}^{N}\alpha_i\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.37)</script><script type="math/tex; mode=display">
s.t. \ \ \ \sum\limits_{i=1}^{N}\alpha_i y_i = 0\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.38)</script><script type="math/tex; mode=display">
0 \leq \alpha_i \leq C, \ \ \ i = 1,2,...,N\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.39)</script><p><strong>定理 7.3</strong>  设$\alpha^<em> = (\alpha^</em>_1,\alpha^<em>_2,…,\alpha^</em>_N)^T$是对偶问题$(7.37)$~$(7.39)$的一个解，若存在$\alpha^<em>$的一个分量$\alpha_j^</em>$，$0&lt; \alpha_j^<em>&lt;C$ ，则原始问题$(7.32)$~$(7.34)$的解$\omega^</em>,b^*$可按下式求得：</p>
<script type="math/tex; mode=display">
\omega^* =\sum\limits_{i=1}^{N}\alpha_i^* y_i x_i\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.50)</script><script type="math/tex; mode=display">
b^* = y_j - \sum\limits_{i=1}^{N}\alpha_i^* y_i (x_i·x_j)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.51)</script><p>由此定理可知，分离超平面可以写成</p>
<script type="math/tex; mode=display">
\sum\limits_{i=1}^{N}\alpha_i^* y_i (x·x_j) + b^* = 0\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.55)</script><p>分类决策函数可以写成</p>
<script type="math/tex; mode=display">
f(x)= sign(\sum\limits_{i=1}^{N}\alpha_i^* y_i (x·x_j) + b^*)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.56)</script><p><strong>算法 7.3（线性支持向量机学习算法）</strong></p>
<p><strong>输入</strong>：线性可分训练数据集$T = \{(x_1,y_1),(x_2,y_2),…,(x_N,y_N)\}$，其中，$x_i \in \chi = R^n, y \in \mathcal{Y} = \{+1, -1\}, i=1,2,…,N$；</p>
<p><strong>输出</strong>：分离超平面和分类决策函数。</p>
<p>​    （1）选择惩罚参数$C&gt;0$，构造并求解凸二次规划问题</p>
<script type="math/tex; mode=display">
\min\limits_{\alpha} \ \ \ \frac{1}{2}\sum\limits_{i=1}^{N}\sum\limits_{j=1}^{N}\alpha_i \alpha_j y_i y_j (x_i·x_j)\ - \ \sum\limits_{i=1}^{N}\alpha_i</script><script type="math/tex; mode=display">
s.t. \ \ \ \sum\limits_{i=1}^{N}\alpha_i y_i = 0</script><script type="math/tex; mode=display">
0 \leq \alpha_i \leq C, \ \ \ i = 1,2,...,N</script><p>求得最优解$\alpha^<em> = (\alpha^</em>_1,\alpha^<em>_2,…,\alpha^</em>_N)^T$。</p>
<p>​    （2）计算$\omega^<em> = \sum\limits_{i=1}^{N}\alpha_i^</em> y_i x_i$</p>
<p>选择$\alpha^<em>$的一个分量$\alpha_j^</em>$适合条件$0&lt;\alpha_j^* &lt;C$，计算</p>
<script type="math/tex; mode=display">
b^* = y_j - \sum\limits_{i=1}^{N}\alpha_i^* y_i (x_i·x_j)</script><p>​    （3）求得分离超平面</p>
<script type="math/tex; mode=display">
\omega^*·x+b^* = 0</script><p>分类决策函数</p>
<script type="math/tex; mode=display">
f(x)=sign(\omega^*·x+b^*)</script><h2 id="7-2-3-支持向量"><a href="#7-2-3-支持向量" class="headerlink" title="7.2.3 支持向量"></a>7.2.3 支持向量</h2><p>在线性不可分的情况下，将对偶问题$(7.37)$~$(7.39)$的解$\alpha^<em> = (\alpha^</em>_1,\alpha^<em>_2,…,\alpha^</em>_N)^T$中对应于$\alpha^*_i &gt; 0$的样本点$(x_i,y_i)$的实例$x_i$称为支持向量（软间隔的支持向量）。</p>
<p>软间隔的支持向量$x_i$或者在间隔边界上，或者在间隔边界与分离超平面之间，或者在分离超平面误分一侧。</p>
<ul>
<li>若$\alpha_i^* &lt;C$，则$\xi_i = 0$，支持向量$x_i$恰好落在间隔边界上；</li>
<li>若$\alpha_i^* = C$，$0&lt;\xi_i &lt;1$，则分类正确，$x_i$在间隔边界与分离超平面之间；</li>
<li>若$\alpha_i^* = C$，$\xi_i = 1$，则$x_i$在分离超平面上；</li>
<li>若$\alpha_i^* = C$，$\xi_i &gt; 1$，则$x_i$位于分离超平面误分类一侧。</li>
</ul>
<h2 id="7-2-4-合页损失函数"><a href="#7-2-4-合页损失函数" class="headerlink" title="7.2.4 合页损失函数"></a>7.2.4 合页损失函数</h2><p>线性支持向量机学习还有另外一种解释，就是最小化以下目标函数：</p>
<script type="math/tex; mode=display">
\sum\limits_{i=1}^{N}[1-y_i(\omega·x +b)]_{+} + \lambda||\omega||^2\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.57)</script><ul>
<li><p>目标函数的第1项是经验损失或经验风险，函数</p>
<script type="math/tex; mode=display">
L(y(\omega·x + b)) = [1-y(\omega·x+b)]_{+}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.58)</script><p>称为<strong>合页损失函数（hinge loss function）</strong>。下标“+”表示以下去正值的函数。</p>
<script type="math/tex; mode=display">
[z]_{+} = \lbrace_{0,\ \ \ z \leq 0}^{z, \ \ \ z >0}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.59)</script><p>这就是说，当样本点$(x_i,y_i)$被正确分类且函数间隔（确信度）$y_i(\omega·x_i+b)$大于1时，损失是0，否则损失是$1-y_i(\omega·x_i+b)$。</p>
</li>
<li><p>目标函数的第2项是系数为$\lambda$的$\omega$的$L_2$范数，是正则化项。</p>
</li>
</ul>
<p><strong>定理 7.4</strong>  线性支持向量机原始最优化问题：</p>
<script type="math/tex; mode=display">
\min\limits_{\omega,b,\xi} \ \ \ \frac{1}{2}||\omega||^2 \ + \ C\sum\limits_{i=1}^N \xi_i</script><script type="math/tex; mode=display">
s.t.\ \ \ y_i(\omega·x_i+b) \geq 1 - \xi_i \ \ \ i = 1,2,...,N</script><script type="math/tex; mode=display">
\xi_i \geq 0,\ \ \ i = 1,2,...,N</script><p>等价于最优化问题</p>
<script type="math/tex; mode=display">
\min\limits_{\omega,b}\ \ \ \sum\limits_{i=1}^{N}[1-y_i(\omega·x +b)]_{+} + \lambda||\omega||^2\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.63)</script><p>合页损失函数横轴是函数间隔$y(\omega·x +b)$，纵轴是损失。由于函数形状像一个合页，故名合页损失函数。</p>
<p>0-1损失函数，可以认为它是二分类问题的真正的损失函数，而合页损失函数是0-1损失函数的上界。由于0-1损失函数不是连续可导的，直接优化由其构成的目标函数比较困难，可以认为线性支持向量机是优化由0-1损失函数的上界（合页损失函数）构成的目标函数。这时的上界损失函数又称为<strong>代理损失函数（surrogate loss function）</strong>。</p>
<p>合页损失函数不仅要分类正确，而且确信度足够高时损失才是0。也就是说，合页损失函数对学习有更高的要求。</p>
<h1 id="7-3-非线性支持向量机与核函数"><a href="#7-3-非线性支持向量机与核函数" class="headerlink" title="7.3 非线性支持向量机与核函数"></a>7.3 非线性支持向量机与核函数</h1><p>非线性支持向量机主要特点是利用核技巧（kernel trick）。</p>
<h2 id="7-3-1-核技巧"><a href="#7-3-1-核技巧" class="headerlink" title="7.3.1 核技巧"></a>7.3.1 核技巧</h2><ol>
<li><strong>非线性分类问题</strong></li>
</ol>
<p>一般来说，对给定的一个训练数据集$T = \{(x_1,y_1),(x_2,y_2),…,(x_N,y_N)\}$，其中，$x_i \in \chi = R^n, y \in Y = \{+1, -1\}, i=1,2,…,N$。如果能用$R^n$中的一个超曲面将正负例正确分开，则称这个问题为非线性可分问题。</p>
<p>非线性问题往往不好求解，所以希望能用解线性分类问题的方法解决这个问题。所采取的方法是进行一个非线性变换，将非线性问题变换为线性问题，通过解变换后的线性问题的方法求解原来的非线性问题。</p>
<p>用线性分类方法求解非线性分类问题分为两步：</p>
<ul>
<li>使用一个变换将原空间的数据映射到新空间；</li>
<li>在新空间里用线性分类学习方法从训练数据中学习分类模型。</li>
</ul>
<hr>
<ol>
<li><strong>核函数的定义</strong></li>
</ol>
<p><strong>定义 7.6 （核函数）</strong>  设$\chi$是输入空间（欧式空间$R^n$的子集或离散集合），又设$\mathcal{H}$为特征空间（希尔伯特空间），如果存在一个从$\mathcal{X}$到$\mathcal{H}$的映射</p>
<script type="math/tex; mode=display">
\phi(x) : \mathcal{X} \longrightarrow \mathcal{H}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.65)</script><p>使得对所有$x,z \in \mathcal{X}$，函数$K(x,z)$满足条件</p>
<script type="math/tex; mode=display">
K(x,z) = \phi(x)·\phi(z)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.66)</script><p>则称$K(x,z)$为核函数，$\phi(x)$为映射函数，式中$\phi(x)·\phi(z)$为$\phi(x)$和$\phi(z)$的内积。</p>
<hr>
<p>核技巧想法是，在学习与预测中只定义核函数$K(x,z)$，而不显示地定义映射函数$\phi$。通常，直接计算$K(x,z)$比较容易，而通过$\phi(x)$和$\phi(z)$计算$K(x,z)$并不容易。</p>
<p>对于给定的核$K(x,z)$，特征空间$\mathcal{H}$和映射函数$\phi$的取法并不唯一，可以取不同的特征空间，即便是在同一特征空间里也可以取不同的映射。</p>
<hr>
<ol>
<li><strong>核技巧在支持向量机中的应用</strong></li>
</ol>
<p>在线性支持向量机的对偶问题中，无论是目标函数还是决策函数（分离超平面）都只涉及输入实例与实例之间的内积。在对偶问题的目标函数$(7.37)$中内积$x_i·x_j$可以用核函数$K(x_i,x_j) = \phi(x_i)·\phi(x_j)$来代替。此时对偶问题的目标函数成为</p>
<script type="math/tex; mode=display">
W(\alpha) = \frac{1}{2}\sum\limits_{i=1}^{N}\sum\limits_{j=1}^{N}\alpha_i \alpha_j y_i y_j K(x_i,x_j)\ - \ \sum\limits_{i=1}^{N}\alpha_i\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.67)</script><p>同样，分类决策函数中的内积也可以用核函数代替，而分类决策函数式成为</p>
<script type="math/tex; mode=display">
f(x)= sign(\sum\limits_{i=1}^{N}\alpha_i^* y_i \phi(x)·\phi(x_j) + b^*)</script><script type="math/tex; mode=display">
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ =sign(\sum\limits_{i=1}^{N}\alpha_i^* y_i K(x_i,x) + b^*)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.68)</script><p>这等价于经过映射函数$\phi$将原来的输入空间变换到一个新的特征空间，将输入空间中的内积$x_i·x_j$变换为特征空间中的内积$\phi(x_i)·\phi(x_j)$，在新的特征空间里从训练样本中学习线性支持向量机。当映射函数是非线性函数时，学习到的含有核函数的支持向量机是非线性分类模型。</p>
<p>在核函数$K(x,z)$给定的条件下，可以利用解线性分类问题的方法来求解非线性分类问题的支持向量机。学习是隐式地在特征空间进行的，不需要显式地定义特征空间和映射函数。这样的技巧称为核技巧，它是巧妙地利用线性分类学习方法与核函数解决非线性问题的技术。</p>
<h2 id="7-3-2-正定核"><a href="#7-3-2-正定核" class="headerlink" title="7.3.2 正定核"></a>7.3.2 正定核</h2><p>通常所说的核函数就是<strong>正定核函数（positive definite kernel function）</strong>。</p>
<p>假设$K(x,z)$是定义在$\mathcal{X} \times \mathcal{X}$上的对称函数，并且对任意的$x_i,x_2,…,x_m \in \mathcal{X}$，$K(x,z)$关于$x_i,x_2,…,x_m$的$Gram$矩阵是半正定的。可以依据函数$K(x,z)$，构成一个希尔伯特空间(Hilbert space)，其步骤是：首先定义映射$\phi$并构成向量空间$\mathcal{S}$；然后在$\mathcal{S}$上定义内积构成内积空间；最后将$\mathcal{S}$完备化构成希尔伯特空间。</p>
<ol>
<li><strong>定义映射，构成向量空间$\mathcal{S}$</strong></li>
</ol>
<p>先定义映射</p>
<script type="math/tex; mode=display">
\phi : x \longrightarrow K(·,x)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.69)</script><p>根据这一映射，对任意$x_i \in \mathcal{X},\alpha_i \in R,i=1,2,…,m$，定义线性组合</p>
<script type="math/tex; mode=display">
f(·)=\sum\limits_{i=1}^{m}\alpha_i K(·,x_i)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.70)</script><p>考虑由线性组合为元素的集合$\mathcal{S}$。由于集合$\mathcal{S}$对加法和数乘运算是封闭的，所以$\mathcal{S}$构成一个向量空间。</p>
<ol>
<li><strong>在$\mathcal{S}$上定义内积，使其成为内积空间</strong></li>
</ol>
<p>在$\mathcal{S}$上定义一个运算$*$：对任意$f,g \in \mathcal{S}$,</p>
<script type="math/tex; mode=display">
f(·)=\sum\limits_{i=1}^{m}\alpha_i K(·,x_i)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.71)</script><script type="math/tex; mode=display">
g(·)=\sum\limits_{j=1}^{l}\beta_j K(·,z_j)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.72)</script><p>定义运算$*$</p>
<script type="math/tex; mode=display">
f * g = \sum\limits_{i=1}^{m}\sum\limits_{j=1}^{l}\alpha_i\beta_j K(x_i,z_j)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.73)</script><p>赋予内积的向量空间为内积空间。因此$\mathcal{S}$是一个内积空间。既然$*$为$\mathcal{S}$的内积运算，那么仍然用$·$表示，即</p>
<script type="math/tex; mode=display">
f · g = \sum\limits_{i=1}^{m}\sum\limits_{j=1}^{l}\alpha_i\beta_j K(x_i,z_j)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.74)</script><ol>
<li><strong>将内积空间</strong>$\mathcal{S}$<strong>完备化为希尔伯特空间</strong></li>
</ol>
<p>现将内积空间$\mathcal{S}$完备化。由式$(7.81)$定义的内积可以得到范数</p>
<script type="math/tex; mode=display">
||f|| = \sqrt{f·f}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.82)</script><p>因此，$\mathcal{S}$是一个赋范向量空间。根据泛函分析理论，对于不完备的赋范向量空间$\mathcal{S}$，一定可以使之完备化，得到完备的赋范向量空间$\mathcal{H}$。一个内积空间，当作为一个赋范向量空间是完备的时候，就是希尔伯特空间。这样，就得到了希尔伯特空间$\mathcal{H}$。</p>
<p>这一希尔伯特空间$\mathcal{H}$称为<strong>再生核希尔伯特空间（reproducing kernel Hilbert space，RKHS）</strong>。这是由于核$K$具有再生性，即满足</p>
<script type="math/tex; mode=display">
K(·,x)·f = f(x)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.83)</script><p>及</p>
<script type="math/tex; mode=display">
K(·,x) · K(·,z) = K(x,z)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.84)</script><p>称为再生核。</p>
<ol>
<li><strong>正定核的充要条件</strong></li>
</ol>
<p><strong>定理 7.5（正定核的充要条件）</strong>  设$K:\mathcal{X} \times \mathcal{X} \longrightarrow R$是对称函数，则$K(x,z)$为正定核函数的充要条件是对任意$x_i \in \mathcal{X},i=1,2,…,m$，$K(x,z)$对应的$Gram$矩阵：</p>
<script type="math/tex; mode=display">
K = [K(x_i,x_j)]_{m \times m}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.85)</script><p>是半正定矩阵。</p>
<p><strong>定义 7.7（正定核的等价定义）</strong>  设$\mathcal{X} \subset R^n$，$K(x,z)$是定义在$\mathcal{X} \times \mathcal{X}$上的对称函数，如果对任意$x_i \in \mathcal{X},i=1,2,…,m$，$K(x,z)$对应的$Gram$矩阵</p>
<script type="math/tex; mode=display">
K = [K(x_i,x_j)]_{m \times m}</script><p>是半正定矩阵，则称$K(x,z)$是正定核。</p>
<h2 id="7-3-3-常用核函数"><a href="#7-3-3-常用核函数" class="headerlink" title="7.3.3 常用核函数"></a>7.3.3 常用核函数</h2><ol>
<li><strong>多项式核函数（polynomial kernel function）</strong></li>
</ol>
<script type="math/tex; mode=display">
K(x,z) = (x·z + 1 )^p\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.88)</script><p>对应的支持向量机是一个$p$次多项式分类器。在此情形下，分类决策函数成为</p>
<script type="math/tex; mode=display">
f(x) = sign(\sum\limits_{i=1}^{N_\mathcal{S}}a_i^* y_i(x_i·x + 1)^p + b^*)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.89)</script><ol>
<li><strong>高斯核函数（Gaussian kernel function）</strong></li>
</ol>
<script type="math/tex; mode=display">
K(x,z) = exp(-\frac{||x-z||^2}{2\sigma^2})\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.90)</script><p>对应的支持向量机是<strong>高斯径向基函数（radial basis function）</strong>分类器。在此情形下，分类决策函数成为</p>
<script type="math/tex; mode=display">
f(x) = sign(\sum\limits_{i=1}^{N_\mathcal{S}}a_i^* y_iexp(-\frac{||x-x_i||^2}{2\sigma^2}) + b^*)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.91)</script><ol>
<li><strong>字符串核函数（string kernel function）</strong></li>
</ol>
<p>核函数不仅可以定义在欧式空间上，还可以定义在离散数据的集合上。</p>
<p>两个字符串$s$和$t$上的字符串核函数是基于映射$\phi$的特征空间中的内积：</p>
<script type="math/tex; mode=display">
k_n(s,t) = \sum\limits_{u\in \sum^n}[\phi_n(s)]_u [\phi_n(t)]_u</script><script type="math/tex; mode=display">
= \sum\limits_{u\in \sum^n}\sum\limits_{(i,j):s(i)=t(j)=u}\lambda^{l(i)}\lambda^{l(j)}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.93)</script><p>字符串核函数$k_n(s,t)$给出了字符串$s$和$t$中长度等于$n$的所有子串组成的特征向量的<strong>余弦相似度（cosine similarity）</strong>。直观上，两个字符串相同的子串越多，他们就越相似，字符串核函数的值就越大。</p>
<h2 id="7-3-4-非线性支持向量分类机"><a href="#7-3-4-非线性支持向量分类机" class="headerlink" title="7.3.4 非线性支持向量分类机"></a>7.3.4 非线性支持向量分类机</h2><p>将线性支持向量机扩展到非线性支持向量机，只需将线性支持向量机对偶形式中的内积换成核函数。</p>
<p><strong>定义 7.8（非线性支持向量机）</strong>  从非线性分类训练集，通过核函数与软间隔最大化，或凸二次规划$(7.95)$~$(7.97)$，学习得到的分类决策函数</p>
<script type="math/tex; mode=display">
f(x) = sign(\sum\limits_{i=1}^{N}\alpha_i^* y_i K(x,x_i) + b^*)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.94)</script><p>称为非线性支持向量机，$K(x,z)$是正定核函数。</p>
<hr>
<p>算法 7.4 （非线性支持向量机学习算法）</p>
<p><strong>输入</strong>：训练数据集$T = \{(x_1,y_1),(x_2,y_2),…,(x_N,y_N)\}$，其中，$x_i \in \chi = R^n, y \in \mathcal{Y} = \{+1, -1\}, i=1,2,…,N$；</p>
<p><strong>输出</strong>：分类决策函数。</p>
<p>​    （1）选取适当的核函数$K(x,z)$和适当的参数$C$，构造并求解最优化问题</p>
<script type="math/tex; mode=display">
\min\limits_{\alpha}\ \ \  \frac{1}{2}\sum\limits_{i=1}^{N}\sum\limits_{j=1}^{N}\alpha_i \alpha_j y_i y_j K(x_i,x_j)\ - \ \sum\limits_{i=1}^{N}\alpha_i\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.95)</script><script type="math/tex; mode=display">
s.t. \ \ \ \ \sum\limits_{i=1}^{N}\alpha_iy_i = 0\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.96)</script><script type="math/tex; mode=display">
0 \leq \alpha_i \leq C,\ \ \ i = 1,2,...,N\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.97)</script><p>求得最优解$\alpha^<em> = (\alpha^</em>_1,\alpha^<em>_2,…,\alpha^</em>_N)^T$。</p>
<p>​    （2）选择$\alpha^<em>$的一个正分量$0&lt;\alpha_j^</em> &lt; C$，计算</p>
<script type="math/tex; mode=display">
b^* = y_j - \sum\limits_{i=1}^{N}\alpha_i^* y_i K(x_i·x_j)</script><p>​    （3）构造决策函数：</p>
<script type="math/tex; mode=display">
f(x) = sign(\sum\limits_{i=1}^{N}\alpha_i^* y_i K(x,x_i) + b^*)</script><p>当$K(x,z)$是正定核函数时，问题$(7.95)$~$(7.97)$是凸二次规划问题，解是存在的。</p>
<h1 id="7-4-序列最小最优化算法"><a href="#7-4-序列最小最优化算法" class="headerlink" title="7.4 序列最小最优化算法"></a>7.4 序列最小最优化算法</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/11/Data%20_Competition/Python_Foundation/%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/11/Data%20_Competition/Python_Foundation/%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E7%B1%BB/" class="post-title-link" itemprop="url">第九章 类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-11 16:17:10" itemprop="dateCreated datePublished" datetime="2021-06-11T16:17:10+08:00">2021-06-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-02 21:52:56" itemprop="dateModified" datetime="2021-07-02T21:52:56+08:00">2021-07-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">数据竞赛</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/06/11/Data%20_Competition/Python_Foundation/%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E7%B1%BB/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/06/11/Data%20_Competition/Python_Foundation/%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E7%B1%BB/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="9-1-创建和使用类"><a href="#9-1-创建和使用类" class="headerlink" title="9.1 创建和使用类"></a>9.1 创建和使用类</h1><p>使用类几乎可以模拟任何东西。</p>
<h2 id="9-1-1-创建一个类"><a href="#9-1-1-创建一个类" class="headerlink" title="9.1.1 创建一个类"></a>9.1.1 创建一个类</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;创建一个类来模拟小狗&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sit</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;模拟小狗收到命令时蹲下&quot;&quot;&quot;</span></span><br><span class="line">        print(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> is now sitting.&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">roll_over</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;模拟小狗收到命令时打滚&quot;&quot;&quot;</span></span><br><span class="line">        print(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> rolled over!&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>类中的函数称为<strong>方法</strong>。</li>
<li>通过实例访问的变量称为<strong>属性</strong>。</li>
</ul>
<p><strong>方法__init__()</strong>：方法__init__()是一个特殊方法，每当根据类创建一个新实例时，Python都会自动运行它。在这个方法的定义中，形参self必不可少，而且必须位于其他形参的前面。每个与实例相关联的方法调用都会自动传递实参self，它是一个指向实例本身的引用，让实例能够访问类中的属性和方法。</p>
<p>注意：方法__init__() 前后有两个_。</p>
<h2 id="9-1-2-根据类创建实例"><a href="#9-1-2-根据类创建实例" class="headerlink" title="9.1.2 根据类创建实例"></a>9.1.2 根据类创建实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;创建一个类来模拟小狗&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sit</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;模拟小狗收到命令时蹲下&quot;&quot;&quot;</span></span><br><span class="line">        print(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> is now sitting.&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">roll_over</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;模拟小狗收到命令时打滚&quot;&quot;&quot;</span></span><br><span class="line">        print(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> rolled over!&quot;</span>)</span><br><span class="line"> </span><br><span class="line">my_dog = Dog(<span class="string">&#x27;willie&#x27;</span>, <span class="number">6</span>)</span><br><span class="line">print(<span class="string">f&quot;My dog`s name is <span class="subst">&#123;my_dog.name&#125;</span>&quot;</span>)</span><br><span class="line">print(<span class="string">f&quot;My og is <span class="subst">&#123;my_dog.age&#125;</span> years old&quot;</span>)        </span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">My dog&#96;s name is willie</span><br><span class="line">My dog is 6 years old</span><br></pre></td></tr></table></figure>
<ol>
<li>访问属性</li>
</ol>
<p>要访问实例的属性，可使用句点表示法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_dog.name</span><br></pre></td></tr></table></figure>
<ol>
<li>调用方法</li>
</ol>
<p>要调用方法，可指定实例的名称和要调用的方法，并用句点分隔。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_dog.sit()</span><br><span class="line">my_dog.roll_over()</span><br></pre></td></tr></table></figure>
<h1 id="9-2-使用类和实例"><a href="#9-2-使用类和实例" class="headerlink" title="9.2 使用类和实例"></a>9.2 使用类和实例</h1><p>可使用类来模拟现实世界中的很多情景。类编写好后，大部分时间将花在根据类创建的实例上。可以直接修改实例的属性，也可以编写方法以特定的方式进行修改。</p>
<h2 id="9-2-1-修改属性的值"><a href="#9-2-1-修改属性的值" class="headerlink" title="9.2.1 修改属性的值"></a>9.2.1 修改属性的值</h2><ol>
<li><p>直接修改属性的值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;创建一个类来模拟小狗&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sit</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;模拟小狗收到命令时蹲下&quot;&quot;&quot;</span></span><br><span class="line">        print(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> is now sitting.&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">roll_over</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;模拟小狗收到命令时打滚&quot;&quot;&quot;</span></span><br><span class="line">        print(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> rolled over!&quot;</span>)</span><br><span class="line"> </span><br><span class="line">my_dog = Dog(<span class="string">&#x27;willie&#x27;</span>, <span class="number">6</span>)</span><br><span class="line">print(<span class="string">f&quot;My dog`s name is <span class="subst">&#123;my_dog.name&#125;</span>&quot;</span>)</span><br><span class="line">print(<span class="string">f&quot;My dog is <span class="subst">&#123;my_dog.age&#125;</span> years old&quot;</span>)    </span><br><span class="line">my_dog.age = <span class="number">7</span>    <span class="comment">#直接修改属性的值</span></span><br><span class="line">print(<span class="string">f&quot;Now, My dog is <span class="subst">&#123;my_dog.age&#125;</span> years old&quot;</span>)   </span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">My dog&#96;s name is willie</span><br><span class="line">My dog is 6 years old</span><br><span class="line">Now, My dog is 7 years old</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过方法修改属性的值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;创建一个类来模拟小狗&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sit</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;模拟小狗收到命令时蹲下&quot;&quot;&quot;</span></span><br><span class="line">        print(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> is now sitting.&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">roll_over</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;模拟小狗收到命令时打滚&quot;&quot;&quot;</span></span><br><span class="line">        print(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> rolled over!&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_age</span>(<span class="params">self, add_value</span>):</span></span><br><span class="line">        self.age = self.age + add_value</span><br><span class="line">        </span><br><span class="line">my_dog = Dog(<span class="string">&#x27;willie&#x27;</span>, <span class="number">6</span>)</span><br><span class="line">print(<span class="string">f&quot;My dog`s name is <span class="subst">&#123;my_dog.name&#125;</span>&quot;</span>)</span><br><span class="line">print(<span class="string">f&quot;My dog is <span class="subst">&#123;my_dog.age&#125;</span> years old&quot;</span>)    </span><br><span class="line">my_dog.add_age(<span class="number">2</span>) </span><br><span class="line">print(<span class="string">f&quot;Now, My dog is <span class="subst">&#123;my_dog.age&#125;</span> years old&quot;</span>)   </span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">My dog&#96;s name is willie</span><br><span class="line">My dog is 6 years old</span><br><span class="line">Now, My dog is 8 years old</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="9-3-继承"><a href="#9-3-继承" class="headerlink" title="9.3 继承"></a>9.3 继承</h1><p>编写类时，并非总是要从空白开始。如果要编写的类是另一个现成类的特殊版本，可使用继承。一个类继承另一个类时，将自动获得另一个类的所有属性和方法。原有的类称为父类，而新类称为子类。子类继承了父类的所有属性和方法，同时还可以定义自己的属性和方法。</p>
<h2 id="9-3-1-子类的方法-init"><a href="#9-3-1-子类的方法-init" class="headerlink" title="9.3.1 子类的方法__init__()"></a>9.3.1 子类的方法__init__()</h2><p>在既有类的基础上编写新类时，通常要调用父类的方法__init__()。这将初始化在父类__init__()方法中定义的所有属性。从而让子类包含这些属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;创建一个类来模拟小狗&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sit</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;模拟小狗收到命令时蹲下&quot;&quot;&quot;</span></span><br><span class="line">        print(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> is now sitting.&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">roll_over</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;模拟小狗收到命令时打滚&quot;&quot;&quot;</span></span><br><span class="line">        print(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> rolled over!&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_age</span>(<span class="params">self, add_value</span>):</span></span><br><span class="line">        self.age = self.age + add_value</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeaDog</span>(<span class="params">Dog</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name, age)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">my_sea_dog = SeaDog(<span class="string">&#x27;sea_willie&#x27;</span>, <span class="number">10</span>)</span><br><span class="line">print(<span class="string">f&quot;My dog`s name is <span class="subst">&#123;my_sea_dog.name&#125;</span>&quot;</span>)</span><br><span class="line">print(<span class="string">f&quot;My dog is <span class="subst">&#123;my_sea_dog.age&#125;</span> years old&quot;</span>)    </span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">My dog&#96;s name is sea_willie</span><br><span class="line">My dog is 10 years old</span><br></pre></td></tr></table></figure>
<p>super()是一个特殊函数，能够调用父类的方法。父类也称为<strong>超类</strong>（superclass），名称super由此而来。</p>
<h2 id="9-3-2-给子类定义属性和方法"><a href="#9-3-2-给子类定义属性和方法" class="headerlink" title="9.3.2 给子类定义属性和方法"></a>9.3.2 给子类定义属性和方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;创建一个类来模拟小狗&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sit</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;模拟小狗收到命令时蹲下&quot;&quot;&quot;</span></span><br><span class="line">        print(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> is now sitting.&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">roll_over</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;模拟小狗收到命令时打滚&quot;&quot;&quot;</span></span><br><span class="line">        print(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> rolled over!&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_age</span>(<span class="params">self, add_value</span>):</span></span><br><span class="line">        self.age = self.age + add_value</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeaDog</span>(<span class="params">Dog</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name, age)</span><br><span class="line">        self.skill = <span class="string">&#x27;swim&#x27;</span> <span class="comment">#定义子类自己的属性</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">describe_sea_dog</span>(<span class="params">self</span>):</span> <span class="comment">#定义子类自己的方法</span></span><br><span class="line">        print(<span class="string">f&quot;sea dog can <span class="subst">&#123;self.skill&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">my_sea_dog = SeaDog(<span class="string">&#x27;sea_willie&#x27;</span>, <span class="number">10</span>)</span><br><span class="line">print(<span class="string">f&quot;My dog`s name is <span class="subst">&#123;my_sea_dog.name&#125;</span>&quot;</span>)</span><br><span class="line">print(<span class="string">f&quot;My dog is <span class="subst">&#123;my_sea_dog.age&#125;</span> years old&quot;</span>)   </span><br><span class="line">my_sea_dog.describe_sea_dog() </span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">My dog&#96;s name is sea_willie</span><br><span class="line">My dog is 10 years old</span><br><span class="line">sea dog can swim</span><br></pre></td></tr></table></figure>
<h2 id="9-3-3-重写父类的方法"><a href="#9-3-3-重写父类的方法" class="headerlink" title="9.3.3 重写父类的方法"></a>9.3.3 重写父类的方法</h2><p>对于父类的方法，只要它不符合子类模拟的实物行为，都可以进行重写。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;创建一个类来模拟小狗&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sit</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;模拟小狗收到命令时蹲下&quot;&quot;&quot;</span></span><br><span class="line">        print(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> is now sitting.&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">roll_over</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;模拟小狗收到命令时打滚&quot;&quot;&quot;</span></span><br><span class="line">        print(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> rolled over!&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_age</span>(<span class="params">self, add_value</span>):</span></span><br><span class="line">        self.age = self.age + add_value</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeaDog</span>(<span class="params">Dog</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name, age)</span><br><span class="line">        self.skill = <span class="string">&#x27;swim&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">describe_sea_dog</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">f&quot;sea dog can <span class="subst">&#123;self.skill&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">roll_over</span>(<span class="params">self</span>):</span><span class="comment"># 重写父类的打滚方法</span></span><br><span class="line">        print(<span class="string">&quot;sea dog can&#x27;t roll over!&quot;</span>)</span><br><span class="line">        </span><br><span class="line">my_sea_dog = SeaDog(<span class="string">&#x27;sea_willie&#x27;</span>, <span class="number">10</span>)</span><br><span class="line">print(<span class="string">f&quot;My dog`s name is <span class="subst">&#123;my_sea_dog.name&#125;</span>&quot;</span>)</span><br><span class="line">print(<span class="string">f&quot;My dog is <span class="subst">&#123;my_sea_dog.age&#125;</span> years old&quot;</span>)   </span><br><span class="line">my_sea_dog.describe_sea_dog() </span><br><span class="line">my_sea_dog.roll_over()</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">My dog&#96;s name is sea_willie</span><br><span class="line">My dog is 10 years old</span><br><span class="line">sea dog can swim</span><br><span class="line">sea dog can&#39;t roll over!</span><br></pre></td></tr></table></figure>
<h2 id="9-3-4-将实例用作属性"><a href="#9-3-4-将实例用作属性" class="headerlink" title="9.3.4 将实例用作属性"></a>9.3.4 将实例用作属性</h2><p>使用代码模拟实物时，可能会发现自己给类添加的细节越来越多：属性和方法清单以及文件都越来越长。在这种情况下，可能需要将类的一部分提取出来，作为一个单独的类。可以将大型类拆分成多个协同工作得小类。</p>
<h1 id="9-4-导入类"><a href="#9-4-导入类" class="headerlink" title="9.4 导入类"></a>9.4 导入类</h1><p>随着不断给类添加功能，文件可能变得很长，即便妥善地使用了继承亦如此。为遵循Python的总体理念，应让文件尽可能整洁。Python在这方面提供了帮助，允许将类存储在模块中，然后在主程序中导入所需的模块。</p>
<h2 id="9-4-1-导入单个类"><a href="#9-4-1-导入单个类" class="headerlink" title="9.4.1 导入单个类"></a>9.4.1 导入单个类</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> module_name <span class="keyword">import</span> ClassName</span><br></pre></td></tr></table></figure>
<h2 id="9-4-2从一个模块中导入多个类"><a href="#9-4-2从一个模块中导入多个类" class="headerlink" title="9.4.2从一个模块中导入多个类"></a>9.4.2从一个模块中导入多个类</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> module_name <span class="keyword">import</span> ClassName1, ClassName2, ClassName3</span><br></pre></td></tr></table></figure>
<h2 id="9-4-3-导入整个模块"><a href="#9-4-3-导入整个模块" class="headerlink" title="9.4.3 导入整个模块"></a>9.4.3 导入整个模块</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> module_name</span><br></pre></td></tr></table></figure>
<h2 id="9-4-4-导入模块中的所有类"><a href="#9-4-4-导入模块中的所有类" class="headerlink" title="9.4.4 导入模块中的所有类"></a>9.4.4 导入模块中的所有类</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> module_name <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>
<h2 id="9-4-5-使用别名"><a href="#9-4-5-使用别名" class="headerlink" title="9.4.5 使用别名"></a>9.4.5 使用别名</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> module_name <span class="keyword">import</span> ClassName <span class="keyword">as</span> CN</span><br></pre></td></tr></table></figure>
<h1 id="9-5-Python标准库"><a href="#9-5-Python标准库" class="headerlink" title="9.5 Python标准库"></a>9.5 Python标准库</h1><p>Python标准库是一组模块，安装的Python都包含它。</p>
<p>模块random演示</p>
<p>在这个模块中，一个有趣的函数是randint()。它将两个整数作为参数，并随机返回一个位于这两个整数之间（含）的整数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    print(randint(<span class="number">1</span>, <span class="number">6</span>))</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">2</span><br><span class="line">6</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>另一个有用的函数是choic()。它将一个列表或元组作为参数，并随机返回其中的一个元素：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    print(choice(numbers))</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h1 id="9-6-类编码风格"><a href="#9-6-类编码风格" class="headerlink" title="9.6 类编码风格"></a>9.6 类编码风格</h1><p>类名应采用驼峰命名法，即将类名中的每个单词的首字母都大写，而不使用下划线。实例命名和模块命名都采用小写格式，并在单词之间加上下划线。</p>
<p>在类中，可使用一个空行来分隔方法；而在模块中，可使用两个空行来分隔类。</p>
<p>需要同时导入标准库中的模块和编写的模块时，先编写导入标准库模块的语句，再添加一个空行，然后编写导入自己编写的模块语句。在包含多条import语句的程序中，这种做法让人更容易明白程序使用的各个模块都来自何处。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/10/Data%20_Competition/Python_Foundation/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/10/Data%20_Competition/Python_Foundation/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">第八章 函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-10 20:24:46" itemprop="dateCreated datePublished" datetime="2021-06-10T20:24:46+08:00">2021-06-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-02 21:53:06" itemprop="dateModified" datetime="2021-07-02T21:53:06+08:00">2021-07-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">数据竞赛</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/06/10/Data%20_Competition/Python_Foundation/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%87%BD%E6%95%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/06/10/Data%20_Competition/Python_Foundation/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%87%BD%E6%95%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="8-1-定义函数"><a href="#8-1-定义函数" class="headerlink" title="8.1 定义函数"></a>8.1 定义函数</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_user</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;显示简单的问候语。&quot;&quot;&quot;</span></span><br><span class="line">    print(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line"></span><br><span class="line">greet_user()</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello!</span><br></pre></td></tr></table></figure>
<p>使用关键字def来告诉Python，要定义一个函数。这是函数定义，向Python指出了函数名，还可能在圆括号内指出函数为完成任务需要什么样的信息。</p>
<p>用三对引号括起来的文本称为<strong>文档字符串（docstring）</strong>的注释，描述了函数是做什么的。</p>
<h2 id="8-1-1-向函数传递信息"><a href="#8-1-1-向函数传递信息" class="headerlink" title="8.1.1 向函数传递信息"></a>8.1.1 向函数传递信息</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_user</span>(<span class="params">username</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;显示简单的问候语&quot;&quot;&quot;</span></span><br><span class="line">    print(<span class="string">f&quot;Hello,<span class="subst">&#123;username&#125;</span>!&quot;</span>)</span><br><span class="line"></span><br><span class="line">greet_user(<span class="string">&quot;zhangsan&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello,zhangsan!</span><br></pre></td></tr></table></figure>
<h2 id="8-1-2-实参和形参"><a href="#8-1-2-实参和形参" class="headerlink" title="8.1.2 实参和形参"></a>8.1.2 实参和形参</h2><p>在函数greet_user()的定义中，变量username是一个<strong>形参（parameter）</strong>，即函数完成工作所需的信息。在代码greet_user(“zhangsan”)中，值“zhangsan”是一个<strong>实参（argument）</strong>，即调用函数时传递给函数的信息。</p>
<h1 id="8-2-传递实参"><a href="#8-2-传递实参" class="headerlink" title="8.2 传递实参"></a>8.2 传递实参</h1><p>向函数传递实参的方式很多：</p>
<ul>
<li>使用<strong>位置实参</strong>，这要求实参的顺序与形参的顺序相同；</li>
<li>使用<strong>关键字实参</strong>，其中每个实参都由变量名和值组成；</li>
<li>使用<strong>列表</strong>和<strong>字典</strong>。</li>
</ul>
<h2 id="8-2-1-位置实参"><a href="#8-2-1-位置实参" class="headerlink" title="8.2.1 位置实参"></a>8.2.1 位置实参</h2><p>调用函数时，Python必须将函数调用中的每个实参都关联到函数定义中的一个形参。为此，最简单的关联方式就是基于实参的顺序。这种关联方式称为<strong>位置实参</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe_person</span>(<span class="params">person_name, person_age</span>):</span></span><br><span class="line">    print(<span class="string">f&quot;my name is <span class="subst">&#123;person_name&#125;</span>,i am <span class="subst">&#123;person_age&#125;</span> yesrs old~&quot;</span>)</span><br><span class="line">  </span><br><span class="line">describe_person(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">24</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my name is zhangsan,i am 24 yesrs old~</span><br></pre></td></tr></table></figure>
<ol>
<li><p>多次调用函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe_person</span>(<span class="params">person_name, person_age</span>):</span></span><br><span class="line">    print(<span class="string">f&quot;my name is <span class="subst">&#123;person_name&#125;</span>,i am <span class="subst">&#123;person_age&#125;</span> yesrs old~&quot;</span>)</span><br><span class="line">  </span><br><span class="line">describe_person(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">24</span>)</span><br><span class="line">describe_person(<span class="string">&quot;lisi&quot;</span>, <span class="number">30</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my name is zhangsan,i am 24 yesrs old~</span><br><span class="line">my name is lisi,i am 30 yesrs old~</span><br></pre></td></tr></table></figure>
</li>
<li><p>位置实参的顺序很重要</p>
<p>使用位置实参来调用函数时，如果实参的顺序不正确，结果可能出乎意料：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe_person</span>(<span class="params">person_name, person_sex</span>):</span></span><br><span class="line">    print(<span class="string">f&quot;my name is <span class="subst">&#123;person_name&#125;</span>,i am <span class="subst">&#123;person_sex&#125;</span>&quot;</span>)</span><br><span class="line">  </span><br><span class="line">describe_person(<span class="string">&quot;male&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my name is male,i am zhangsan</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="8-2-2-关键字实参"><a href="#8-2-2-关键字实参" class="headerlink" title="8.2.2 关键字实参"></a>8.2.2 关键字实参</h2><p><strong>关键字实参</strong>是传递给函数的名称值对。因为直接在实参中将名称和值关联起来，所以向函数传递实参时不会混淆。关键字实参让你必须考虑函数调用中的实参顺序，还清楚地指出了函数调用中各个值的用途。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe_person</span>(<span class="params">person_name, person_sex</span>):</span></span><br><span class="line">    print(<span class="string">f&quot;my name is <span class="subst">&#123;person_name&#125;</span>,i am <span class="subst">&#123;person_sex&#125;</span>&quot;</span>)</span><br><span class="line">  </span><br><span class="line">describe_person(person_name = <span class="string">&#x27;zhangsan&#x27;</span>, person_sex = <span class="string">&#x27;male&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my name is zhangsan,i am male</span><br></pre></td></tr></table></figure>
<p>注意：使用关键字实参时，务必准确指定函数定义中的形参名。</p>
<h2 id="8-2-3-默认值"><a href="#8-2-3-默认值" class="headerlink" title="8.2.3 默认值"></a>8.2.3 默认值</h2><p>编写函数时，可给每个形参指定<strong>默认值</strong>。在调用函数中给形参提供了实参时，Python将使用指定的实参数；否则，将使用形参的默认值。因此形参指定默认值后，可在函数调用中省略相应的实参。使用默认值可简化函数调用，还可清楚第指出函数的典型用法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe_person</span>(<span class="params">person_name, person_sex = <span class="string">&#x27;male&#x27;</span></span>):</span></span><br><span class="line">    print(<span class="string">f&quot;my name is <span class="subst">&#123;person_name&#125;</span>,i am <span class="subst">&#123;person_sex&#125;</span>&quot;</span>)</span><br><span class="line">  </span><br><span class="line">describe_person(person_name = <span class="string">&#x27;zhangsan&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my name is zhangsan,i am male</span><br></pre></td></tr></table></figure>
<p>使用默认值时，必须先在形参列表中列出没有默认值的形参，再列出有默认值的形参。这让Python依然能够正确地解读位置实参。</p>
<h2 id="8-2-4-等效的函数调用"><a href="#8-2-4-等效的函数调用" class="headerlink" title="8.2.4 等效的函数调用"></a>8.2.4 等效的函数调用</h2><p>鉴于可混合使用位置实参，关键字实参和默认值，通常有多种等效的函数调用方式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe_person</span>(<span class="params">person_name, person_sex = <span class="string">&#x27;male&#x27;</span></span>):</span></span><br><span class="line">    print(<span class="string">f&quot;my name is <span class="subst">&#123;person_name&#125;</span>,i am <span class="subst">&#123;person_sex&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">describe_person(<span class="string">&quot;zhangsan&quot;</span>)</span><br><span class="line">describe_person(person_name = <span class="string">&quot;lisi&quot;</span>)</span><br><span class="line">describe_person(<span class="string">&quot;wangwu&quot;</span>,<span class="string">&quot;female&quot;</span>)</span><br><span class="line">describe_person(person_name = <span class="string">&quot;zhaoliu&quot;</span>, person_sex = <span class="string">&#x27;female&#x27;</span>)</span><br><span class="line">describe_person(person_sex = <span class="string">&#x27;female&#x27;</span>, person_name = <span class="string">&quot;liuqi&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my name is zhangsan,i am male</span><br><span class="line">my name is lisi,i am male</span><br><span class="line">my name is wangwu,i am female</span><br><span class="line">my name is zhaoliu,i am female</span><br><span class="line">my name is liuqi,i am female</span><br></pre></td></tr></table></figure>
<h1 id="8-3-返回值"><a href="#8-3-返回值" class="headerlink" title="8.3 返回值"></a>8.3 返回值</h1><p>函数并非总是直接显示输出，它还可以处理一些数据，并返回一个或一组值。函数返回的值称为<strong>返回值</strong>。</p>
<h2 id="8-3-1-返回简单值"><a href="#8-3-1-返回简单值" class="headerlink" title="8.3.1 返回简单值"></a>8.3.1 返回简单值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_formatted_name</span>(<span class="params">first_name, last_name</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回整洁的姓名&quot;&quot;&quot;</span></span><br><span class="line">    full_name = <span class="string">f&quot;<span class="subst">&#123;first_name&#125;</span> <span class="subst">&#123;last_name&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">return</span> full_name.title()</span><br><span class="line"></span><br><span class="line">full_person_name = get_formatted_name(<span class="string">&#x27;zhang&#x27;</span>, <span class="string">&#x27;san&#x27;</span>)</span><br><span class="line">print(full_person_name)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Zhang San</span><br></pre></td></tr></table></figure>
<h2 id="8-3-3-返回字典"><a href="#8-3-3-返回字典" class="headerlink" title="8.3.3 返回字典"></a>8.3.3 返回字典</h2><p>函数可返回任何类型的值，包括列表和字典等较复杂的数据结构。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_person</span>(<span class="params">first_name, last_name</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回一个字典，其中包含有关一个人的信息。&quot;&quot;&quot;</span></span><br><span class="line">    person = &#123;<span class="string">&#x27;first&#x27;</span> : first_name, <span class="string">&#x27;last&#x27;</span> : last_name&#125;</span><br><span class="line">    <span class="keyword">return</span> person</span><br><span class="line"></span><br><span class="line">full_person = build_person(<span class="string">&#x27;zhang&#x27;</span>, <span class="string">&#x27;san&#x27;</span>)</span><br><span class="line">print(full_person)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#39;first&#39;: &#39;zhang&#39;, &#39;last&#39;: &#39;san&#39;&#125;</span><br></pre></td></tr></table></figure>
<p>在条件测试中，None相当于False。</p>
<h1 id="8-4-传递列表"><a href="#8-4-传递列表" class="headerlink" title="8.4 传递列表"></a>8.4 传递列表</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_users</span>(<span class="params">names</span>):</span></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">        print(<span class="string">f&quot;Hello <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line">user_names = [<span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;lisi&#x27;</span>, <span class="string">&#x27;wangwu&#x27;</span>]</span><br><span class="line">greet_users(user_names)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello zhangsan</span><br><span class="line">Hello lisi</span><br><span class="line">Hello wangwu</span><br></pre></td></tr></table></figure>
<h2 id="8-4-1-在函数中修改列表"><a href="#8-4-1-在函数中修改列表" class="headerlink" title="8.4.1 在函数中修改列表"></a>8.4.1 在函数中修改列表</h2><p>将列表传递给函数后，函数就可对其进行修改。在函数中对这个列表所做的任何修改都是永久性的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_users</span>(<span class="params">names</span>):</span></span><br><span class="line">   names.append(<span class="string">&#x27;zhaoliu&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">user_names = [<span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;lisi&#x27;</span>, <span class="string">&#x27;wangwu&#x27;</span>]</span><br><span class="line">print(user_names)</span><br><span class="line">greet_users(user_names)</span><br><span class="line">print(user_names)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#39;zhangsan&#39;, &#39;lisi&#39;, &#39;wangwu&#39;]</span><br><span class="line">[&#39;zhangsan&#39;, &#39;lisi&#39;, &#39;wangwu&#39;, &#39;zhaoliu&#39;]</span><br></pre></td></tr></table></figure>
<h2 id="8-4-2-禁止函数修改列表"><a href="#8-4-2-禁止函数修改列表" class="headerlink" title="8.4.2 禁止函数修改列表"></a>8.4.2 禁止函数修改列表</h2><p>如果想在函数中操作列表而不影响原列表，可将列表的副本传递给函数，可以这样做：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function_name(list_name[:])</span><br></pre></td></tr></table></figure>
<p>切片表示法[:]创建列表的副本。</p>
<p>虽然向函数传递列表的副本可保留原始列表的内容，但除非有充分的理由，否则还是应该将原始列表传递给函数。这是因为让函数使用现成的列表可以避免花时间和内存创建副本，从而提高效率，在处理大型列表时尤其如此。</p>
<h1 id="8-5-传递任意数量的实参"><a href="#8-5-传递任意数量的实参" class="headerlink" title="8.5 传递任意数量的实参"></a>8.5 传递任意数量的实参</h1><p>有时候，预先不知道函数需要接受多少个实参，好在Python允许函数从调用语句中收集任意数量的实参。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_users</span>(<span class="params">*names</span>):</span></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">        print(<span class="string">f&quot;Hello <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line">    print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">greet_users(<span class="string">&#x27;zhangsan&#x27;</span>)</span><br><span class="line">greet_users(<span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;lisi&#x27;</span>)</span><br><span class="line">greet_users(<span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;lisi&#x27;</span>, <span class="string">&#x27;wangwu&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Hello zhangsan</span><br><span class="line"></span><br><span class="line">Hello zhangsan</span><br><span class="line">Hello lisi</span><br><span class="line"></span><br><span class="line">Hello zhangsan</span><br><span class="line">Hello lisi</span><br><span class="line">Hello wangwu</span><br></pre></td></tr></table></figure>
<p>形参名*names中的星号让Python创建一个名为names的空元组，并将收到的所有值都封装到这个元组中。</p>
<h2 id="8-5-1-结合使用位置实参和任意数量实参"><a href="#8-5-1-结合使用位置实参和任意数量实参" class="headerlink" title="8.5.1 结合使用位置实参和任意数量实参"></a>8.5.1 结合使用位置实参和任意数量实参</h2><p>如果要让函数接受不同类型的实参，必须在函数定义中将接纳任意数量实参的形参放在最后。Python先匹配位置实参和关键字实参，再将余下的实参都收集到最后一个形参中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_pizza</span>(<span class="params">size, *toppings</span>):</span></span><br><span class="line">    print(<span class="string">f&quot;\nMaking a <span class="subst">&#123;size&#125;</span>-inch pizza with the following topping:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> topping <span class="keyword">in</span> toppings:</span><br><span class="line">        print(<span class="string">f&quot;-<span class="subst">&#123;topping&#125;</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line">make_pizza(<span class="number">16</span>, <span class="string">&#x27;pepperoni&#x27;</span>)</span><br><span class="line">make_pizza(<span class="number">12</span>, <span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;green peppers&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为;l</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Making a 16-inch pizza with the following topping:</span><br><span class="line">-pepperoni</span><br><span class="line"></span><br><span class="line">Making a 12-inch pizza with the following topping:</span><br><span class="line">-mushrooms</span><br><span class="line">-green peppers</span><br><span class="line">-extra cheese</span><br></pre></td></tr></table></figure>
<p>经常i看到通用形参名*args，它也收集任意数量的位置实参。</p>
<h2 id="8-5-2-使用任意数量的关键字实参"><a href="#8-5-2-使用任意数量的关键字实参" class="headerlink" title="8.5.2 使用任意数量的关键字实参"></a>8.5.2 使用任意数量的关键字实参</h2><p>有时候，需要接受任意数量的实参，但预先不知道传递给函数的会是什么样的信息。在这种情况下，可将函数编写成能够接受任意数量的键值对——调用语句提供了多少就接受多少。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_profile</span>(<span class="params">first, last, **user_info</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;创建一个字典，其中包含我们知道的有关用户的一切。&quot;&quot;&quot;</span></span><br><span class="line">    user_info[<span class="string">&#x27;first_name&#x27;</span>] = first</span><br><span class="line">    user_info[<span class="string">&#x27;last_name&#x27;</span>] = last</span><br><span class="line">    <span class="keyword">return</span> user_info</span><br><span class="line"></span><br><span class="line">user_profile = build_profile(<span class="string">&#x27;zhang&#x27;</span>, <span class="string">&#x27;san&#x27;</span>, location=<span class="string">&#x27;chongqing&#x27;</span>, field=<span class="string">&#x27;computer science&#x27;</span>)</span><br><span class="line">print(user_profile)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#39;location&#39;: &#39;chongqing&#39;, &#39;field&#39;: &#39;computer science&#39;, &#39;first_name&#39;: &#39;zhang&#39;, &#39;last_name&#39;: &#39;san&#39;&#125;</span><br></pre></td></tr></table></figure>
<p>形参**user_info中的两个星号让Python创建一个名为user_info的空字典，并将接收到的所有名称值对都放到这个字典中。</p>
<p>经常会看到形参名**kwargs，它用于收集任意数量的关键字实参。</p>
<h1 id="8-6-将函数存储在模块中"><a href="#8-6-将函数存储在模块中" class="headerlink" title="8.6 将函数存储在模块中"></a>8.6 将函数存储在模块中</h1><p>使用函数的优点之一是可将代码块与主程序分离。通过给函数指定描述性名称，可让主程序容易理解得多。还可以更进一步，将函数存储在称为<strong>模块</strong>的独立文件中，再将模块<strong>导入</strong>到主程序中。</p>
<h2 id="8-6-1-导入整个模块"><a href="#8-6-1-导入整个模块" class="headerlink" title="8.6.1  导入整个模块"></a>8.6.1  导入整个模块</h2><p>模块是扩展名为.py的文件，包含要导入到程序中的代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> module_name</span><br></pre></td></tr></table></figure>
<p>只需要编写一条import语句并在其中指定模块名，就可在程序中使用该模块中的所有函数。如果使用这种import语句导入了名为module_name.py的整个模块，就可以使用下面的语法来使用其中的任何一个函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module_name.function_name()</span><br></pre></td></tr></table></figure>
<h2 id="8-6-2-导入特定的函数"><a href="#8-6-2-导入特定的函数" class="headerlink" title="8.6.2 导入特定的函数"></a>8.6.2 导入特定的函数</h2><p>还可以导入模块中的特定函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> module_name <span class="keyword">import</span> function_name</span><br></pre></td></tr></table></figure>
<p>通过用逗号分隔函数名，可根据需要从模块中导入任意数量的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> module_name <span class="keyword">import</span> function_0, function_1, function_2 </span><br></pre></td></tr></table></figure>
<p>由于在import语句中显示地导入了函数，调用时只需指定其名称即可。</p>
<h2 id="8-6-3-使用as给函数指定别名"><a href="#8-6-3-使用as给函数指定别名" class="headerlink" title="8.6.3 使用as给函数指定别名"></a>8.6.3 使用as给函数指定别名</h2><p>如果要导入函数的名称可能与程序中现有的名称冲突，或者函数的名称太长，可指定简短而独一无二的别名：函数的另一个名称，类似于外号。要给函数取这种特殊外号，需要在导入它时指定。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> module_name <span class="keyword">import</span> function_name <span class="keyword">as</span> fn</span><br></pre></td></tr></table></figure>
<h2 id="8-6-4-使用as给模块指定别名"><a href="#8-6-4-使用as给模块指定别名" class="headerlink" title="8.6.4 使用as给模块指定别名"></a>8.6.4 使用as给模块指定别名</h2><p>还可以给模块指定别名。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> module_name <span class="keyword">as</span> mn</span><br></pre></td></tr></table></figure>
<h2 id="8-6-5-导入模块中的所有函数"><a href="#8-6-5-导入模块中的所有函数" class="headerlink" title="8.6.5 导入模块中的所有函数"></a>8.6.5 导入模块中的所有函数</h2><p>使用星号（*）运算符可让Python导入模块中的所有函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from module_name import *</span><br></pre></td></tr></table></figure>
<h1 id="8-7-函数编写指南"><a href="#8-7-函数编写指南" class="headerlink" title="8.7 函数编写指南"></a>8.7 函数编写指南</h1><p>应给函数指定描述性名称，且只在其中使用小写字母和下划线。</p>
<p>给形参指定默认值时，等号两边不要有空格。对于函数调用中的关键字实参，也应遵循这种约定。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/10/Statistical_Learning_Methods_Notes/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E9%80%BB%E8%BE%91%E6%96%AF%E8%92%82%E5%9B%9E%E5%BD%92%E4%B8%8E%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/10/Statistical_Learning_Methods_Notes/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E9%80%BB%E8%BE%91%E6%96%AF%E8%92%82%E5%9B%9E%E5%BD%92%E4%B8%8E%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">第六章 逻辑斯蒂回归与最大熵模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-10 20:24:36" itemprop="dateCreated datePublished" datetime="2021-06-10T20:24:36+08:00">2021-06-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-09 20:09:16" itemprop="dateModified" datetime="2021-06-09T20:09:16+08:00">2021-06-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">统计学习方法</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/06/10/Statistical_Learning_Methods_Notes/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E9%80%BB%E8%BE%91%E6%96%AF%E8%92%82%E5%9B%9E%E5%BD%92%E4%B8%8E%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/06/10/Statistical_Learning_Methods_Notes/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E9%80%BB%E8%BE%91%E6%96%AF%E8%92%82%E5%9B%9E%E5%BD%92%E4%B8%8E%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>逻辑斯蒂回归（logistic regression）</strong>是统计学习中的经典分类方法。</p>
<p>最大熵是概率模型学习的一个准则，将其推广到分类问题得到<strong>最大熵模型（maximum entropy model）</strong>。</p>
<p>逻辑斯蒂回归模型与最大熵模型都属于对数线性模型。</p>
<h1 id="6-1-逻辑斯蒂回归模型"><a href="#6-1-逻辑斯蒂回归模型" class="headerlink" title="6.1 逻辑斯蒂回归模型"></a>6.1 逻辑斯蒂回归模型</h1><h2 id="6-1-1-逻辑斯蒂分布"><a href="#6-1-1-逻辑斯蒂分布" class="headerlink" title="6.1.1 逻辑斯蒂分布"></a>6.1.1 逻辑斯蒂分布</h2><p>首先介绍<strong>逻辑斯蒂分布（logistic distribution）</strong>。</p>
<p><strong>定义 6.1（逻辑斯蒂分布）</strong>  设$X$是连续随机变量，$X$服从逻辑斯蒂分布是指$X$具有下列分布函数和密度函数：</p>
<script type="math/tex; mode=display">
F(x) = P(X \leq x) = \frac{1}{1 \ + \ e^{-(x - \mu)/\gamma}} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (6.1)</script><script type="math/tex; mode=display">
f(x) = F'(x) = \frac{e^{-(x - \mu)/\gamma}}{\gamma(1 \ + \ e^{-(x - \mu)/\gamma})^2} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (6.2)</script><p>式中，$\mu$为位置参数，$\gamma &gt; 0$为形状参数。</p>
<p>分布函数属于逻辑斯蒂函数，其图形是一条$S$形曲线（sigmoid curve）。该曲线以点$(\mu,\frac{1}{2})$为中心对称，即满足</p>
<script type="math/tex; mode=display">
F(-x \ + \ \mu) - \frac{1}{2} = -F(x \ + \ \mu) + \frac{1}{2}</script><p>形状参数$\gamma$的值越小，曲线在中心附近增长得越快。</p>
<h2 id="6-1-2-二项逻辑斯蒂回归模型"><a href="#6-1-2-二项逻辑斯蒂回归模型" class="headerlink" title="6.1.2 二项逻辑斯蒂回归模型"></a>6.1.2 二项逻辑斯蒂回归模型</h2><p><strong>二项逻辑斯蒂回归模型（binomial logistic regression model）</strong>是一种分类模型，由条件概率分布$P(Y|X)$表示，形式为参数化的逻辑斯蒂分布。</p>
<p><strong>定义 6.2（逻辑斯蒂回归模型）</strong>  二项逻辑斯蒂回归模型是如下的条件概率分布：</p>
<script type="math/tex; mode=display">
P(Y=1|x) = \frac{\exp(\omega·x + b)}{1 \ + \ \exp(\omega·x + b)} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (6.3)</script><script type="math/tex; mode=display">
P(Y=0|x) = \frac{1}{1 \ + \ \exp(\omega·x + b)} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (6.4)</script><p>这里，$x \in R^n$是输入，$Y \in \{0,1\}$是输出，$\omega \in R^n $和$b \in R$是参数，$\omega$称为权值向量，$b$称为偏置，$\omega·x$为$\omega$和$x$的内积。</p>
<p>对于给定的输入实例$x$，逻辑斯蒂回归比较两个条件概率值的大小，将实例$x$分到概率值较大的那一类。</p>
<p>有时为了方便，将权值向量和输入向量加以扩充，仍记作$\omega,x$，即$\omega = (\omega^{(1)},\omega^{(2)},…,\omega^{(n)},b)^T,\ x = (x^{(1)},x^{(2)},…,x^{(n)},1)$。这时，逻辑斯蒂回归模型如下：</p>
<script type="math/tex; mode=display">
P(Y=1|x) = \frac{\exp(\omega·x)}{1 \ + \ \exp(\omega·x)} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (6.5)</script><script type="math/tex; mode=display">
P(Y=0|x) = \frac{1}{1 \ + \ \exp(\omega·x)} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (6.6)</script><hr>
<p>一个事件的<strong>几率（odds）</strong>是指该事件发生的概率与该事件不发生的概率的比值。如果事件发生的概率是$p$，那么该事件的几率是$\frac{p}{1-p}$，该事件的<strong>对数几率（log odds）</strong>或<strong>logit函数</strong>是</p>
<script type="math/tex; mode=display">
logit(p) = \log\frac{p}{1-p}</script><p>对于逻辑斯蒂回归而言，由式$(6.5)$与式$(6.6)$得</p>
<script type="math/tex; mode=display">
\log\frac{P(Y=1|x)}{1\ - \ P(Y=1|x)} = \omega ·x</script><p>这就是说，在逻辑斯蒂回归模型中，输出$Y=1$的对数几率是输入$x$的线性函数。或者说，输出$Y=1$的对数几率是由输入$x$的线性函数表示的模型，即逻辑斯蒂回归模型。</p>
<h2 id="6-1-3-模型参数估计"><a href="#6-1-3-模型参数估计" class="headerlink" title="6.1.3 模型参数估计"></a>6.1.3 模型参数估计</h2><p>逻辑斯蒂回归模型学习时，对于给定的训练数据集$T = \{(x_1,y_1),(x_2,y_2),…,(x_N,y_N)\}$，其中，$x_i \in R^n, y_i \in\{0,1\} $，可以应用极大似然估计法估计模型参数，从而得到逻辑斯蒂回归模型。</p>
<p>设：</p>
<script type="math/tex; mode=display">
P(Y=1|x) = \pi(x),\ \ \  P(Y=0|x) = 1 - \pi(x)</script><p>似然函数为</p>
<script type="math/tex; mode=display">
\prod\limits_{i=1}^{N}[\pi(x_i)]^{y_i}[1-\pi(x_i)]^{1-y_i}</script><p>对数似然函数为</p>
<script type="math/tex; mode=display">
L(\omega) = \sum\limits_{i=1}^{N}[y_i \log \pi(x_i)\  + \ (1-y_i)\log(1-\pi(x_i))]</script><script type="math/tex; mode=display">
\ \ \ \ =\sum\limits_{i=1}^{N}[y_i \log \frac{\pi(x_i)}{1-\pi(x_i)}\  + \ \log(1-\pi(x_i))]</script><script type="math/tex; mode=display">
\ \ =\sum\limits_{i=1}^{N}[y_i (\omega·x_i)\  - \ \log(1+\exp(\omega · x_i))]</script><p>对$L(\omega)$求极大值，得到$\omega$的估计值。</p>
<p>这样，问题就变成了以对数似然函数为目标函数的最优化问题。逻辑斯蒂回归学习中通常采用的方法是梯度下降法及拟牛顿法。</p>
<h2 id="6-1-4-多项逻辑斯蒂回归"><a href="#6-1-4-多项逻辑斯蒂回归" class="headerlink" title="6.1.4 多项逻辑斯蒂回归"></a>6.1.4 多项逻辑斯蒂回归</h2><p>上面介绍的逻辑斯蒂回归模型是二项分类模型，用于二类分类。可以将其推广为<strong>多项逻辑斯蒂回归模型（multi-nominal logistic regression model）</strong>，用于多类分类。</p>
<p>设离散型随机变量$Y$的取值集合是$\{1,2,…,K\}$，那么多项逻辑斯蒂回归模型是</p>
<script type="math/tex; mode=display">
P(Y=k|x) = \frac{\exp(\omega_k·x)}{1 \ + \ \sum\limits_{k=1}^{K-1}\exp(\omega_k·x)}, \ \ k = 1,2,...,K-1 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (6.7)</script><script type="math/tex; mode=display">
P(Y=K|x) = \frac{1}{1 \ + \ \sum\limits_{k=1}^{K-1}\exp(\omega_k·x)}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (6.8)</script><p>这里，$x \in R^{n+1},\omega_k \in R^{n+1}$。</p>
<p>二项逻辑斯蒂回归的参数估计法也可以推广到多项逻辑斯蒂回归。</p>
<h1 id="6-2-最大熵模型"><a href="#6-2-最大熵模型" class="headerlink" title="6.2 最大熵模型"></a>6.2 最大熵模型</h1><p><strong>最大熵模型（maximum entropy model）</strong>由最大熵原理推导实现。</p>
<h2 id="6-2-1-最大熵原理"><a href="#6-2-1-最大熵原理" class="headerlink" title="6.2.1 最大熵原理"></a>6.2.1 最大熵原理</h2><p>最大熵原理认为，学习概率模型时，在所有可能的概率模型（分布）中，熵最大的模型是最好的模型。通常用约束条件来确定概率模型的集合，所以，最大熵原理也可以表述为在满足约束条件的模型集合中选取熵最大的模型。</p>
<p>假设离散随机变量$X$的概率分布是$P(X)$，则其熵是</p>
<script type="math/tex; mode=display">
H(P) = -\sum\limits_{x}P(x)\log P(x)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (6.9)</script><p>熵满足下列不等式：</p>
<script type="math/tex; mode=display">
0 \leq H(P) \leq \log|X|</script><p>式中，$|X|$是$X$的取值个数，当且仅当$X$的分布是均匀分布时右边的等号成立。这就是说，当$X$服从均匀分布时，熵最大。</p>
<p>直观地，最大熵原理认为要选择的概率模型首先必须满足已有的事实，即约束条件。在没有更多信息的情况下，那些不确定的部分都是“等可能的”。最大熵原理通过熵的最大化来表示等可能性。“等可能”不容易操作，而熵则是一个可优化的数值指标。</p>
<h2 id="6-2-2-最大熵模型的定义"><a href="#6-2-2-最大熵模型的定义" class="headerlink" title="6.2.2 最大熵模型的定义"></a>6.2.2 最大熵模型的定义</h2><p>假设分类模型是一个条件概率分布$P(Y|X),X \in \chi \subseteq R^n$表示输入，$Y \in \mathcal{Y}$表示输出，$\chi $和$\mathcal{Y}$分别是输入和输出的集合。这个模型表示的是对于给定的输入$X$，以条件概率$P(Y|X)$输出$Y$。</p>
<p>给定一个训练数据集</p>
<script type="math/tex; mode=display">
T = \{(x_1,y_1),(x_2,y_2),...,(x_N,y_N)\}</script><p>学习的目标是用最大熵原理选择最好的分类模型。</p>
<hr>
<p>首先考虑模型应该满足的条件。给定训练数据集，可以确定联合分布$P(X,Y)$的经验分布和边缘分布$P(X)$的经验分布，分别以$\tilde{P}(X,Y)$和$\tilde{P}(X)$表示。这里，</p>
<script type="math/tex; mode=display">
\tilde{P}(X=x,Y=y) = \frac{\upsilon(X=x,Y=y)}{N}</script><script type="math/tex; mode=display">
\tilde{P}(X=x)=\frac{\upsilon(X=x)}{N}</script><p>其中，$\upsilon(X=x,Y=y)$表示训练数据中样本$(x,y)$出现的频数，$\upsilon(X=x)$表示训练数据中输入$x$出现的频数，$N$表示训练样本容量。</p>
<p>用<strong>特征函数（feature function）</strong>$f(x,y)$描述输入$x$和输出$y$之间的某一个事实。其定义是</p>
<script type="math/tex; mode=display">
f(x,y) = \lbrace_{0, \ \ \ 否则}^{1,\ \ \ x与y满足某一事实}</script><p>特征函数$f(x,y)$关于经验分布$\tilde{P}(X,Y)$的期望值，用$E_{\tilde{P}}(f)$表示：</p>
<script type="math/tex; mode=display">
E_{\tilde{P}}(f) = \sum\limits_{x,y}\tilde{P}(x,y)f(x,y)</script><p>特征函数$f(x,y)$关于模型$P(Y|X)$与经验分布$\tilde{P}(X)$的期望值，用$E_P(f)$表示：</p>
<script type="math/tex; mode=display">
E_P(f)=\sum\limits_{x,y}\tilde{P}(x)P(y|x)f(x,y)</script><p>如果模型能够获取训练数据中的信息，那么就可以假设这两个期望值相等，即</p>
<script type="math/tex; mode=display">
E_P(f)=E_{\tilde{P}}(f)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (6.10)</script><p>或</p>
<script type="math/tex; mode=display">
\sum\limits_{x,y}\tilde{P}(x)P(y|x)f(x,y) = \sum\limits_{x,y}\tilde{P}(x,y)f(x,y)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (6.11)</script><p>将式$(6.10)$或式$(6.11)$作为模型学习的约束条件。假设有$n$个特征函数$f_i(x,y),\ \ i=1,2,…,n$，那么就有$n$个约束条件。</p>
<hr>
<p><strong>定义 6.3（最大熵模型）</strong> 假设满足所有约束条件的模型集合为</p>
<script type="math/tex; mode=display">
\mathcal{C} \equiv \{P\in \mathcal{P}|E_P(f_i)=E_{\tilde{P}}(f),\ \ \ i=1,2,...,n\}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (6.12)</script><p>定义在条件概率分布$P(Y|X)$上的条件熵为</p>
<script type="math/tex; mode=display">
H(P) = -\sum\limits_{x,y}\tilde{P}(x)P(y|x)\log P(y|x)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (6.13)</script><p>则模型集合$\mathcal{C}$中条件熵$H(P)$最大的模型称为最大熵模型。</p>
<h2 id="6-2-3-最大熵模型的学习"><a href="#6-2-3-最大熵模型的学习" class="headerlink" title="6.2.3 最大熵模型的学习"></a>6.2.3 最大熵模型的学习</h2><p>最大熵模型的学习过程就是求解最大熵模型的过程。最大熵模型的学习可以形式化为约束最优化问题。</p>
<p>对于给定的训练数据集$T = \{(x_1,y_1),(x_2,y_2),…,(x_N,y_N)\}$以及特征函数$f_i(x,y),i=1,2,…,n$，最大熵模型的学习等价于约束最优化问题：</p>
<script type="math/tex; mode=display">
\max\limits_{P \in \mathcal{C}}  H(P) = -\sum\limits_{x,y}\tilde{P}(x)P(y|x)\log P(y|x)</script><script type="math/tex; mode=display">
s.t.\ \ \ E_P(f_i)=E_{\tilde{P}}(f_i),\ \ \ i=1,2,...,n</script><script type="math/tex; mode=display">
\sum\limits_{y} P(y|x) = 1</script><p>按照最优化问题的习惯，将求最大值问题改写为等价的求最小值问题：</p>
<script type="math/tex; mode=display">
\min\limits_{P \in \mathcal{C}}  -H(P) = \sum\limits_{x,y}\tilde{P}(x)P(y|x)\log P(y|x)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (6.14)</script><script type="math/tex; mode=display">
s.t.\ \ \ E_P(f_i) - E_{\tilde{P}}(f_i) = 0,\ \ \ i=1,2,...,n \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (6.15)</script><script type="math/tex; mode=display">
\sum\limits_{y} P(y|x) = 1 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  (6.16)</script><p>求解约束最优化问题$(6.14)~(6.16)$，所得出的解，就是最大熵模型学习的解。<strong>具体推导省略。详见《统计学习方法-李航》98~100页。</strong></p>
<p>可以应用最优化算法求对偶函数$\Psi(\omega)$的极大化，得到$\omega^<em>$，用来表示$P^</em> \in \mathcal{C}$。这里，$P^<em>=P_{\omega^</em>}=P_{\omega^*}(y|x)$是学习到的最优模型（最大熵模型）也就是说，最大熵模型的学习归结为对偶函数$\Psi(\omega)$的极大化。</p>
<h2 id="6-2-4-极大似然估计"><a href="#6-2-4-极大似然估计" class="headerlink" title="6.2.4 极大似然估计"></a>6.2.4 极大似然估计</h2><p>对偶函数极大化等价于最大熵模型的极大似然估计。对偶函数$\Psi(\omega)$等价于对数似然函数$L_{\tilde{P}}(P_\omega)$。<strong>具体推导省略。详见《统计学习方法-李航》102~103页。</strong></p>
<p>这样，最大熵模型的学习问题就转换为具体求解对数似然函数极大化或对偶函数极大化的问题。</p>
<p>可以将最大熵模型写成更一般的形式。</p>
<script type="math/tex; mode=display">
P_{\omega}(y|x)=\frac{1}{Z_{\omega}(x)}\exp(\sum\limits_{i=1}^n \omega_if_i(x,y))\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (6.28)</script><p>其中，</p>
<script type="math/tex; mode=display">
Z_{\omega}(x)=\sum\limits_{y} \exp(\sum\limits_{i=1}^n \omega_if_i(x,y))\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (6.29)</script><p>最大熵模型与逻辑斯蒂回归模型由类似的形式，它们又称为<strong>对数线性模型（log linear model）</strong>。模型学习就是在给定的训练数据条件下对模型进行极大似然估计或正则化的极大似然估计。</p>
<h1 id="6-3-模型学习的最优化算法"><a href="#6-3-模型学习的最优化算法" class="headerlink" title="6.3 模型学习的最优化算法"></a>6.3 模型学习的最优化算法</h1><p>逻辑斯蒂回归模型、最大熵模型学习归结为以似然函数为目标函数的最优化问题，通常通过迭代算法求解。从最优化的观点看，这时的目标函数具有很好的性质。它是光滑的凸函数，因此多种最优化的方法都适用，保证能找到全局最优解。常用的方法有改进的迭代尺度法、梯度下降法、牛顿法和拟牛顿法。牛顿法或拟牛顿法一般收敛速度更快。</p>
<h2 id="6-3-1-改进的迭代尺度法"><a href="#6-3-1-改进的迭代尺度法" class="headerlink" title="6.3.1 改进的迭代尺度法"></a>6.3.1 改进的迭代尺度法</h2><p><strong>改进的迭代尺度法（improved iterative scaling，IIS）</strong>是一种最大熵模型学习的最优化算法。</p>
<h2 id="6-3-2-拟牛顿法"><a href="#6-3-2-拟牛顿法" class="headerlink" title="6.3.2 拟牛顿法"></a>6.3.2 拟牛顿法</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/08/Data%20_Competition/Python_Foundation/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E5%92%8Cwhile%E5%BE%AA%E7%8E%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/08/Data%20_Competition/Python_Foundation/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E5%92%8Cwhile%E5%BE%AA%E7%8E%AF/" class="post-title-link" itemprop="url">第七章 用户输入和while循环</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-08 16:46:39" itemprop="dateCreated datePublished" datetime="2021-06-08T16:46:39+08:00">2021-06-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-02 21:52:45" itemprop="dateModified" datetime="2021-07-02T21:52:45+08:00">2021-07-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">数据竞赛</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/06/08/Data%20_Competition/Python_Foundation/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E5%92%8Cwhile%E5%BE%AA%E7%8E%AF/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/06/08/Data%20_Competition/Python_Foundation/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E5%92%8Cwhile%E5%BE%AA%E7%8E%AF/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="7-1-函数input-的工作原理"><a href="#7-1-函数input-的工作原理" class="headerlink" title="7.1 函数input()的工作原理"></a>7.1 函数input()的工作原理</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">message = <span class="built_in">input</span>(<span class="string">&quot;tell me something:&quot;</span>)</span><br><span class="line">print(message)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tell me something:Hello Python World!   #Hello Python World!为用户在控制台的输入</span><br><span class="line">Hello Python World!</span><br></pre></td></tr></table></figure>
<p>函数input()接受一个参数——要向用户显示的<strong>提示（prompt）</strong>或说明，让用户知道该如何做。</p>
<p>程序运行到input()函数时，程序等待用户输入，并在用户按回车键后继续运行。</p>
<h2 id="7-1-1-编写清晰的程序"><a href="#7-1-1-编写清晰的程序" class="headerlink" title="7.1.1 编写清晰的程序"></a>7.1.1 编写清晰的程序</h2><p>有时候，提示可能超过一行。例如，你可能需要指出获取特定输入的原因。在这种情况下，可将提示赋给一个变量，再将该变量传递给函数input()。这样，即便提示超过一行，input()语句也会非常清晰。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">prompt = <span class="string">&quot;If you tell us who you are, we can personalize the message you see.&quot;</span></span><br><span class="line">prompt += <span class="string">&quot;\nWhat is your first name?&quot;</span></span><br><span class="line">name = <span class="built_in">input</span>(prompt)</span><br><span class="line">print(<span class="string">f&quot;hello, <span class="subst">&#123;name&#125;</span>!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">If you tell us who you are, we can personalize the message you see.</span><br><span class="line">What is your first name?zhang</span><br><span class="line">hello, zhang!</span><br></pre></td></tr></table></figure>
<h2 id="7-1-2-使用int-来获取数值输入"><a href="#7-1-2-使用int-来获取数值输入" class="headerlink" title="7.1.2 使用int()来获取数值输入"></a>7.1.2 使用int()来获取数值输入</h2><p>使用函数input()时，Python将用户输入解读为字符串。为解决这个问题，可使用函数int()，它让Python将输入视为数值。函数int()将数的字符串转换为数值表示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="built_in">input</span>(<span class="string">&quot;How old are you?&quot;</span>)</span><br><span class="line">age = <span class="built_in">int</span>(age)</span><br><span class="line"><span class="keyword">if</span>(age &gt;= <span class="number">18</span>):</span><br><span class="line">	print(<span class="string">&quot;you are a men!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">How old are you?24</span><br><span class="line">you are a men!</span><br></pre></td></tr></table></figure>
<p>还有函数float()可将字符串转为小数。</p>
<h2 id="7-1-3-求模运算符"><a href="#7-1-3-求模运算符" class="headerlink" title="7.1.3 求模运算符"></a>7.1.3 求模运算符</h2><p>处理数值信息时，求模运算符（%）是个很有用的工具，它将两个数相除并返回余数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="number">4</span> % <span class="number">3</span>)</span><br><span class="line">print(<span class="number">5</span> % <span class="number">3</span>)</span><br><span class="line">print(<span class="number">6</span> % <span class="number">3</span>)</span><br><span class="line">print(<span class="number">7</span> % <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h1 id="7-2-while循环简介"><a href="#7-2-while循环简介" class="headerlink" title="7.2 while循环简介"></a>7.2 while循环简介</h1><p>for循环用于针对集合中的每个元素都执行一个代码块，而while循环则不断运行，直到指定的条件不满足为止。</p>
<h2 id="7-2-1-使用while循环"><a href="#7-2-1-使用while循环" class="headerlink" title="7.2.1 使用while循环"></a>7.2.1 使用while循环</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cur_number = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> cur_number &lt; <span class="number">6</span>:</span><br><span class="line">	print(cur_number)</span><br><span class="line">	cur_number += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<h2 id="7-2-2-让用户选择何时退出"><a href="#7-2-2-让用户选择何时退出" class="headerlink" title="7.2.2 让用户选择何时退出"></a>7.2.2 让用户选择何时退出</h2><p>可以使用while循环让程序在用户愿意时不断运行，可以定义一个<strong>退出值</strong>，只要用户输入的不是这个值，程序就将接着运行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">while</span> message != <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">	message = <span class="built_in">input</span>(<span class="string">&quot;please input something:&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> message != <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">		print(<span class="string">f&quot;your input the message is :<span class="subst">&#123;message&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">please input something:hello</span><br><span class="line">your input the message is :hello</span><br><span class="line"></span><br><span class="line">please input something:python</span><br><span class="line">your input the message is :python</span><br><span class="line"></span><br><span class="line">please input something:world</span><br><span class="line">your input the message is :world</span><br><span class="line"></span><br><span class="line">please input something:quit</span><br></pre></td></tr></table></figure>
<h2 id="7-2-3-使用标志"><a href="#7-2-3-使用标志" class="headerlink" title="7.2.3 使用标志"></a>7.2.3 使用标志</h2><p>在要求很多条件都满足才继续运行的程序中，可定义一个变量，用于判断整个程序是否处于活动状态。这个变量称为<strong>标志（flag）</strong>，充当程序的交通信号灯。可以让程序在标志为True时继续运行，并在任何事件导致的值为False时让程序停止运行。这样，在while语句中就只需检查一个条件：标志的当前值是否为True。然后将所有其他测试（是否发生了应将标志设为False的事件）都放在其他地方，从而让程序更整洁。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">message = <span class="string">&quot;&quot;</span></span><br><span class="line">flag = <span class="literal">True</span></span><br><span class="line"><span class="keyword">while</span> flag:</span><br><span class="line">	message = <span class="built_in">input</span>(<span class="string">&quot;please input something:&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> message != <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">		print(<span class="string">f&quot;your input the message is :<span class="subst">&#123;message&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        flag = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">please input something:hello </span><br><span class="line">your input the message is :hello </span><br><span class="line"></span><br><span class="line">please input something:python</span><br><span class="line">your input the message is :python</span><br><span class="line"></span><br><span class="line">please input something:world</span><br><span class="line">your input the message is :world</span><br><span class="line"></span><br><span class="line">please input something:quit</span><br></pre></td></tr></table></figure>
<h2 id="7-2-4-使用break退出循环"><a href="#7-2-4-使用break退出循环" class="headerlink" title="7.2.4 使用break退出循环"></a>7.2.4 使用break退出循环</h2><p>break语句用于控制程序流程，可用来控制哪些代码行将执行，哪些代码行不执行，从而让程序按你的要求执行你要执行的代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">message = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	message = <span class="built_in">input</span>(<span class="string">&quot;please input something:&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> message == <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">f&quot;your input the message is :<span class="subst">&#123;message&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">please input something:hello </span><br><span class="line">your input the message is :hello </span><br><span class="line"></span><br><span class="line">please input something:python</span><br><span class="line">your input the message is :python</span><br><span class="line"></span><br><span class="line">please input something:world</span><br><span class="line">your input the message is :world</span><br><span class="line"></span><br><span class="line">please input something:quit</span><br></pre></td></tr></table></figure>
<h2 id="7-2-5-在循环中使用continue"><a href="#7-2-5-在循环中使用continue" class="headerlink" title="7.2.5 在循环中使用continue"></a>7.2.5 在循环中使用continue</h2><p>要返回循环开头，并根据条件测试结果决定是否继续执行循环，可使用continue语句，它不像break语句那样不再执行余下的代码并退出整个循环。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cur_number = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> cur_number &lt; <span class="number">10</span>:</span><br><span class="line">	cur_number += <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span>(cur_number % <span class="number">2</span> == <span class="number">0</span>):</span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">	print(cur_number)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">9</span><br></pre></td></tr></table></figure>
<h2 id="7-2-6-避免无限循环"><a href="#7-2-6-避免无限循环" class="headerlink" title="7.2.6 避免无限循环"></a>7.2.6 避免无限循环</h2><p>如果程序陷入无限循环，可按Ctrl+C，也可关闭显示程序输出的终端窗口</p>
<h1 id="7-3使用while循环处理列表和字典"><a href="#7-3使用while循环处理列表和字典" class="headerlink" title="7.3使用while循环处理列表和字典"></a>7.3使用while循环处理列表和字典</h1><p>for循环是一种遍历列表的有效方式，但不应在for循环中修改列表，否则将导致Python难以跟踪其中的元素。要在遍历列表的同时对其进行修改，可使用while循环。</p>
<h2 id="7-3-1-在列表之间移动元素"><a href="#7-3-1-在列表之间移动元素" class="headerlink" title="7.3.1 在列表之间移动元素"></a>7.3.1 在列表之间移动元素</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">unconfirmed_users = [<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;brian&#x27;</span>, <span class="string">&#x27;candace&#x27;</span>]</span><br><span class="line">confirmed_users = []</span><br><span class="line">print(unconfirmed_users)</span><br><span class="line">print(confirmed_users)</span><br><span class="line"><span class="keyword">while</span> unconfirmed_users:</span><br><span class="line">	cur_user = unconfirmed_users.pop()</span><br><span class="line">	print(<span class="string">f&quot;verifying user:<span class="subst">&#123;cur_user.title()&#125;</span>&quot;</span>)</span><br><span class="line">	confirmed_users.append(cur_user)</span><br><span class="line">print(unconfirmed_users)</span><br><span class="line">print(confirmed_users)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[&#39;alice&#39;, &#39;brian&#39;, &#39;candace&#39;]</span><br><span class="line">[]</span><br><span class="line">verifying user:Candace</span><br><span class="line">verifying user:Brian</span><br><span class="line">verifying user:Alice</span><br><span class="line">[]</span><br><span class="line">[&#39;candace&#39;, &#39;brian&#39;, &#39;alice&#39;]</span><br></pre></td></tr></table></figure>
<h2 id="7-3-2删除为特定值的所有列表元素"><a href="#7-3-2删除为特定值的所有列表元素" class="headerlink" title="7.3.2删除为特定值的所有列表元素"></a>7.3.2删除为特定值的所有列表元素</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pets = [<span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;goldfish&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;rabbit&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>]</span><br><span class="line">print(pets)</span><br><span class="line"><span class="keyword">while</span> <span class="string">&#x27;cat&#x27;</span> <span class="keyword">in</span> pets:</span><br><span class="line">	pets.remove(<span class="string">&#x27;cat&#x27;</span>)</span><br><span class="line">print(pets)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#39;dog&#39;, &#39;cat&#39;, &#39;dog&#39;, &#39;goldfish&#39;, &#39;cat&#39;, &#39;rabbit&#39;, &#39;cat&#39;]</span><br><span class="line">[&#39;dog&#39;, &#39;dog&#39;, &#39;goldfish&#39;, &#39;rabbit&#39;]</span><br></pre></td></tr></table></figure>
<h2 id="7-3-3-使用用户输入来填充字典"><a href="#7-3-3-使用用户输入来填充字典" class="headerlink" title="7.3.3 使用用户输入来填充字典"></a>7.3.3 使用用户输入来填充字典</h2><p>可使用while循环提示用户输入任意多的信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">responses = &#123;&#125;</span><br><span class="line">polling_active = <span class="literal">True</span><span class="comment">#设置一个标志，指出调查是否继续</span></span><br><span class="line"><span class="keyword">while</span> polling_active:</span><br><span class="line">    name = <span class="built_in">input</span>(<span class="string">&quot;\nWhat is your name?&quot;</span>)</span><br><span class="line">    response = <span class="built_in">input</span>(<span class="string">&quot;which mountain would you like to climb someday?&quot;</span>)</span><br><span class="line">    responses[name] = response</span><br><span class="line">    </span><br><span class="line">    repeat = <span class="built_in">input</span>(<span class="string">&quot;would you like to let another person respond?(yes/no)&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> repeat == <span class="string">&#x27;no&#x27;</span>:</span><br><span class="line">        polling_active = <span class="literal">False</span></span><br><span class="line">print(<span class="string">&quot;\n---poll results---&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> name, response <span class="keyword">in</span> responses.items():</span><br><span class="line">    print(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span> would like to climb <span class="subst">&#123;response&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">What is your name?zhangsan</span><br><span class="line"></span><br><span class="line">which mountain would you like to climb someday?Deanli</span><br><span class="line"></span><br><span class="line">would you like to let another person respond?(yes&#x2F;no)yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">What is your name?lisi</span><br><span class="line"></span><br><span class="line">which mountain would you like to climb someday?Devil&#96;s Thumb</span><br><span class="line"></span><br><span class="line">would you like to let another person respond?(yes&#x2F;no)no</span><br><span class="line"></span><br><span class="line">---poll results---</span><br><span class="line">zhangsan would like to climb Deanli</span><br><span class="line">lisi would like to climb Devil&#96;s Thumb</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/08/Java_Notes/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/08/Java_Notes/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" class="post-title-link" itemprop="url">Java集合框架</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-06-08 14:43:03 / 修改时间：14:41:21" itemprop="dateCreated datePublished" datetime="2021-06-08T14:43:03+08:00">2021-06-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Java高级教程</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/06/08/Java_Notes/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/06/08/Java_Notes/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h1><p>集合框架被设计成要满足以下几个目标。</p>
<ul>
<li>该框架必须是高性能的。基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的。</li>
<li>该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。</li>
<li>对一个集合的扩展和适应必须是简单的。</li>
</ul>
<p>为此，整个集合框架就围绕一组标准接口而设计。你可以直接使用这些接口的标准实现，诸如：LinkedList，HashSet和TreeSet等，除此之外你也可以通过这些接口实现自己的集合。</p>
<p><img src="D:/Typora/https:cdn.jsdelivr.net/gh/TheNormalPeople/BlogImage/img/20210531163613.gif" alt="Java集合框架"></p>
<p>从上面集合框架图可以看到，Java集合框架主要包括两种类型的容器</p>
<ul>
<li><strong>集合（Collection）</strong>：存储一个元素集合。Collection接口又有三种子类型。<ul>
<li>List</li>
<li>Set</li>
<li>Queue</li>
</ul>
</li>
<li><strong>图（Map）</strong>：存储键-值对映射。</li>
</ul>
<p>集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容。</p>
<ul>
<li><strong>接口</strong>：是代表集合的抽象数据类型。例如：Collection、List、Set、Map等。之所以定义多个接口，是为了以不同的方式操作集合对象。</li>
<li><strong>实现（类）</strong>：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。</li>
<li><strong>算法</strong>：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。</li>
</ul>
<p>除了集合，该框架也定义了集合Map接口和类。Map里存储的是键-值对。尽管不是集合，但是他们完全整合在集合中。</p>
<p><img src="java笔记图片/集合框架体系.png" alt="集合框架体系"></p>
<p>java集合框架位于java.util包中， 所以当使用集合框架的时候需要进行导包。</p>
<h2 id="集合接口"><a href="#集合接口" class="headerlink" title="集合接口"></a>集合接口</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">接口描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>Collection接口</strong><br />Collection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素，Java不提供直接继承自Collection的类，只提供继承于的子接口（如List和Set）。<br />Collection接口存储一组不唯一，无序的对象。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>List接口</strong><br />List接口是一个有序的Collection，使用此接口能够精确的控制每个元素插入的位置，能够通过索引（元素在List中位置，类似于数组的下标）来访问List中的元素，第一个元素的索引为0，而且允许有相同的元素。<br />List接口存储一组不唯一，有序（插入顺序）的对象。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>Set接口</strong><br />Set具有与Collection完全一样的接口，只是行为上不同，Set不保存重复的元素。<br />Set接口存储一组唯一，无序的对象。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>SortedSet接口</strong><br />继承于Set，保存有序的集合。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><strong>Map接口</strong><br />Map接口存储一组键值对象，提供key（键）到value（值）的映射。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><strong>Map.Entry接口</strong><br />描述在一个Map中的一个元素（键-值对）。是一个Map的内部接口。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"><strong>SortedMap接口</strong><br />继承于Map，使Key保持在升序排列。</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left"><strong>Enumeration接口</strong><br />这是一个传统的接口和定义的方法，通过它可以枚举（一次获得一个）对象集合中的元素。这个传统接口已被迭代器取代。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Set和List的区别</strong></p>
<ul>
<li>Set接口实例存储是无序的、不重复的数据。List接口实例存储的是有序的、可以重复的元素。</li>
<li>Set检索效率低下，删除和插入效率高，插入和删除不会引起位置改变。</li>
<li>List和数组类似，可以动态增长，根据实际存储的数据长度自动增长List的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变。</li>
</ul>
<h2 id="集合实现类（集合类）"><a href="#集合实现类（集合类）" class="headerlink" title="集合实现类（集合类）"></a>集合实现类（集合类）</h2><p>Java提供了一套实现了Collection接口的标准集合类。其中一些是具体类，这些类可以直接拿来使用，而另外一些是抽象类，提供了接口的部分实现。</p>
<p>标准集合类汇总于下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>类描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><strong>AbstractCollection</strong><br />实现了大部分的集合接口。</td>
</tr>
<tr>
<td>2</td>
<td><strong>AbstractList</strong><br />继承于AbstractCollection并且实现了大部分List接口。</td>
</tr>
<tr>
<td>3</td>
<td><strong>AbstractSequentialList</strong><br />继承于AbstractList，提供了对数据元素的链式访问而不是随机访问。</td>
</tr>
<tr>
<td>4</td>
<td><strong>LinkedList</strong><br />该类实现了List接口，允许有null（空）元素。主要用于创建链表数据结构，该类没有同步方法，如果多个线程同时访问一个List，则必须自己实现访问同步，解决方法就是在创建List时候构造一个同步的List。例如：<code>List list = Collection.synchronizedList(newLinkedList(...));</code><br />LinkedList查找效率低。</td>
</tr>
<tr>
<td>5</td>
<td><strong>ArrayList</strong><br />该类也实现了List接口，实现了可变大小的数组，随机访问和遍历元素时，提供更好的性能。该类也是非同步的，在多线程的情况下不要使用。ArrayList增长当前长度的50%，插入删除效率低。</td>
</tr>
<tr>
<td>6</td>
<td><strong>AbstractSet</strong><br />继承于AbstractCollection并且实现了大部分Set接口。</td>
</tr>
<tr>
<td>7</td>
<td><strong>HashSet</strong><br />该类实现了Set接口，不允许出现重复元素，不保证集合中元素的顺序，允许包含值为null的元素，但最多只能一个。</td>
</tr>
<tr>
<td>8</td>
<td><strong>LinkedHashSet</strong><br />具有可预知迭代顺序的Set接口的哈希表和链接列表实现。</td>
</tr>
<tr>
<td>9</td>
<td><strong>TreeSet</strong><br />该类实现了Set接口，可以实现排序等功能。</td>
</tr>
<tr>
<td>10</td>
<td><strong>AbstractMap</strong><br />实现了大部分的Map接口。</td>
</tr>
<tr>
<td>11</td>
<td><strong>HashMap</strong><br />HashMap是一个散列表，它存储的内容是键值对（key-value）映射。<br />该类实现了Map接口，根据键的HashCode值存储数据，具有很快的访问速度，最多允许一条记录的键为null，不支持线程同步。</td>
</tr>
<tr>
<td>12</td>
<td><strong>TreeMap</strong><br />继承了AbstractMap，并且使用一棵树。</td>
</tr>
<tr>
<td>13</td>
<td><strong>WeakHashMap</strong><br />继承AbstractMap类，使用弱秘钥的哈希表。</td>
</tr>
<tr>
<td>14</td>
<td><strong>LinkedHashMap</strong><br />继承于HashMap，使用元素的自然顺序对元素进行排序。</td>
</tr>
<tr>
<td>15</td>
<td><strong>IdentityHashMap</strong><br />继承AbstractMap类，比较文档时使用引用相等。</td>
</tr>
</tbody>
</table>
</div>
<p>java.util包中定义的类，如下所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>类描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><strong>Vector</strong><br />该类和ArrayList非常相似，但是该类是同步的，可以用在多线程的情况，该类允许设置默认的增长长度，默认扩容方式为原来的2倍。</td>
</tr>
<tr>
<td>2</td>
<td><strong>Stack</strong><br />栈是Vector的一个子类，它实现了一个标准的后进先出的栈。</td>
</tr>
<tr>
<td>3</td>
<td><strong>Dictionary</strong><br />Dictionary类是一个抽象类，用来存储键-值对，作用和Map类相似。</td>
</tr>
<tr>
<td>4</td>
<td><strong>Hashtable</strong><br />Hashtable是Dictionary（字典）类的子类，位于java.util包中。</td>
</tr>
<tr>
<td>5</td>
<td><strong>Properties</strong><br />Properties继承于Hashtable，表示一个持久的属性集，属性列表中每个键及其对应的值都是一个字符串。</td>
</tr>
<tr>
<td>6</td>
<td><strong>BitSet</strong><br />一个BitSet类创建一种特殊类型的数组来保存位值。BitSet中数组大小会随需要增加。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="集合算法"><a href="#集合算法" class="headerlink" title="集合算法"></a>集合算法</h2><p>集合框架定义了几种算法，可用于集合和映射。这些算法被定义为集合类的静态方法。</p>
<p>在尝试比较不兼容的类型时，一些方法能够抛出ClassCastException异常。当试图修改一个不可修改的集合时，抛出UnsupportedOperationException异常。</p>
<p>集合定义三个静态的变量：EMPTY_SET，EMPTY_LIST，EMPTY_MAP。这些变量都不可改变。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>算法描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><strong>Collection Algorithms</strong><br/>这里是一个列表中的所有算法实现。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="如何使用迭代器"><a href="#如何使用迭代器" class="headerlink" title="如何使用迭代器"></a>如何使用迭代器</h2><p>通常情况下，你会希望遍历一个集合中的元素。例如，显示集合中的每个元素。</p>
<p>一般遍历数组都是采用for循环或者增强for循环，这两个方法也可以用在集合框架，但是还有一种方法是采用迭代器遍历集合框架，它是一个对象，实现了Iterator接口或ListIterator接口。</p>
<p>迭代器，能够通过循环来得到或删除集合的元素。ListIterator继承了Iterator，以允许双向遍历列表和修改元素。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>迭代器方法描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>使用Java Iterator<br />这里通过实例列出Iterator和ListIterator接口提供的所有方法。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="遍历ArrayList"><a href="#遍历ArrayList" class="headerlink" title="遍历ArrayList"></a>遍历ArrayList</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;hahahaha&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一种遍历方法使用for-each遍历List</span></span><br><span class="line">        <span class="keyword">for</span>(String str : list)&#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种遍历，把链表变为数组相关的内容进行遍历</span></span><br><span class="line">        String[] strArray = <span class="keyword">new</span> String[list.size()];</span><br><span class="line">        list.toArray(strArray); <span class="comment">//将list变为String数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strArray.length; i++)&#123;</span><br><span class="line">            System.out.println(strArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三种遍历，使用迭代器进行相关遍历</span></span><br><span class="line">        Iterator&lt;String&gt; iter = list.iterator(); <span class="comment">//将list的迭代器赋给iter</span></span><br><span class="line">        <span class="keyword">while</span>(iter.hasNext())&#123;<span class="comment">//判断下一个元素之后有值</span></span><br><span class="line">            System.out.println(iter.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解析</strong>：三种方法都是采用遍历ArrayList集合，第三种方法是采用迭代器的方法，该方法可以不用担心在遍历的过程中会超出集合的长度。</p>
<h3 id="遍历Map"><a href="#遍历Map" class="headerlink" title="遍历Map"></a>遍历Map</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Map_IteratorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;value3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一种：普遍使用，二次取值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;通过Map.KeySet遍历key和value：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(String key : map.keySet())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;key = &quot;</span> + key + <span class="string">&quot; and value = &quot;</span> + map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种：</span></span><br><span class="line">        System.out.println(<span class="string">&quot;通过Map.entrySet使用iterator遍历key和value&quot;</span>);</span><br><span class="line">        Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            Map.Entry&lt;String, String&gt; entry = it.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;key = &quot;</span> + entry.getKey() + <span class="string">&quot; and value = &quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三种：推荐，尤其是容量大时</span></span><br><span class="line">        System.out.println(<span class="string">&quot;通过Map.entrySet遍历key和value&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String, String&gt; entry : map.entrySet())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;key = &quot;</span> + entry.getKey() + <span class="string">&quot; and value = &quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第四种</span></span><br><span class="line">        System.out.println(<span class="string">&quot;通过Map.values()遍历所有的value，但不能遍历key&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String v : map.values())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;value = &quot;</span> + v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="如果使用比较器"><a href="#如果使用比较器" class="headerlink" title="如果使用比较器"></a>如果使用比较器</h2><p>TreeSet和TreeMap的按照排序顺序来存储元素，然而，这是通过比较器来精确定义按照什么样的排序顺序。</p>
<p>这个接口可以让我们以不同的方式来排序一个集合。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>比较器方法描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>使用Java Comparator<br />这里通过实例列出Comparator接口提供的所有方法</td>
</tr>
</tbody>
</table>
</div>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java集合框架为程序员提供了预先包装的数据结构和算法来操作它们。</p>
<p>集合是一个对象，可容纳其他对象的引用。集合接口声明对每一种类型的集合可以执行的操作。</p>
<p>集合框架的类和接口均在java.util包中。</p>
<p>任何对象加入集合类后，自动转变为Object类型，所以在取出的是否，需要进行强制类型转换。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/08/Data%20_Competition/Python_Foundation/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%97%E5%85%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/08/Data%20_Competition/Python_Foundation/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%97%E5%85%B8/" class="post-title-link" itemprop="url">第六章 字典</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-08 14:42:31" itemprop="dateCreated datePublished" datetime="2021-06-08T14:42:31+08:00">2021-06-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-02 21:52:50" itemprop="dateModified" datetime="2021-07-02T21:52:50+08:00">2021-07-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">数据竞赛</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/06/08/Data%20_Competition/Python_Foundation/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%97%E5%85%B8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/06/08/Data%20_Competition/Python_Foundation/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%97%E5%85%B8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="6-1-一个简单的字典"><a href="#6-1-一个简单的字典" class="headerlink" title="6.1 一个简单的字典"></a>6.1 一个简单的字典</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">human_0 = &#123;<span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;age&#x27;</span> : <span class="number">24</span>&#125;</span><br><span class="line">print(human_0[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line">print(human_0[<span class="string">&#x27;age&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zhangsan</span><br><span class="line">24</span><br></pre></td></tr></table></figure>
<h1 id="6-2-使用字典"><a href="#6-2-使用字典" class="headerlink" title="6.2 使用字典"></a>6.2 使用字典</h1><p>在Python中，<strong>字典</strong>是一系列键值对。每个<strong>键</strong>都与一个值相关联，可使用键来访问相关联的值。与键相关联的值可以是数、字符串、列表乃至字典。事实上，可将任何Python对象用作字典中的值。</p>
<p>在Python中，字典用放在花括号（{}）中的一系列键值对表示。键值对是两个相关联的值。指定键时，Python将返回与之相关联的值。键和值之间用冒号分隔，而键值对之间用逗号分隔。</p>
<h2 id="6-2-1-访问字典中的值"><a href="#6-2-1-访问字典中的值" class="headerlink" title="6.2.1 访问字典中的值"></a>6.2.1 访问字典中的值</h2><p>要获取与键相关联的值，可依次指定字典名和放在方括号内的键</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">student_1 = &#123;<span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;lisi&#x27;</span>, <span class="string">&#x27;age&#x27;</span> : <span class="number">25</span>&#125;</span><br><span class="line">print(student_1[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line">print(student_1[<span class="string">&#x27;age&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lisi</span><br><span class="line">25</span><br></pre></td></tr></table></figure>
<h2 id="6-2-2-添加键值对"><a href="#6-2-2-添加键值对" class="headerlink" title="6.2.2 添加键值对"></a>6.2.2 添加键值对</h2><p>字典一种动态结构，可随时在其中添加键值对。要添加键值对，可依次指定字典名、用方括号括起的键和相关联的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">student_1 = &#123;<span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;lisi&#x27;</span>, <span class="string">&#x27;age&#x27;</span> : <span class="number">25</span>&#125;</span><br><span class="line">print(student_1)</span><br><span class="line">student_1[<span class="string">&#x27;height&#x27;</span>] = <span class="number">175</span></span><br><span class="line">print(student_1)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#39;name&#39; : &#39;lisi&#39;, &#39;age&#39; : 25&#125;</span><br><span class="line">&#123;&#39;name&#39; : &#39;lisi&#39;, &#39;age&#39; : 25, &#39;height&#39; : 175&#125;</span><br></pre></td></tr></table></figure>
<p>在Python3.7中，字典中元素的排列顺序与定义时相同。如果将字典打印出来或遍历其元素，将发现元素的排列顺序与添加顺序相同。</p>
<h2 id="6-2-3-先创建一个空字典"><a href="#6-2-3-先创建一个空字典" class="headerlink" title="6.2.3 先创建一个空字典"></a>6.2.3 先创建一个空字典</h2><p>在空字典中添加键值对有时候可提供便利，而有时候必须这样做。为此，可先使用一对空花括号定义一个字典，再分行添加各个键值对。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">student_1 = &#123;&#125;</span><br><span class="line">student_1[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;zhangsan&#x27;</span></span><br><span class="line">student_1[<span class="string">&#x27;age&#x27;</span>] = <span class="number">24</span></span><br><span class="line">student_1[<span class="string">&#x27;height&#x27;</span>] = <span class="number">175</span></span><br><span class="line">print(student_1)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#39;name&#39; : &#39;zhangsan&#39;, &#39;age&#39; : 24, &#39;height&#39; : 175&#125;</span><br></pre></td></tr></table></figure>
<p>使用字典来存储用户提供的数据或在编写能自动生成大量键值对的代码时，通常需要先定义一个空字典。</p>
<h2 id="6-2-4-修改字典中的值"><a href="#6-2-4-修改字典中的值" class="headerlink" title="6.2.4 修改字典中的值"></a>6.2.4 修改字典中的值</h2><p>要修改字典中的值，可依次指定字典名、用方括号括起的键，以及与该键相关联的新值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">student_1 = &#123;<span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;age&#x27;</span> : <span class="number">24</span>, <span class="string">&#x27;height&#x27;</span> : <span class="number">175</span>&#125;</span><br><span class="line">print(student_1)</span><br><span class="line">student_1[<span class="string">&#x27;age&#x27;</span>] = <span class="number">25</span></span><br><span class="line">print(student_1)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#39;name&#39; : &#39;zhangsan&#39;, &#39;age&#39; : 24, &#39;height&#39; : 175&#125;</span><br><span class="line">&#123;&#39;name&#39; : &#39;zhangsan&#39;, &#39;age&#39; : 25, &#39;height&#39; : 175&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-2-5删除键值对"><a href="#6-2-5删除键值对" class="headerlink" title="6.2.5删除键值对"></a>6.2.5删除键值对</h2><p>对于字典中不再需要的信息，可使用del语句将相应的键值对彻底删除。使用del语句时，必须指定字典名和要删除的键。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">student_1 = &#123;<span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;age&#x27;</span> : <span class="number">24</span>, <span class="string">&#x27;height&#x27;</span> : <span class="number">175</span>&#125;</span><br><span class="line">print(student_1)</span><br><span class="line"><span class="keyword">del</span> student_1[<span class="string">&#x27;height&#x27;</span>]</span><br><span class="line">print(student_1)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#39;name&#39; : &#39;zhangsan&#39;, &#39;age&#39; : 24, &#39;height&#39; : 175&#125;</span><br><span class="line">&#123;&#39;name&#39; : &#39;zhangsan&#39;, &#39;age&#39; : 24&#125;</span><br></pre></td></tr></table></figure>
<p>删除的键值对会永远消失。</p>
<h2 id="6-2-6-由类似对象组成的字典"><a href="#6-2-6-由类似对象组成的字典" class="headerlink" title="6.2.6 由类似对象组成的字典"></a>6.2.6 由类似对象组成的字典</h2><p>在前面的示例中，字典存储的是一个对象的多种信息，当也可以使用字典来存储众多对象的同一种信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">favorite_languages = &#123;<span class="string">&#x27;jen&#x27;</span> : <span class="string">&#x27;Pythone&#x27;</span>, <span class="string">&#x27;sarah&#x27;</span> : <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;edward&#x27;</span> : <span class="string">&#x27;Ruby&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-2-7-使用get-来访问值"><a href="#6-2-7-使用get-来访问值" class="headerlink" title="6.2.7 使用get()来访问值"></a>6.2.7 使用get()来访问值</h2><p>使用放在方括号内的键从字典中获取感兴趣的值时，可能会引发问题：如果指定的键不存在就会出错。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">student_1 = &#123;<span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;age&#x27;</span> : <span class="number">24</span>&#125;</span><br><span class="line">print(student_1[<span class="string">&#x27;height&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#1&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    print(student_1[&#39;height&#39;])</span><br><span class="line">KeyError: &#39;height&#39;</span><br></pre></td></tr></table></figure>
<p>方法get()的第一个参数用于指定键，是必不可少的；第二个参数为指定的键不存在时要返回的值，是可选的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">student_1 = &#123;<span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;age&#x27;</span> : <span class="number">24</span>&#125;</span><br><span class="line">studen_height = studen_1.get(<span class="string">&#x27;height&#x27;</span>, <span class="string">&#x27;There is no key-value&#x27;</span>)</span><br><span class="line">print(student_1[<span class="string">&#x27;height&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">There is no key-value</span><br></pre></td></tr></table></figure>
<p>如果指定的键有可能不存在，应考虑使用方法get()，而不要使用方括号表示法。</p>
<p>调用get()时，如果没有指定第二个参数且指定的键不存在，Python将返回值None。这个特殊值表示没有相应的值。None并非错误，而是一个表示所需值不存在的特殊值。</p>
<h1 id="6-3-遍历字典"><a href="#6-3-遍历字典" class="headerlink" title="6.3 遍历字典"></a>6.3 遍历字典</h1><p>字典可用于以各种方式存储信息，因此有多种遍历方式：可遍历字典的所有键值对，也可仅遍历键或值。</p>
<h2 id="6-3-1-遍历所有键值对"><a href="#6-3-1-遍历所有键值对" class="headerlink" title="6.3.1 遍历所有键值对"></a>6.3.1 遍历所有键值对</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">student_1 = &#123;<span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;age&#x27;</span> : <span class="number">24</span>, <span class="string">&#x27;height&#x27;</span> : <span class="number">175</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> student_1.items():</span><br><span class="line">	print(<span class="string">f&quot;key:<span class="subst">&#123;key&#125;</span>&quot;</span>)</span><br><span class="line">	print(<span class="string">f&quot;value:<span class="subst">&#123;value&#125;</span>\n&quot;</span>)</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">key:name</span><br><span class="line">value:zhangsan</span><br><span class="line"></span><br><span class="line">key:age</span><br><span class="line">value:24</span><br><span class="line"></span><br><span class="line">key:height</span><br><span class="line">value:175</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="6-3-2-遍历字典中的所有键"><a href="#6-3-2-遍历字典中的所有键" class="headerlink" title="6.3.2 遍历字典中的所有键"></a>6.3.2 遍历字典中的所有键</h2><p>在不需要使用字典中的值是，方法keys()很有用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">student_1 = &#123;<span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;age&#x27;</span> : <span class="number">24</span>, <span class="string">&#x27;height&#x27;</span> : <span class="number">175</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> student_1.keys():</span><br><span class="line">	print(key.title())</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Name</span><br><span class="line">Age</span><br><span class="line">Height</span><br></pre></td></tr></table></figure>
<p>遍历字典时，会默认遍历所有的键。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">student_1 = &#123;<span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;age&#x27;</span> : <span class="number">24</span>, <span class="string">&#x27;height&#x27;</span> : <span class="number">175</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> student_1:</span><br><span class="line">	print(key.title())</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Name</span><br><span class="line">Age</span><br><span class="line">Height #输出结果与使用方法keys()一致。</span><br></pre></td></tr></table></figure>
<p>方法keys()并非只能用于遍历：实际上，它返回一个列表，其中包含字典中的所有键。</p>
<h2 id="6-3-3-按特定顺序遍历字典中的所有键"><a href="#6-3-3-按特定顺序遍历字典中的所有键" class="headerlink" title="6.3.3 按特定顺序遍历字典中的所有键"></a>6.3.3 按特定顺序遍历字典中的所有键</h2><p>要以特定顺序返回元素，一种办法是在for循环中对返回的键进行排序。为此，可使用函数sorted()来获得按特定顺序排列的键列表的副本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">student_1 = &#123;<span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;age&#x27;</span> : <span class="number">24</span>, <span class="string">&#x27;height&#x27;</span> : <span class="number">175</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> <span class="built_in">sorted</span>(student_1.keys()):</span><br><span class="line">	print(key.title())</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Age</span><br><span class="line">Name</span><br><span class="line">Height</span><br></pre></td></tr></table></figure>
<h2 id="6-3-4-遍历字典中的所有值"><a href="#6-3-4-遍历字典中的所有值" class="headerlink" title="6.3.4 遍历字典中的所有值"></a>6.3.4 遍历字典中的所有值</h2><p>如果主要对字典包含的值感兴趣，可使用方法values()来返回一个值列表，不包含任何键。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">student_1 = &#123;<span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;age&#x27;</span> : <span class="number">24</span>, <span class="string">&#x27;height&#x27;</span> : <span class="number">175</span>&#125;</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> student_1.values():</span><br><span class="line">	print(value)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zhang</span><br><span class="line">24</span><br><span class="line">175</span><br></pre></td></tr></table></figure>
<p>这种做法提取字典中所有的值，而没有考虑是否重复。涉及的值很少时，这也许不是问题，但如果被调查者很多，最终的列表可能包含大量重复项。为剔除重复项，可使用<strong>集合(set)</strong>。集合中的每个元素都必须是独一无二的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">languages = &#123;<span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;C++&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>&#125;</span><br><span class="line">print(languages)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#39;Python&#39;, &#39;Java&#39;, &#39;C++&#39;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6-4-嵌套"><a href="#6-4-嵌套" class="headerlink" title="6.4 嵌套"></a>6.4 嵌套</h1><p>有时候，需要将一系列字典存储在列表中，或将列表作为值存储在字典中，这称为<strong>嵌套</strong>。</p>
<h2 id="6-4-1-字典列表"><a href="#6-4-1-字典列表" class="headerlink" title="6.4.1 字典列表"></a>6.4.1 字典列表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">student_1 = &#123;<span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;age&#x27;</span> : <span class="number">24</span>, <span class="string">&#x27;height&#x27;</span> : <span class="number">175</span>&#125;</span><br><span class="line">student_2 = &#123;<span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;lisi&#x27;</span>, <span class="string">&#x27;age&#x27;</span> : <span class="number">25</span>, <span class="string">&#x27;height&#x27;</span> : <span class="number">178</span>&#125;</span><br><span class="line">student_3 = &#123;<span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;wangwu&#x27;</span>, <span class="string">&#x27;age&#x27;</span> : <span class="number">26</span>, <span class="string">&#x27;height&#x27;</span> : <span class="number">180</span>&#125;</span><br><span class="line">students = [student_1, student_2, student_3]</span><br><span class="line"><span class="keyword">for</span> student <span class="keyword">in</span> students:</span><br><span class="line">    print(student)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#39;name&#39; : &#39;zhangsan&#39;, &#39;age&#39; : 24, &#39;height&#39; : 175&#125;</span><br><span class="line">&#123;&#39;name&#39; : &#39;lisi&#39;, &#39;age&#39; : 25, &#39;height&#39; : 178&#125;</span><br><span class="line">&#123;&#39;name&#39; : &#39;wangwu&#39;, &#39;age&#39; : 26, &#39;height&#39; : 180&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-4-2-在字典中存储列表"><a href="#6-4-2-在字典中存储列表" class="headerlink" title="6.4.2 在字典中存储列表"></a>6.4.2 在字典中存储列表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">favorite_languages = &#123;</span><br><span class="line">	<span class="string">&#x27;zhangsan&#x27;</span> : [<span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>],</span><br><span class="line">	<span class="string">&#x27;lisi&#x27;</span> : [<span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;C&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;wangwu&#x27;</span> : [<span class="string">&#x27;C++&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>]</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">for</span> name, languages <span class="keyword">in</span> favorite_languages.items():</span><br><span class="line">    print(<span class="string">f&quot;<span class="subst">&#123;name.title()&#125;</span>`s favorite languages are:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> language <span class="keyword">in</span> languages:</span><br><span class="line">        print(<span class="string">f&quot;\t<span class="subst">&#123;language&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Zhangsan&#96;s favorite languages are:</span><br><span class="line">	Python</span><br><span class="line">	Java</span><br><span class="line">Lisi&#96;s favorite languages are:</span><br><span class="line">	Java</span><br><span class="line">	C</span><br><span class="line">Wangwu&#96;s favorite languages are:</span><br><span class="line">	C++</span><br><span class="line">	Python</span><br></pre></td></tr></table></figure>
<h2 id="6-4-3-在字典中存储字典"><a href="#6-4-3-在字典中存储字典" class="headerlink" title="6.4.3 在字典中存储字典"></a>6.4.3 在字典中存储字典</h2><p>与在字典中存储列表类似，这里就不做演示。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/08/Statistical_Learning_Methods_Notes/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%86%B3%E7%AD%96%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/08/Statistical_Learning_Methods_Notes/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%86%B3%E7%AD%96%E6%A0%91/" class="post-title-link" itemprop="url">第五章 决策树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-06-08 10:48:14 / 修改时间：10:47:31" itemprop="dateCreated datePublished" datetime="2021-06-08T10:48:14+08:00">2021-06-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">统计学习方法</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/06/08/Statistical_Learning_Methods_Notes/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%86%B3%E7%AD%96%E6%A0%91/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/06/08/Statistical_Learning_Methods_Notes/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%86%B3%E7%AD%96%E6%A0%91/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="5-1-决策树模型与学习"><a href="#5-1-决策树模型与学习" class="headerlink" title="5.1 决策树模型与学习"></a>5.1 决策树模型与学习</h1><p>决策树（decision tree）是一种基本的分类与回归方法。</p>
<p>决策树学习通常包括$3$个步骤：特征选择、决策树的生成和决策树的修剪。</p>
<h2 id="5-1-1-决策树模型"><a href="#5-1-1-决策树模型" class="headerlink" title="5.1.1 决策树模型"></a>5.1.1 决策树模型</h2><p><strong>定义5.1（决策树）</strong>  分类决策树模型是一种描述对实例进行分类的树形结构。决策树由<strong>结点（node）</strong>和<strong>有向边（directed edge）</strong>组成。结点有两种类型：<strong>内部结点（internal node）</strong>和<strong>叶结点（leaf node）</strong>。内部结点表示一个特征或属性，叶结点表示一个类。</p>
<p>用决策树分类，从根结点开始，对实例的某一特征进行测试，根据测试结果，将实例分配到其子结点；这时，每一个子结点对应着该特征的一个取值。如此递归地对实例进行测试并分配，直至达到叶结点。最后将实例分到叶结点的类中。</p>
<h2 id="5-1-2-决策树与if-then规则"><a href="#5-1-2-决策树与if-then规则" class="headerlink" title="5.1.2 决策树与if-then规则"></a>5.1.2 决策树与if-then规则</h2><p>可以将决策树看成一个if-then规则的集合。将决策树转换成if-then规则的过程是这样的：</p>
<ul>
<li>由决策树的根结点到叶结点的每一条路径构建一条规则；</li>
<li>路径上内部结点的特征对应着规则的条件，而叶结点的类对应着规则的结论。</li>
</ul>
<p>决策树的路径或其对应的if-then规则集合具有一个重要的性质：<strong>互斥并且完备</strong>。这就是说，每一个实例都被一条路径或一条规则所覆盖，而且只被一条路径或一条规则所覆盖。这里所谓覆盖是指实例的特征与路径上的特征一致或实例满足规则的条件。</p>
<h2 id="5-1-3-决策树与条件概率分布"><a href="#5-1-3-决策树与条件概率分布" class="headerlink" title="5.1.3 决策树与条件概率分布"></a>5.1.3 决策树与条件概率分布</h2><p>决策树还表示给定特征条件下类的条件概率分布。这一条件概率分布定义在特征空间的一个<strong>划分（partition）</strong>上。将特征空间划分为互不相交的<strong>单元（cell）</strong>或<strong>区域（region）</strong>，并在每个单元定义一个类的概率分布就构成了一个条件概率分布。决策树的一条路径对应于划分中的一个单元。决策树所表示的条件概率分布由各个单元给定条件下类的条件概率分布组成。</p>
<p>假设$X$为表示特征的随机变量，$Y$为表示类的随机变量，那么这个条件概率分布可以表示为$P(Y|X)$。$X$取值于给定划分下单元的集合，$Y$取值于类的集合。</p>
<p>各叶结点（单元）上的条件概率往往偏向某一个类，即属于某一类的概率较大。决策树分类时将该结点的实例强行分到条件概率大的那一类去。</p>
<h2 id="5-1-4-决策树学习"><a href="#5-1-4-决策树学习" class="headerlink" title="5.1.4 决策树学习"></a>5.1.4 决策树学习</h2><p>假设给定训练数据集</p>
<script type="math/tex; mode=display">
D = \{(x_1,y_1),(x_2,y_2),...,(x_N,y_N)\}</script><p>其中，$x_i=(x_i^{(1)},x_i^{(2)},…x_i^{(n)})^T$为输入实例（特征向量），$n$为特征个数，$y_i \in \{1,2,…,K\}$为类标记，$i=1,2,…,N,N$为样本容量。</p>
<p>决策树学习本质上是从训练数据集中归纳出一组分类规则。</p>
<p>与训练数据集不相矛盾的决策树（即能对训练数据进行正确分类的决策树）可能有多个，也可能一个都没有。我们需要的是一个与训练数据矛盾较小的决策树，同时具有很好的泛化能力。</p>
<p>从另一个角度看，决策树学习是由训练数据集估计条件概率模型。基于特征空间划分的类的条件概率模型有无穷多个。我们选择的条件概率模型应该不仅对训练数据有很好的拟合，而且对未知数据有很好的预测。</p>
<p>决策树学习用损失函数表示这一目标。决策树学习的损失函数通常是正则化的极大似然函数。决策树学习的策略是以损失函数为目标函数的最小化。现实中决策树学习算法通常采用启发式方法，近似求解这一最优化问题。这样得到的决策树是<strong>次最优（sub-optimal）</strong>的。</p>
<p>决策树学习的算法通常是一个递归地选择最优特征，并根据该特征对训练数据进行分割，使得对各个子数据集有一个最好的分类过程。这一过程对应着对特征空间的划分，也对应着决策树的构建。</p>
<ul>
<li><p>开始，构建根结点，将所有训练数据都放在根结点。选择一个最优特征，按照这一特征将训练数据集分割成子集，使得各个子集有一个在当前条件下最好的分类。</p>
</li>
<li><p>如果这些子集已经能够被正确分类，那么构建叶结点，并将这些子集分到对应的叶结点中去；</p>
</li>
<li>如果还有子集不能被基本正确分类，那么久对这些子集选择新的最优特征，继续对其进行分割，构建相应的结点。</li>
<li>如此递归下去，直至所有训练数据子集都被基本正确分类，或者没有合适的特征为止。</li>
<li>最后每个子集都被分到叶结点上，即都有了明确的类。</li>
</ul>
<p>以上方法生成的决策树可能对训练数据有很好的分类能力，但对未知的测试数据却未必有很好的分类能力，即可能发生过拟合想象。我们需要对已生成的树自下而上进行剪枝，将树变得跟简单，从而使它具有更好的泛化能力。具体地，就是去掉过于细分的叶结点，使其回退到父结点，甚至更高的结点，然后将父结点或更高的结点改为新的叶结点。</p>
<h1 id="5-2-特征选择"><a href="#5-2-特征选择" class="headerlink" title="5.2 特征选择"></a>5.2 特征选择</h1><h2 id="5-2-1-特征选择问题"><a href="#5-2-1-特征选择问题" class="headerlink" title="5.2.1 特征选择问题"></a>5.2.1 特征选择问题</h2><p>如果利用一个特征进行分类的结果与随机分类的结果没有很大差别，称这个特征是没有分类能力的。经验上扔掉这样的特征对决策树学习的精度影响不大。</p>
<p>特征选择是决定用哪个特征来划分特征空间。通常特征选择的准则是信息增益或信息增益比。</p>
<h2 id="5-2-2-信息增益"><a href="#5-2-2-信息增益" class="headerlink" title="5.2.2 信息增益"></a>5.2.2 信息增益</h2><p><strong>熵（entropy）</strong>是表示随机变量不确定性的度量。</p>
<ul>
<li>设$X$是一个取有限个值的离散随机变量，其概率分布为</li>
</ul>
<script type="math/tex; mode=display">
P(X=x_i) = p_i, \ \ \ i = 1,2,...,n</script><p>​        则随机变量$X$的熵定义为</p>
<script type="math/tex; mode=display">
H(X) = - \sum\limits_{i=1}^{n} p_i \log p_i \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.1)</script><p>​        若$p_i = 0$，则定义$0\log 0 = 0$。通常，式$(5.1)$中的对数以$2$为底或以$e$为底（自然对数）这时熵的单位分别称作<strong>比特（bit）</strong>或<strong>纳特（nat）</strong>。</p>
<p>​        熵只依赖于$X$的分布，而与$X$的取值无关，所以也可将$X$的熵记作$H(p)$，即</p>
<script type="math/tex; mode=display">
H(p) = - \sum\limits_{i=1}^{n} p_i \log p_i \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.2)</script><p>​        熵越大，随机变量的不确定性就越大。从定义可验证</p>
<script type="math/tex; mode=display">
0 \leq H(p) \leq \log n \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.3)</script><ul>
<li>设有随机变量$(X,Y)$，其联合概率分布为<script type="math/tex; mode=display">
P(X=x_i,Y=y_i) = p_{ij},\ \ \ i=1,2,...,n; \ \ \ j = 1,2,...,m</script>条件熵$H(Y|X)$表示在已知随机变量$X$的条件下随机变量$Y$的不确定性。定义为$X$给定条件下$Y$的条件概率分布的熵对$X$的数学期望<script type="math/tex; mode=display">
H(Y|X) = \sum\limits_{i=1}^{n}p_iH(Y|X=x_i) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.5)</script>这里，$p_i=P(X=x_i),i=1,2,…,n$。</li>
</ul>
<p>当熵和条件熵中的概率估计由数据估计（特别是极大似然估计）得到时，所对应的熵与条件熵分别称为<strong>经验熵（empirical entropy）</strong>和<strong>经验条件熵（empirical conditional entropy）</strong>。</p>
<p><strong>信息增益（information gain）</strong>表示得知特征$X$的信息而使得类$Y$的信息的不确定性减少的程度。</p>
<p><strong>定义 5.2（信息增益）</strong>  特征$A$对训练数据集$D$的信息增益$g(D,A)$，定义为集合$D$的经验熵$H(D)$与特征$A$给定条件下$D$的经验条件熵$H(D|A)$之差，即</p>
<script type="math/tex; mode=display">
g(D,A)=H(D)-H(D|A) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.6)</script><p>一般地，熵$H(Y)$与条件熵$H(Y|X)$之差称为<strong>互信息（mutual information）</strong>。决策树学习中的信息增益等价于训练数据集中类与特征的互信息。</p>
<p>给定训练数据集$D$和特征$A$：</p>
<ul>
<li>经验熵$H(D)$，表示对数据集$D$进行分类的不确定性。</li>
<li>经验条件熵$H(D|A)$，表示在特征$A$给定的条件下对数据集$D$进行分类的不确定性。</li>
<li>信息增益$g(D,A)$，表示由于特征$A$而使得对数据集$D$的分类的不确定性减少的程度。</li>
</ul>
<p>显然，对于数据集$D$而言，信息增益依赖于特征，不同的特征往往具有不同的信息增益。信息增益大的特征具有更强的分类能力。</p>
<p>根据信息增益准则的特征选择方法是：对训练数据集（或子集）$D$，计算其每个特征的信息增益，并比较它们的大小，选择信息增益最大的特征。</p>
<p>设训练数据集为$D$，$|D|$表示其样本容量，即样本个数。设有$K$个类$C_k,k=1,2,…,K,$$|C_k|$为属于类$C_k$的样本个数，$\sum\limits_{k=1}^{K}|C_k|=|D|$。设特征$A$有$n$个不同的取值$\{a_1,a_2,…,a_n\}$，根据特征A的取值将$D$划分为$n$个子集$D_1,D_2,…,D_n$，$|D_i|$为$D_i$的样本数，$\sum\limits_{i=1}^{n}|D_i|=|D|$。记子集$D_i$中属于类$C_k$的样本的集合为$D_{ik}$，即$D_{ik} = D_i \bigcap C_k,|D_{ik}|$为$D_{ik}$的样本个数。于是信息增益的算法如下：</p>
<p><strong>算法 5.1（信息增益的算法）</strong></p>
<p><strong>输入</strong>：训练数据集$D$和特征$A$；</p>
<p><strong>输出</strong>：特征$A$对训练数据集$D$的信息增益$g(D,A)$。</p>
<p>​    （1）计算数据集$D$的经验熵$H(D)$</p>
<script type="math/tex; mode=display">
H(D) = - \sum\limits_{k=1}^{K} \frac{|C_k|}{|D|} \log_2 \frac{|C_k|}{|D|}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.7)</script><p>​    （2）计算特征$A$对数据集$D$的经验条件熵$H(D|A)$</p>
<script type="math/tex; mode=display">
H(D|A)=\sum\limits_{i=1}^{n} \frac{|D_i|}{|D|} H(D_i) = -\sum\limits_{i=1}^{n} \frac{|D_i|}{|D|}\sum\limits_{k=1}^{K}\frac{|D_{ik}|}{|D_i|} \log_2 \frac{|D_{ik}|}{|D_i|}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.8)</script><p>​    （3）计算信息增益</p>
<script type="math/tex; mode=display">
g(D,A) = H(D) - H(D|A)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.9)</script><h2 id="5-2-3-信息增益比"><a href="#5-2-3-信息增益比" class="headerlink" title="5.2.3 信息增益比"></a>5.2.3 信息增益比</h2><p>以信息增益作为划分训练数据集的特征，存在偏向于选择取值较多的特征的问题。信息增益比（information gain ratio）可以对这一问题进行校正。</p>
<p><strong>定义 5.3（信息增益比）</strong>  特征$A$对训练数据集$D$的信息增益比$g_R(D,A)$定义为其信息增益$g(D,A)$与训练数据集$D$关于特征$A$的值的熵$H_A(D)$之比，即</p>
<script type="math/tex; mode=display">
g_R(D,A) = \frac{g(D,A)}{H_A(D)} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.10)</script><p>其中，$H_A(D) = -\sum\limits_{i=1}^{n}\frac{|D_i|}{|D|} \log_2 \frac{|D_i|}{|D|}$，$n$是特征$A$取值的个数。</p>
<h1 id="5-3-决策树的生成"><a href="#5-3-决策树的生成" class="headerlink" title="5.3 决策树的生成"></a>5.3 决策树的生成</h1><h2 id="5-3-1-ID3算法"><a href="#5-3-1-ID3算法" class="headerlink" title="5.3.1 ID3算法"></a>5.3.1 ID3算法</h2><p><strong>ID3算法</strong>的核心是在决策树各个结点上应用信息增益准则选择特征，递归地构建决策树。</p>
<ul>
<li>从根结点（root node）开始，对结点计算所有可能的特征信息增益，选择信息增益最大的特征作为结点的特征，由该特征的不同取值建立结点；</li>
<li>再对子结点递归地调用以上方法，构建决策树；</li>
<li>直到所有特征的信息增益均很小或没有特征可以选择为止。</li>
</ul>
<p><strong>ID3</strong>相当于用极大似然法进行概率模型的选择。</p>
<p><strong>算法 5.2（ID3算法）</strong></p>
<p><strong>输入</strong>：训练数据集$D$，特征集$A$阈值$\epsilon$；</p>
<p><strong>输出</strong>：决策树$T$。</p>
<p>​    （1）若$D$中所有实例属于同一类$C_k$，则$T$为单节点树，并将类$C_k$作为该结点的类标记，返回$T$；</p>
<p>​    （2）若$A = \emptyset$，则$T$为单节点树，并将$D$中实例数最大的类$D_k$作为该结点的类标记，返回$T$；</p>
<p>​    （3）否则，按算法5.1计算$A$中各特征对$D$的信息增益，选择信息增益最大的特征$A_g$；</p>
<p>​    （4）如果$A_g$的信息增益小于阈值$\epsilon$，则置$T$为单结点树，并将$D$中实例数最大的类$C_k$作为该结点的类标记，返回$T$；</p>
<p>​    （5）否则，对$A_g$的每一可能值$a_i$，依$A_g = a_i$将$D$分割为若干非空子集$D_i$，将$D_i$中实例数最大的类作为标记，构建子结点，由结点及子结点构成树$T$，返回$T$；</p>
<p>​    （6）对第$i$个子结点，以$D_i$为训练集，以$A-\{A_g\}$为特征集，递归地调用步（1）~ 步（5），得到子树$T_i$,返回$T_i$。</p>
<p>ID3算法只有树的生成，所以该算法生成的树容易产生过拟合。</p>
<h2 id="5-3-2-C4-5的生成算法"><a href="#5-3-2-C4-5的生成算法" class="headerlink" title="5.3.2 C4.5的生成算法"></a>5.3.2 C4.5的生成算法</h2><p>算法5.3（C4.5的生成算法）</p>
<p>输入：训练数据集$D$，特征集$A$阈值$\epsilon$；</p>
<p>输出：决策树$T$。</p>
<p>​    （1）若$D$中所有实例属于同一类$C_k$，则$T$为单节点树，并将类$C_k$作为该结点的类标记，返回$T$；</p>
<p>​    （2）若$A = \emptyset$，则$T$为单节点树，并将$D$中实例数最大的类$D_k$作为该结点的类标记，返回$T$；</p>
<p>​    （3）否则，按式$(5.10)$计算$A$中各特征对$D$的信息增益比，选择信息增益比最大的特征$A_g$；</p>
<p>​    （4）如果$A_g$的信息增益比小于阈值$\epsilon$，则置$T$为单结点树，并将$D$中实例数最大的类$C_k$作为该结点的类，返回$T$；</p>
<p>​    （5）否则，对$A_g$的每一可能值$a_i$，依$A_g = a_i$将$D$分割为若干非空子集$D_i$，将$D_i$中实例数最大的类作为标记，构建子结点，由结点及子结点构成树$T$，返回$T$；</p>
<p>​    （6）对结点$i$，以$D_i$为训练集，以$A-\{A_g\}$为特征集，递归地调用步（1）~ 步（5），得到子树$T_i$,返回$T_i$。</p>
<h1 id="5-4-决策树的剪枝"><a href="#5-4-决策树的剪枝" class="headerlink" title="5.4 决策树的剪枝"></a>5.4 决策树的剪枝</h1><p>在决策树学习中将已生成的树进行简化的过程称为剪枝（pruning）。具体地，，剪枝从已生成的树上裁掉一些子树或叶结点，并将其根结点或父结点作为新的叶结点，从而简化分类树模型。</p>
<p>决策树的剪枝往往通过极小化决策树整体的<strong>损失函数（loss function）</strong>或<strong>代价函数（cost function）</strong>来实现。</p>
<p>设树$T$的叶结点个数为$|T|$，$t$是树$T$的叶结点，该叶结点有$N_t$个样本点，其中$k$类的样本点有$N_{tk}$个，$k=1,2,…,K$，$H_t(T)$为叶结点$t$上的经验熵，$\alpha \geq 0$为参数，则决策树学习的损失函数可以定义为</p>
<script type="math/tex; mode=display">
C_{\alpha}(T) = \sum\limits_{t=1}^{|T|}N_t H_t(T) + \alpha|T| \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.11)</script><p>其中经验熵为</p>
<script type="math/tex; mode=display">
H_t(T) = - \sum\limits_{k}\frac{N_{tk}}{N_t} \log \frac{N_{tk}}{N_t}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.12)</script><p>在损失函数中，将式$(5.11)$右端的第1项记作</p>
<script type="math/tex; mode=display">
C(T)=\sum\limits_{t=1}^{|T|}N_t H_t(T)=-\sum\limits_{t=1}^{|T|}\sum\limits_{k=1}^{K}N_{tk} \log \frac{N_{tk}}{N_t}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.13)</script><p>这时有</p>
<script type="math/tex; mode=display">
C_{\alpha}(T) = C(T)+\alpha|T| \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.14)</script><p>式$(5.14)$中，$C(T)$表示模型对训练数据的预测误差，即模型与训练数据的拟合程度，$|T|$表示模型复杂度，参数$\alpha \geq 0$控制两者之间的影响。较大的$\alpha$促使选择较简单的模型（树），较小的$\alpha$促使选择较复杂的模型（树）。$\alpha = 0$意味着只考虑模型与训练数据的拟合程度，不考虑模型的复杂度。</p>
<p>剪枝，就是当$\alpha$确定时，选择损失函数最小的模型，即损失函数最小的子树。当$\alpha$值确定时</p>
<ul>
<li>子树越大，往往与训练数据的拟合越好，但是模型的复杂度就越高；</li>
<li>子树越小，模型的复杂度就越低，但是往往与训练数据的拟合不好。</li>
</ul>
<p>损失函数正好表示了对两者的平衡。</p>
<p>决策树生成只考虑了通过提高信息增益（或信息增益比）对训练数据进行更好的拟合。而决策树剪枝通过优化损失函数还考虑了减小模型复杂度。决策树生成学习局部的模型，而决策树剪枝学习整体的模型。</p>
<p>式$(5.11)$或式$(5.14)$定义的损失函数的极小化等价于正则化的极大似然估计。所以，利用损失函数最小原则进行剪枝就是用正则化的极大似然估计进行模型选择。</p>
<p><strong>算法 5.4（树的剪枝算法）</strong></p>
<p><strong>输入</strong>：生成算法产生的整个树$T$，参数$\alpha$；</p>
<p><strong>输出</strong>：修剪后的子树$T_\alpha$。</p>
<p>​    （1）计算每个结点的经验熵。</p>
<p>​    （2）递归地从树的叶结点向上回缩。设一组叶结点回缩到其父结点之前与之后的整体树分别为$T_B$与$T_A$，其对应的损失函数值分别是$C_{\alpha}(T_B)$与$C_{\alpha}(T_A)$，如果</p>
<script type="math/tex; mode=display">
C_{\alpha}(T_A) \leq C_{\alpha}(T_B) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.15)</script><p>则进行剪枝，即将父结点变为新的叶结点。</p>
<p>​    （3）返回（2），直至不能继续为止，得到损失函数最小的子树$T_{\alpha}$。</p>
<h1 id="5-5CART算法"><a href="#5-5CART算法" class="headerlink" title="5.5CART算法"></a>5.5CART算法</h1><p><strong>分类与回归树（classification and regression tree，CART）</strong>同样由特征选择、树的生成及剪枝组成，既可以用于分类也可以用于回归。</p>
<p>CART是在给定输入随机变量$X$条件下输出随机变量$Y$的条件概率分布的学习方法。CART假设决策树是二叉树，内部结点特征的取值为“是”和“否”，左分支是取值为“是”的分支，右分支是取值为“否”的分支。这样的决策树等价于递归地二分每个特征，将输入空间即特征空间划分为有限个单元，并在这些单元上确定预测的概率分布，也就是在输入给定的条件下输出的条件概率分布。</p>
<p>CART算法由以下两步组成：</p>
<ul>
<li>决策树生成：基于训练数据集生成决策树，生成的决策树要尽量大；</li>
<li>决策树剪枝：用验证数据集对已生成的树进行剪枝并选择最优子树，这时用损失函数最小作为剪枝的标准。</li>
</ul>
<h2 id="5-5-1-CART生成"><a href="#5-5-1-CART生成" class="headerlink" title="5.5.1 CART生成"></a>5.5.1 CART生成</h2><p>对回归树用平方误差最小化准则，对分类树用<strong>基尼指数（Gini index）</strong>最小化准则，进行特征选择，生成二叉树。</p>
<ol>
<li><strong>回归树的生成</strong></li>
</ol>
<p>一颗回归树对应着输入空间（即特征空间）的一个划分以及在划分的单元上的输出值。假设已将输入空间划分为$M$个单元$R_1,R_2,…,R_M$，并且在每个单元$R_m$上有一个固定的输出值$c_m$，于是回归树模型可表示为</p>
<script type="math/tex; mode=display">
f(x)=\sum\limits_{m=1}^{M} c_m I(x \in R_m)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.16)</script><p>当输入空间的划分确定时，可以用平方误差$\sum\limits_{x_i \in R_m}(y_i-f(x_i))^2$来表示回归树对于训练数据的预测误差，用平方误差最小的准则求解每个单元上的最优输出值。单元$R_m$上的$c_m$的最优值$\hat c_m$是$R_m$上的所有输入实例$x_i$对应的输出$y_i$的均值，即</p>
<script type="math/tex; mode=display">
\hat c_m = ave(y_i|x_i \in R_m)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.17)</script><p>这里采用启发式的方法对输入空间进行划分。选择第$j$个变量$x^{(j)}$和它取的值$s$，作为<strong>切分变量（splitting variable）</strong>和<strong>切分点（splitting point）</strong>，并定义两个区域：</p>
<script type="math/tex; mode=display">
R_1(j,s) = \{x|x^{(j)} \leq s\} \ \ \  和 \ \ \ R_2(j,s) = \{x|x^{(j)} > s\}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.18)</script><p>然后寻找最优切分变量$j$和最优切分点$s$。具体地，求解</p>
<script type="math/tex; mode=display">
\min\limits_{j,s}[\min\limits_{c_1}\sum\limits_{x_i\in R_1(j,s)}(y_i - c_1)^2 + \min\limits_{c_2}\sum\limits_{x_i\in R_2(j,s)}(y_i - c_2)^2]\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.19)</script><p>对固定输入变量$j$可以找到最优切分点$s$。</p>
<script type="math/tex; mode=display">
\hat c_1 = ave(y_i|x_i \in R_1(j,s)) \ \ \ 和 \ \ \ \hat c_2 = ave(y_i|x_i \in R_2(j,s))\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.20)</script><p>遍历所有输入变量，找到最优的切分变量$j$，构成一个对$(j,s)$。依次将输入空间划分为两个区域。接着，对每个区域重复上述划分过程，直到满足停止条件为止。这样就生成一颗回归树。这样的回归树通常称为<strong>最小二乘回归树（least squares regression tree）</strong>。</p>
<p><strong>算法 5.5（最小二乘回归树生成算法）</strong></p>
<p><strong>输入</strong>：训练数据集$D$；</p>
<p><strong>输出</strong>：回归树$f(x)$。</p>
<p>在训练数据集所在的输入空间中，递归地将每个区域划分为两个子区域并决定每个子区域上的输出值，构建二叉决策树：</p>
<p>​    （1）选择最优切分变量$j$与切分点$s$，求解</p>
<script type="math/tex; mode=display">
\min\limits_{j,s}[\min\limits_{c_1}\sum\limits_{x_i\in R_1(j,s)}(y_i - c_1)^2 + \min\limits_{c_2}\sum\limits_{x_i\in R_2(j,s)}(y_i - c_2)^2]</script><p>遍历变量$j$，对固定的切分变量$j$扫描切分点$s$，选择使上式达到最小值的对$(j,s)$。</p>
<p>​    （2）用选定的对$(j,s)$划分区域并决定相应的输出值：</p>
<script type="math/tex; mode=display">
R_1(j,s) = \{x|x^{(j)} \leq s\}, \ \ \ R_2(j,s) = \{x|x^{(j)} > s\}</script><script type="math/tex; mode=display">
\hat c_m = \frac{1}{N_m}\sum\limits_{x_i\in R_m(j,s)} y_i, \ \ \ x \in R_m, \ \ \ m=1,2</script><p>​    （3）继续对两个子区域调用步骤(1),(2)，直至满足停止条件。</p>
<p>​    （4）将输入空间划分为$M$个区域$R_1,R_2,…,R_M$，生成决策树：</p>
<script type="math/tex; mode=display">
f(x)=\sum\limits_{m=1}^{M} c_m I(x \in R_m)</script><hr>
<ol>
<li><strong>分类树的生成</strong></li>
</ol>
<p>分类树用基尼指数选择最优特征，同时决定该特征的最优二值切分点。</p>
<p><strong>定义 5.4（基尼指数）</strong>  分类问题中，假设有$K$个类，样本点属于第$k$类的概率为$p_k$，则概率分布的基尼指数定义为</p>
<script type="math/tex; mode=display">
Gini(p) = \sum\limits_{k = 1}^{K} p_k(1-p_k) = 1 - \sum\limits_{k = 1}^{K} p_k^2\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.22)</script><p>对于二分类问题，若样本点属于第1个类的概率是$p$，则概率分布的基尼指数为</p>
<script type="math/tex; mode=display">
Gini(p) = 2p(1-p)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.23)</script><p>对于给定的样本集合$D$，其基尼指数为</p>
<script type="math/tex; mode=display">
Gini(D) = 1 - \sum\limits_{k = 1}^{K} (\frac{|C_k|}{|D|})^2 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.24)</script><p>这里，$C_k$是$D$中属于第$k$类的样本子集，$K$是类的个数。</p>
<p>如果样本集合$D$根据特征$A$是否取某一可能值$a$被分割成$D_1$和$D_2$两部分，即</p>
<script type="math/tex; mode=display">
D_1 =\{(x,y)\in D|A(x)=a \}, \ \ \ D_2 = D - D_1</script><p>则在特征$A$的条件下，集合$D$的基尼指数定义为</p>
<script type="math/tex; mode=display">
Gini(D,A)=\frac{|D_1|}{|D|}Gini(D_1) \ +  \ \frac{|D_2|}{|D|}Gini(D_2)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.25)</script><p>基尼指数$Gini(D)$表示集合$D$的不确定性，基尼指数$Gini(D,A)$表示经$A=a$分割后集合$D$的不确定性。基尼指数值越大，样本集合的不确定性也就越大，这一点与熵相似。</p>
<p>基尼指数和熵之半的曲线很接近，都可以近似地代表分类错误率。</p>
<p><strong>算法 5.6（CART生成算法）</strong></p>
<p><strong>输入</strong>：训练数据集$D$，停止计算的条件；</p>
<p><strong>输出</strong>：CART决策树。</p>
<p>根据训练数据集，从根结点开始，递归地对每个结点进行以下操作，构建二叉决策树：</p>
<p>​    （1）设结点的训练数据集为$D$，计算现有特征对该数据集的基尼指数。此时，对每一个特征$A$，对其可能取的每个值$a$，根据样本点对$A=a$的测试为“是”或“否”将$D$分割成$D_1$和$D_2$两部分，利用式$(5.25)$计算$A=a$时的基尼指数。</p>
<p>​    （2）在所有可能的特征$A$以及它们所有可能的切分点$a$中，选择基尼指数最小的特征及其对应的切分点作为最优特征与最优切分点。依最优特征与最优切分点，从现结点生成两个子结点，将训练数据集依特征分配到两个子结点中去。</p>
<p>​    （3）对两个子结点递归地调用(1),(2)，直至满足停止条件。</p>
<p>​    （4）生成CART决策树。</p>
<p>算法停止计算的条件是结点中的样本个数小于预定阈值，或样本集的基尼指数小于预定阈值（样本基本属于同一类），或者没有更多特征。</p>
<h2 id="5-5-2-CART剪枝"><a href="#5-5-2-CART剪枝" class="headerlink" title="5.5.2 CART剪枝"></a>5.5.2 CART剪枝</h2><p>CART剪枝算法由两步组成：</p>
<ul>
<li>首先从生成算法产生的决策树$T_0$底端开始不断剪枝，直到$T_0$的根结点，形成一个子树序列$\{T_0,T_1,…,T_n\}$；</li>
<li>然后通过交叉验证法在独立的验证数据集上对子树序列进行测试，从中选择最优子树。</li>
</ul>
<hr>
<ol>
<li><strong>剪枝，形成一个子树序列</strong></li>
</ol>
<p>在剪枝过程中，计算子树的损失函数：</p>
<script type="math/tex; mode=display">
C_\alpha(T) = C(T) + \alpha|T|\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.26)</script><p>其中，$T$为任意子树，$C(T)$为对训练数据的预测误差（如基尼指数），$|T|$为子树的叶结点个数，$\alpha \geq 0$为参数，$C_\alpha(T)$为参数是$\alpha$时的子树$T$的整体损失。参数$\alpha$权衡训练数据的拟合程度与模型的复杂度。</p>
<p>对固定的$\alpha$，一定存在使损失函数$C_\alpha(T)$最小的子树，将其表示为$T_\alpha$。$T_\alpha$在损失函数$C_\alpha(T)$最小的意义下是最优的。</p>
<ul>
<li>当$\alpha$大的时候，最优子树$T_\alpha$偏小；</li>
<li>当$\alpha$小的时候，最优子树$T_\alpha$偏大；</li>
<li>当$\alpha=0$时，整体树是最优的。</li>
<li>当$\alpha \longrightarrow \infty$时，根结点组成的单结点树是最优的。</li>
</ul>
<p>Breiman等人证明：可以用递归的方法对树进行剪枝。具体地，从整体树$T_0$开始剪枝。对$T_0$的任意内部结点$t$，以$t$为单结点树的损失函数是</p>
<script type="math/tex; mode=display">
C_\alpha(t) = C(t) + \alpha\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.27)</script><p>以$t$为根结点的子树$T_t$的损失函数是</p>
<script type="math/tex; mode=display">
C_\alpha(T_t) = C(T_t) + \alpha|T_t|\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.28)</script><p>当$\alpha = 0$及$\alpha$充分小时，有不等式</p>
<script type="math/tex; mode=display">
C_\alpha(T_t) < C_\alpha(t)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.29)</script><p>当$\alpha$增大时，在某一$\alpha$有</p>
<script type="math/tex; mode=display">
C_\alpha(T_t) = C_\alpha(t)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.30)</script><p>当$\alpha$再增大时，不等式$(5.29)$反向。只要$\alpha = \frac{C(t)-C(T_t)}{|T_t|-1}$，$T_t$与$t$有相同的损失函数值，而$t$的结点少，因此$t$比$T_t$更可取，对$T_t$进行剪枝。</p>
<p>为此，对$T_0$中每一内部结点$t$，计算</p>
<script type="math/tex; mode=display">
g(t)=\frac{C(t)-C(T_t)}{|T_t|-1}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.31)</script><p>它表示剪枝后整体损失函数减少的程度。在$T_0$中减去$g(t)$最小的$T_t$，将得到的子树作为$T_1$，同时将最小的$g(t)$设为$\alpha_1$。$T_1$为区间$[\alpha_1,\alpha_2)$的最优子树。</p>
<p>如此剪枝下去，直至得到根结点。在这一过程中，不断地增加$\alpha$的值，产生新的区间。</p>
<hr>
<ol>
<li><strong>在剪枝得到的子树序列</strong>$T_0,T_1,…,T_n$<strong>中通过交叉验证选取最优子树</strong>$T_\alpha$</li>
</ol>
<p>具体地，利用独立的验证数据集，测试子树序列$T_0,T_1,…,T_n$中各棵子树的平方误差或基尼指数。平方误差或基尼指数最小的决策树被认为是最优的决策树。在子树序列中，每棵子树$T_0,T_1,…,T_n$都对应于一个参数$\alpha_1,\alpha_2,…,\alpha_n$。所以，当最优子树$T_k$确定时，对应的$\alpha_k$也确定了，即得到最优决策树$T_\alpha$。</p>
<hr>
<p><strong>算法 5.7（CART剪枝算法）</strong></p>
<p><strong>输入</strong>：CART算法生成的决策树$T_0$；</p>
<p><strong>输出</strong>：最优决策树$T_\alpha$。</p>
<p>​    （1）设$k=0,T=T_0$。</p>
<p>​    （2）设$\alpha = +\infty$。</p>
<p>​    （3）自下而上地对各个内部结点$t$计算$C(T_t),|T_t|$以及</p>
<script type="math/tex; mode=display">
g(t)=\frac{C(t)-C(T_t)}{|T_t|-1}</script><script type="math/tex; mode=display">
\alpha = \min(\alpha,g(t))</script><p>这里，$T_t$表示以$t$为根结点的子树，$C(T_t)$是对训练数据的预测误差，$|T_t|$是$T_t$的叶结点个数。</p>
<p>​    （4）对$g(t) = \alpha$的内部结点$t$进行剪枝，并对叶结点$t$以多数表决法决定其类，得到树$T$。</p>
<p>​    （5）设$k = k+1,\alpha_k = \alpha,T_k = T$。</p>
<p>​    （6）如果$T_k$不是由根结点及两个叶结点构成的树，则回到步骤(2)；否则令$T_k =T_n$。</p>
<p>​    （7）采用交叉验证法在子树序列$T_0,T_1,…,T_n$中选取最优子树$T_\alpha$。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/default-index/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/default-index/">1</a><span class="page-number current">2</span><a class="page-number" href="/default-index/page/3/">3</a><a class="page-number" href="/default-index/page/4/">4</a><a class="extend next" rel="next" href="/default-index/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Normal People"
      src="/images/posthead.jpg">
  <p class="site-author-name" itemprop="name">Normal People</p>
  <div class="site-description" itemprop="description">Get busy living or get busy dying</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
        
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/TheNormalPeople" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;TheNormalPeople" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1272481411@qq.com" title="E-Mail → mailto:1272481411@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5938927274" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5938927274" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/cy19970506" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;cy19970506" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Normal People</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'y8XFURQNCoQsprRTou9DiEJu-gzGzoHsz',
      appKey     : 'QfVpjKDtJQdJrnJNnWUbVvjH',
      placeholder: "留下邮箱,有空时间回复您！",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
