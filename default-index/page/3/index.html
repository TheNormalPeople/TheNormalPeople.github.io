<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true,"scrollpercent":true,"b2t":true},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Get busy living or get busy dying">
<meta property="og:type" content="website">
<meta property="og:title" content="Blog">
<meta property="og:url" content="http://example.com/default-index/page/3/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="Get busy living or get busy dying">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Normal People">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/default-index/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">by Normal People</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">11</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">34</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/04/Java_Notes/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/04/Java_Notes/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">Java数据结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-04 21:50:01" itemprop="dateCreated datePublished" datetime="2021-06-04T21:50:01+08:00">2021-06-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-31 16:34:52" itemprop="dateModified" datetime="2021-05-31T16:34:52+08:00">2021-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Java高级教程</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/06/04/Java_Notes/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/06/04/Java_Notes/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java数据结构"><a href="#Java数据结构" class="headerlink" title="Java数据结构"></a>Java数据结构</h1><p>Java工具包提供了强大的数据结构。在Java中的数据结构主要包括以下几种接口和类：</p>
<ul>
<li>枚举（Enumeration）</li>
<li>位集合（BitSet）</li>
<li>向量（Vector）</li>
<li>栈（Stack）</li>
<li>字典（Dictionary）</li>
<li>哈希表（Hashtable）</li>
<li>属性（Properties）</li>
</ul>
<p>以上这些类是传统遗留的，在Java2中引入了一种新的框架-集合框架（Collection）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/04/Statistical_Learning_Methods_Notes/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%84%9F%E7%9F%A5%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/04/Statistical_Learning_Methods_Notes/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%84%9F%E7%9F%A5%E6%9C%BA/" class="post-title-link" itemprop="url">第二章 感知机</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-06-04 20:34:57 / 修改时间：21:19:35" itemprop="dateCreated datePublished" datetime="2021-06-04T20:34:57+08:00">2021-06-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">统计学习方法</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/06/04/Statistical_Learning_Methods_Notes/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%84%9F%E7%9F%A5%E6%9C%BA/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/06/04/Statistical_Learning_Methods_Notes/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%84%9F%E7%9F%A5%E6%9C%BA/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>感知机（perceptron）</strong>是二类分类的线性分类模型，其输入为实例的特征向量，输出为实例的类别，取 $+1$ 和 $-1$ 二值。</p>
<p>感知机对应输入空间（特征空间）中将实例划分为正负两类的<strong>分离超平面（separating hyperplane）</strong>，属于判别模型。感知机学习旨在求出将训练数据进行线性划分的分离超平面。</p>
<p>导入基于误分类的损失函数，利用梯度下降法对损失函数进行极小化，求得感知机模型。</p>
<h1 id="2-1-感知机模型"><a href="#2-1-感知机模型" class="headerlink" title="2.1 感知机模型"></a>2.1 感知机模型</h1><p><strong>定义2.1（感知机）</strong>  假设输入空间（特征空间）是$\chi \subseteq R^n$,输出空间是$Y=\{+1, -1\}$。输入$x \in \chi$表示实例的特征向量，对应于输入空间（特征空间）的点；</p>
<p>输出$y \in Y$表示实例的类别。由输入空间到输出空间的如下函数：</p>
<script type="math/tex; mode=display">
f(x) = sign(\omega·x + b) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (2.1)</script><p>称为感知机。其中，$\omega$和$b$为感知机模型参数，$\omega \in R^n$叫作全职（weight）或权值向量（weight vector），$b \in R$叫作偏置（bias），$\omega·x$表示$\omega$和$x$的内积。$sign$是符号函数，即</p>
<script type="math/tex; mode=display">
sign(x) = \lbrace_{ -1,\ \ x < 0 }^{+1,\ \ x \geq 0}  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (2.2)</script><p>感知机模型的假设空间定义在特征空间中的所有<strong>线性分类模型（linear classification model）</strong>或<strong>线性分类器（linear classifier）</strong>，即函数集合：</p>
<script type="math/tex; mode=display">
\{f|f(x) = \omega·x + b\}</script><p>感知机由如下几何解释：线性方程</p>
<script type="math/tex; mode=display">
\omega·x + b = 0</script><p>对应于特征空间$R^n$中的一个超平面$S$,其中$\omega$是超平面的法向量，$b$是超平面的截距。</p>
<ul>
<li><p>感知机学习，由训练数据集（实力的特征向量及类别）求得感知机模型（2.1），即求得模型参数$\omega,b$。</p>
</li>
<li><p>感知机预测，通过学习得到的感知机模型，对于新的输入实例给出其对应的输出类别。</p>
</li>
</ul>
<h1 id="2-2-感知机学习策略"><a href="#2-2-感知机学习策略" class="headerlink" title="2.2 感知机学习策略"></a>2.2 感知机学习策略</h1><h2 id="2-2-1-数据集的线性可分性"><a href="#2-2-1-数据集的线性可分性" class="headerlink" title="2.2.1 数据集的线性可分性"></a>2.2.1 数据集的线性可分性</h2><p><strong>定义2.2（数据集的线性可分性）</strong>  给定一个数据集</p>
<script type="math/tex; mode=display">
T = \{(x_1,y_1),(x_2,y_2),...,(x_N,y_N)\}</script><p>其中，$x_i \in \chi = R^n, y \in Y = \{+1, -1\}, i=1,2,…,N$，如果存在某个超平面$S$</p>
<script type="math/tex; mode=display">
\omega·x + b = 0</script><p>能够将数据集的正实例点和负实例点完全正确地划分到超平面的两侧，即对所有$y_i=+1$的实例$i$，有$\omega·x + b &gt; 0$，对所有$y_i = -1$的实例$i$，有$\omega·x + b &lt; 0$，则称数据集$T$为线性可分数据集（linearly separable data set）；否则，称数据集$T$线性不可分。</p>
<h2 id="2-2-2-感知机学习策略"><a href="#2-2-2-感知机学习策略" class="headerlink" title="2.2.2 感知机学习策略"></a>2.2.2 感知机学习策略</h2><p>为了找出这样的超平面，即确定感知机模型参数$\omega,b$，需要确定一个学习策略，即定义（经验）损失函数并将损失函数极小化。</p>
<p>损失函数的选择是误分类点到超平面$S$的总距离，这是感知机所采用的。</p>
<ul>
<li>假设超平面$s$的误分类点集合为$M$，那么所有误分类点到超平面$S$的总距离为</li>
</ul>
<script type="math/tex; mode=display">
-\frac{1}{||\omega||}\sum\limits_{x_i \in M} y_i(\omega·x_i + b)</script><p>​        不考虑$\frac{1}{||\omega||}$，就得到感知机学习的损失函数。</p>
<ul>
<li>感知机$sign(\omega·x + b)$学习的损失函数定义为</li>
</ul>
<script type="math/tex; mode=display">
L(\omega,b) =-\sum\limits_{x_i \in M} y_i(\omega·x_i + b) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (2.4)</script><p>​        这个损失函数就是感知机学习的经验风险函数。</p>
<p>显然，损失函数$L(\omega,b)$是非负的。如果没有误分类点，损失函数值是$0$。而且，误分类点越少，误分类点离超平面越近，损失函数值就越小。</p>
<p>一个特定的样本点的损失函数：在误分类时是参数$\omega,b$的线性函数，在正确分类时是$0$。因此，给定训练数据集$T$，损失函数$L(\omega,b)$是$\omega,b$的连续可导函数。</p>
<p>感知机学习的策略是在假设空间中选取使损失函数（2.4）最小的模型参数$\omega,b$，即感知机模型。</p>
<h1 id="2-3-感知机学习算法"><a href="#2-3-感知机学习算法" class="headerlink" title="2.3 感知机学习算法"></a>2.3 感知机学习算法</h1><p>感知机学习算法是对以下最优化问题的算法。</p>
<script type="math/tex; mode=display">
\min\limits_{\omega,b} L(\omega,b) = - \sum\limits_{x_i \in M} y_i(\omega·x_i + b) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (2.5)</script><p>感知机学习算法是误分类驱动的，具体采用随机梯度下降法（stochastic gradient descent）。首先，任意选取一个超平面$\omega_0,b_0$，然后用梯度下降法不断地极小化目标函数(2.5)。极小化过程中不是一次使$M$中所有误分类点的梯度下降，而是一次随机选取一个误分类点使其梯度下降。</p>
<ul>
<li>假设误分类点集合$M$是固定的，那么损失函数$L(\omega,b)$的梯度由</li>
</ul>
<script type="math/tex; mode=display">
\bigtriangledown_{\omega}L(\omega,b) = - \sum\limits_{x_i \in M}y_i x_i</script><script type="math/tex; mode=display">
\bigtriangledown_{b}L(\omega,b) = - \sum\limits_{x_i \in M}y_i</script><p>​        给出。</p>
<ul>
<li><p>随机取一个误分类点$(x_i,y_i)$，对$\omega,b$进行更新：</p>
<script type="math/tex; mode=display">
\omega \longleftarrow \omega \ + \ \eta y_i x_i \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (2.6)</script><script type="math/tex; mode=display">
b \longleftarrow b\ + \ \eta y_i \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (2.7)</script></li>
</ul>
<p>式中$\eta(0&lt;\eta \le 1)$是步长，在统计学习中又称为学习率（learning rate）。这样，通过迭代可以期待损失函数$L(\omega,b)$不断减小，直到为$0$。</p>
<p><strong>算法 2.1（感知机学习算法的原始形式）</strong></p>
<p><strong>输入</strong>：训练数据集$T = \{(x_1,y_1),(x_2,y_2),…,(x_N,y_N)\}$，其中，$x_i \in \chi = R^n, y \in Y = \{+1, -1\}, i=1,2,…,N$；学习率$\eta(0&lt;\eta \le 1)$；</p>
<p><strong>输出</strong>：$\omega,b$；感知机模型$f(x)=sign(\omega·x + b)$。</p>
<p>​    （1）选取初值$\omega_0,b_0$；</p>
<p>​    （2）在训练集中选取数据$(x_i,y_i)$；</p>
<p>​    （3）如果$y_i(\omega·x_i + b) \leq 0$，</p>
<script type="math/tex; mode=display">
\omega \longleftarrow \omega \ + \ \eta y_i x_i  \\   b \longleftarrow b\ + \ \eta y_i</script><p>​    （4）转至（2），直至训练集中没有误分类点。</p>
<p>这种学习算法直观上有如下解释：当一个实例点被误分类，即位于分离超平面的错误一侧时，则调整$\omega,b$的值，使分离超平面向该误分类点的一侧移动，以减少该误分类点与超平面间的距离，直至超平面越过该误分类点使其被正确分类。</p>
<p>感知机学习算法由于采用不同的初值或选取不同的误分类点，解可以不同。</p>
<h2 id="2-3-2-算法的收敛性"><a href="#2-3-2-算法的收敛性" class="headerlink" title="2.3.2 算法的收敛性"></a>2.3.2 算法的收敛性</h2><p>为了便于叙述与推导，将偏置$b$并入权重向量$\omega$，记作$\hat\omega = (\omega^T,b)^T$，同样也将输入向量加以扩充，加进常数$1$，记作$\hat x=(x^T,1)^T$。这样，$\hat x \in R^{n+1},\hat\omega \in R^{n+1}$。显然，$\hat\omega·\hat x = \omega·x + b$。</p>
<p><strong>定理 2.1（Novikoff）</strong>  设训练数据集$T = \{(x_1,y_1),(x_2,y_2),…,(x_N,y_N)\}$，其中，$x_i \in \chi = R^n, y \in Y = \{+1, -1\}, i=1,2,…,N$，则</p>
<p>​    （1）存在满足条件$||\hat\omega_{opt}||=1$的超平面$\hat\omega_{opt}·\hat x =\omega_{opt}·x+b_{opt} = 0$将训练数据集完全正确分开；且存在$\gamma&gt;0$，对所有$i=1,2,…,N$</p>
<script type="math/tex; mode=display">
y_i(\hat\omega_{opt}·\hat x_i) = y_i(\omega_{opt}·x_i+b_{opt}) \geq \gamma \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (2.8)</script><p>​    （2）令$R=\max\limits_{1\leq i \leq N}||\hat x_i||$，则感知机算法2.1在训练数据集上的误分类次数$k$满足不等式</p>
<script type="math/tex; mode=display">
k \leq(\frac{R}{\gamma})^2) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (2.9)</script><p>定理表明，误分类的次数$k$是有上界的，经过有限次搜索可以找到将训练数据完全正确分开的分离超平面。也就是说，当训练数据集线性可分时，感知机学习算法原始形式迭代是收敛的。</p>
<p>感知机学习算法存在许多解，这些解既依赖与初值的选择，也依赖于迭代过程中误分类点的选择顺序。为了得到唯一的超平面，需要对分离超平面增加约束条件。</p>
<p>当训练集线性不可分时，感知机学习算法不收敛，迭代结果会放生震荡。</p>
<h2 id="2-3-3-感知机学习算法的对偶形式"><a href="#2-3-3-感知机学习算法的对偶形式" class="headerlink" title="2.3.3 感知机学习算法的对偶形式"></a>2.3.3 感知机学习算法的对偶形式</h2><p>对偶形式的基本想法是，将$\omega$和$b$表示为实例$x_i$和标记$y_i$的线性组合的形式，通过求解其系数而求得$\omega$和$b$。</p>
<p>在算法2.1中可假设初始值$\omega_0,b_0$均为0。对误分类点$(x_i,y_i)$通过</p>
<script type="math/tex; mode=display">
\omega \longleftarrow \omega \ + \ \eta y_i x_i  \\   b \longleftarrow b\ + \ \eta y_i</script><p>逐步修改$\omega,b$，设修改$n$次，则$\omega,b$关于$(x_i,y_i)$的增量分别是$\alpha_i y_i x_i$和$\alpha_i y_i$，这里$\alpha_i = n_i\eta$，$n_i$是点$(x_i,y_i)$被误分类的次数。最后学习到的$\omega,b$可以分别表示为</p>
<script type="math/tex; mode=display">
\omega = \sum\limits_{i=1}^N \alpha_i y_i x_i \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (2.14) \\ b = \sum\limits_{i=1}^N \alpha_i y_i \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (2.15)</script><p>这里，$\alpha_i \geq 0,i=1,2,…,N$，当$\eta = 1$时，表示第$i$个实例点由与误分而进行更新的次数。实例点更新次数越多，意味着它距离分离超平面越近，也就越难正确分类。换句话说，这样的实例对学习结果影响最大。</p>
<p><strong>算法 2.2（感知机学习算法的对偶形式）</strong></p>
<p><strong>输入</strong>：训练数据集$T = \{(x_1,y_1),(x_2,y_2),…,(x_N,y_N)\}$，其中，$x_i \in \chi = R^n, y \in Y = \{+1, -1\}, i=1,2,…,N$；学习率$\eta(0&lt;\eta \le 1)$；</p>
<p><strong>输出</strong>：$\alpha,b$；感知机模型$f(x)=sign(\sum\limits_{j=1}^N \alpha_j y_j x_j · x + b)$，其中$\alpha = (\alpha_1, \alpha_2,…,\alpha_N)^T$。</p>
<p>​    （1）$\alpha \longleftarrow 0, b \longleftarrow 0$；</p>
<p>​    （2）在训练集中选取数据$(x_i,y_i)$；</p>
<p>​    （3）如果$y_i(\sum\limits_{j=1}^N \alpha_j y_j x_j · x + b) \leq 0$，</p>
<script type="math/tex; mode=display">
\alpha_i \longleftarrow \alpha_i \ + \ \eta \\ b \longleftarrow b \ + \ \eta y_i</script><p>​    （4）转至（2）直到没有误分类数据。</p>
<p>对偶形式中训练实例仅以内积的形式出现。为了方便，可以预先将训练集中实例间的内积计算出来并以矩阵的形式存储，这个矩阵就是所谓的$Gram$矩阵（Gram matrix）</p>
<script type="math/tex; mode=display">
G = [x_i · x_j]_{N \times N}</script><p>与原始形式一样，感知机学习算法的对偶形式迭代是收敛的，存在多个解。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/04/Data%20_Competition/Python_Foundation/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%93%8D%E4%BD%9C%E5%88%97%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/04/Data%20_Competition/Python_Foundation/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%93%8D%E4%BD%9C%E5%88%97%E8%A1%A8/" class="post-title-link" itemprop="url">第四章 操作列表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-04 15:06:53" itemprop="dateCreated datePublished" datetime="2021-06-04T15:06:53+08:00">2021-06-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-02 21:52:34" itemprop="dateModified" datetime="2021-07-02T21:52:34+08:00">2021-07-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">数据竞赛</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/06/04/Data%20_Competition/Python_Foundation/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%93%8D%E4%BD%9C%E5%88%97%E8%A1%A8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/06/04/Data%20_Competition/Python_Foundation/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%93%8D%E4%BD%9C%E5%88%97%E8%A1%A8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="4-1-遍历整个列表"><a href="#4-1-遍历整个列表" class="headerlink" title="4.1 遍历整个列表"></a>4.1 遍历整个列表</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&quot;zhang&quot;</span>, <span class="string">&quot;li&quot;</span>, <span class="string">&quot;wang&quot;</span>, <span class="string">&quot;chen&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">	print(name)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zhang</span><br><span class="line">li</span><br><span class="line">wang</span><br><span class="line">chen</span><br></pre></td></tr></table></figure>
<h2 id="4-1-1-深入研究循环"><a href="#4-1-1-深入研究循环" class="headerlink" title="4.1.1 深入研究循环"></a>4.1.1 深入研究循环</h2><p>在编写for循环时，可以给依次与列表中每个值相关联的临时变量指定任意名称。选择描述单个列表元素的有意义名称大有脾益。这些命名约定有助于你明白for循环中将对每个元素执行的操作。使用单数和复数式的名称，可以帮助砍断代码段处理的是单个列表元素还是整个列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> cat <span class="keyword">in</span> cats:</span><br><span class="line"><span class="keyword">for</span> dog <span class="keyword">in</span> dogs:</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> list_of_items:</span><br></pre></td></tr></table></figure>
<h2 id="4-1-2-在for循环中执行更多操作"><a href="#4-1-2-在for循环中执行更多操作" class="headerlink" title="4.1.2 在for循环中执行更多操作"></a>4.1.2 在for循环中执行更多操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&quot;zhang&quot;</span>, <span class="string">&quot;li&quot;</span>, <span class="string">&quot;wang&quot;</span>, <span class="string">&quot;chen&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">	print(<span class="string">f&quot;my name is <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line">	print(<span class="string">&quot;nice to meet you!\n&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">my name is zhang</span><br><span class="line">nice to meet you!</span><br><span class="line"></span><br><span class="line">my name is li</span><br><span class="line">nice to meet you!</span><br><span class="line"></span><br><span class="line">my name is wang</span><br><span class="line">nice to meet you!</span><br><span class="line"></span><br><span class="line">my name is chen</span><br><span class="line">nice to meet you!</span><br></pre></td></tr></table></figure>
<p>每个缩进的代码都是循环的一部分，将针对列表中的每个值都执行一次。</p>
<h2 id="4-1-3-在for循环结束后执行一些操作"><a href="#4-1-3-在for循环结束后执行一些操作" class="headerlink" title="4.1.3 在for循环结束后执行一些操作"></a>4.1.3 在for循环结束后执行一些操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&quot;zhang&quot;</span>, <span class="string">&quot;li&quot;</span>, <span class="string">&quot;wang&quot;</span>, <span class="string">&quot;chen&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">	print(<span class="string">f&quot;my name is <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line">	print(<span class="string">&quot;nice to meet you!\n&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;thank you, everyone~~~&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">my name is zhang</span><br><span class="line">nice to meet you!</span><br><span class="line"></span><br><span class="line">my name is li</span><br><span class="line">nice to meet you!</span><br><span class="line"></span><br><span class="line">my name is wang</span><br><span class="line">nice to meet you!</span><br><span class="line"></span><br><span class="line">my name is chen</span><br><span class="line">nice to meet you!</span><br><span class="line"></span><br><span class="line">thank you, everyone~~~</span><br></pre></td></tr></table></figure>
<h1 id="4-2-避免缩进错误"><a href="#4-2-避免缩进错误" class="headerlink" title="4.2 避免缩进错误"></a>4.2 避免缩进错误</h1><p>Python根据缩进来判断代码行与前一个代码行的关系。Python通过使用缩进让代码更易读。简单地说，它要求你使用缩进让代码整洁而结构清晰。</p>
<h1 id="4-3-创建数值列表"><a href="#4-3-创建数值列表" class="headerlink" title="4.3 创建数值列表"></a>4.3 创建数值列表</h1><p>列表非常适合用于存储数字集合，而Python提供了很多工具，可帮助你高效地处理数字列表。</p>
<h2 id="4-3-1-使用函数range"><a href="#4-3-1-使用函数range" class="headerlink" title="4.3.1 使用函数range()"></a>4.3.1 使用函数range()</h2><p>Python函数<strong>range()</strong>让你能够轻松地生成你系列数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line">	print(number)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>函数range()让Python从指定的第一个值开始数，并在到达指定的第二个值时停止。因为它在第二个值处停止，所以输出不包含该值。</p>
<p>调用函数range()时，也可只指定一个参数，这样它将从0开始。例如，range(6)返回数0~5。</p>
<h2 id="4-3-2-使用range-创建数字列表"><a href="#4-3-2-使用range-创建数字列表" class="headerlink" title="4.3.2 使用range()创建数字列表"></a>4.3.2 使用range()创建数字列表</h2><p>要创建数字列表，可以使用函数list()将range()的结果直接转换为列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numbers = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>))</span><br><span class="line">print(numbers)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>
<p>使用函数range()时，还可指定步长。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">even_numbers = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">2</span>, <span class="number">11</span>, <span class="number">2</span>))</span><br><span class="line">print(even_numbers)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2, 4, 6, 8, 10]</span><br></pre></td></tr></table></figure>
<h2 id="4-3-3-对数字列表执行简单的统计计算"><a href="#4-3-3-对数字列表执行简单的统计计算" class="headerlink" title="4.3.3 对数字列表执行简单的统计计算"></a>4.3.3 对数字列表执行简单的统计计算</h2><p>有几个专门用于处理数字列表的Python函数。可以轻松地找出数字列表的最大值、最小值和总和：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">print(<span class="built_in">min</span>(numbers))</span><br><span class="line">print(<span class="built_in">max</span>(numbers))</span><br><span class="line">print(<span class="built_in">sum</span>(numbers))</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">8</span><br><span class="line">36</span><br></pre></td></tr></table></figure>
<h2 id="4-3-4-列表解析"><a href="#4-3-4-列表解析" class="headerlink" title="4.3.4 列表解析"></a>4.3.4 列表解析</h2><p><strong>列表解析</strong>将for循环和创建新元素的代码合并成一行，并自动附加新元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">squares = [number**<span class="number">2</span> <span class="keyword">for</span> number <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>)]</span><br><span class="line">print(squares)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br></pre></td></tr></table></figure>
<h1 id="4-4-使用列表的一部分"><a href="#4-4-使用列表的一部分" class="headerlink" title="4.4 使用列表的一部分"></a>4.4 使用列表的一部分</h1><p>处理列表的部分元素，Python称之为<strong>切片</strong></p>
<h2 id="4-4-1-切片"><a href="#4-4-1-切片" class="headerlink" title="4.4.1 切片"></a>4.4.1 切片</h2><p>要创建切片，可指定要使用的第一个元素和最后一个元素的索引。与函数range()一样，Python在到达第二个索引之前的元素后停止。要输出列表中的前三个元素，需要指定索引0和3，这将返回索引为0、1和2的元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">print(numbers[<span class="number">0</span>:<span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3]</span><br></pre></td></tr></table></figure>
<p>如果没有指定第一个索引，Python将自动从列表开头开始；要让切片终止于列表末尾，也可使用类似的语法。</p>
<p>负数索引返回离列表末尾相应距离的元素，因此可以输出列表末尾的任意切片。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">print(numbers[-<span class="number">3</span>：])</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[4, 5, 6]</span><br></pre></td></tr></table></figure>
<p>可在表示切片的方括号内指定第三值。这个值告诉Python在指定范围内每隔多少元素提取一个。</p>
<h2 id="4-4-2-遍历切片"><a href="#4-4-2-遍历切片" class="headerlink" title="4.4.2 遍历切片"></a>4.4.2 遍历切片</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> numbers[<span class="number">1</span>:<span class="number">5</span>]</span><br><span class="line">	print(number)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<h2 id="4-4-3-复制列表"><a href="#4-4-3-复制列表" class="headerlink" title="4.4.3 复制列表"></a>4.4.3 复制列表</h2><p>要复制列表，可创建一个包含整个列表的切片，方法是同时省略起始索引和终止索引（[:]）。这让Python创建一个始于第一个元素，终止于最后一个元素的切片，即整个列表的副本。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">print(numbers)</span><br><span class="line">copy_numbers = numbers[:]</span><br><span class="line">print(copy_numbers)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5, 6]</span><br><span class="line">[1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure>
<p>不能直接将整个列表赋给另一个变量，因为列表是引用类型，将导致两个名称都引用同一个列表，而不是将列表的副本赋给新的列表变量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">copy_numbers = numbers</span><br><span class="line">numbers.append(<span class="number">7</span>)</span><br><span class="line">print(numbers)</span><br><span class="line">print(copy_numbers)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5, 6, 7]</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7]# copy_numbers 与 numbers 表示同一个列表</span><br></pre></td></tr></table></figure>
<h1 id="4-5-元组"><a href="#4-5-元组" class="headerlink" title="4.5 元组"></a>4.5 元组</h1><p>Python将不能修改的值称为<strong>不可变的</strong>，而不可变的列表被称为<strong>元组</strong>。</p>
<h2 id="4-5-1-定义元组"><a href="#4-5-1-定义元组" class="headerlink" title="4.5.1 定义元组"></a>4.5.1 定义元组</h2><p>元组看起来很像列表，但使用圆括号而非中括号来标识。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dimensions = (<span class="number">200</span>, <span class="number">50</span>)</span><br><span class="line">print(dimensions[<span class="number">0</span>])</span><br><span class="line">print(dimensions[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">200</span><br><span class="line">50</span><br></pre></td></tr></table></figure>
<p>严格地说，元组是由逗号标识的，圆括号只是让元组看起来更整洁、更清晰。如果要定义只包含一个元素的元组，必须在这个元素后面加上逗号：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numbers = (<span class="number">8</span>,)</span><br></pre></td></tr></table></figure>
<p>创建只包含一个元素的元组通常没有意义，但自动生成的元组可能只有一个元素。</p>
<h2 id="4-5-2-遍历元组中的所有值"><a href="#4-5-2-遍历元组中的所有值" class="headerlink" title="4.5.2 遍历元组中的所有值"></a>4.5.2 遍历元组中的所有值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> numbers:</span><br><span class="line">	print(number)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h2 id="4-5-3-修改元组变量"><a href="#4-5-3-修改元组变量" class="headerlink" title="4.5.3 修改元组变量"></a>4.5.3 修改元组变量</h2><p>虽然不能修改元组的元素，但可以给存储元组的变量赋值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">numbers = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">print(numbers)</span><br><span class="line">	</span><br><span class="line">new_numbers = (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">numbers = new_numbers</span><br><span class="line">print(numbers)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(1, 2, 3)</span><br><span class="line">(4, 5, 6, 7)</span><br></pre></td></tr></table></figure>
<p>如果需要存储的一组值在程序的整个生命周期内都不变，就可以使用元组。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/04/Statistical_Learning_Methods_Notes/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E5%8F%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/04/Statistical_Learning_Methods_Notes/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E5%8F%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%AE%BA/" class="post-title-link" itemprop="url">第一章 统计学习及监督学习概论</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-06-04 10:30:55 / 修改时间：15:44:27" itemprop="dateCreated datePublished" datetime="2021-06-04T10:30:55+08:00">2021-06-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">统计学习方法</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/06/04/Statistical_Learning_Methods_Notes/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E5%8F%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%AE%BA/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/06/04/Statistical_Learning_Methods_Notes/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E5%8F%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%AE%BA/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-1-统计学习"><a href="#1-1-统计学习" class="headerlink" title="1.1 统计学习"></a>1.1 统计学习</h1><ol>
<li><strong>统计学习的特点</strong></li>
</ol>
<p>统计学习（statistical learning）是关于计算机基于数据构建概率统计模型并运用模型对数据进行预测与分析的一门学科。统计学习也称为统计机器学习（statistical machine learning）。</p>
<p>统计学习的主要特点是：</p>
<ul>
<li>统计学习以计算机及网络为平台，是建立在计算机及网络上的。</li>
<li>统计学习以数据为对象，是数据驱动的学科。</li>
<li>统计学习的目的是对数据进行预测与分析。</li>
<li>统计学习以方法为中心，统计学习方法构建模型并应用模型进行预测与分析</li>
<li>统计学习是概率论、统计学、信息论、计算理论、最优化理论及计算机科学等多个领域的交叉学科，并且在发展中逐步形成独自的理论体系与方法论。</li>
</ul>
<p>赫尔伯特·西蒙（Herbert A. Simon）对“学习”给出以下定义：“如果一个系统能够通过执行某个过程改进它的性能，这就是学习。”</p>
<ol>
<li><strong>统计学习的对象</strong></li>
</ol>
<p>统计学习研究的对象是数据（data）。它从数据出发，提取数据的特征，抽象出数据的模型，发现数据中的知识，又回到对数据的分析与预测中去。</p>
<p>统计学习关于数据的基本假设是同类数据具有一定的统计规律性，这是统计学习的前提。</p>
<p>在统计学习中，以变量或变量组表示数据。数据分为由连续变量和离散变量表示的类型。</p>
<ol>
<li><strong>统计学习的目的</strong></li>
</ol>
<p>统计学习总的目标就是考虑学习什么样的模型和如何学习模型，以使模型能对数据进行准确的预测和分析，同时也要考虑尽可能地提高学习效率。</p>
<ol>
<li><strong>统计学习的方法</strong></li>
</ol>
<p>统计学习由监督学习（supervised learning）、无监督学习（unsupervised learning）和强化学习（reinforcement learning）等组成。</p>
<p>统计学习方法可以概括如下：从给定的、有限的、用于学习的训练数据（training data）集合出发，假设数据是独立同分布产生的；并且假设要学习的模型属于某个函数的集合，称为假设空间（hypothesis space）；应用某个评价标准（evaluation criterion），从假设空间中选取一个最优模型，使它对已知的训练数据及未知的测试数据（test data）在给定的评价标准下有最优的预测；最优模型的选取由算法实现。</p>
<p>统计学习方法包括模型的假设空间、模型选择的评价标准以及模型学习的算法。称其为统计学习方法的三要素，简称为模型（model）、策略（strategy）和算法（algorithm）。</p>
<p>实现统计学习方法的步骤如下：</p>
<ul>
<li>得到一个有限的训练数据集合；</li>
<li>确定包含所有可能的模型的假设空间，即学习模型的集合；</li>
<li>确定模型选择的标准，即学习的策略；</li>
<li>实现求解最优模型的算法，即学习的算法；</li>
<li>通过学习方法选择最优模型；</li>
<li>利用学习的最优模型对新数据进行预测或分析。</li>
</ul>
<ol>
<li><strong>统计学习的研究</strong></li>
</ol>
<p>统计学习研究一般包括统计学习方法、统计学习理论及统计学习应用三个方面。</p>
<ol>
<li><strong>统计学习的重要性</strong></li>
</ol>
<p>统计学习学科在科学技术中的重要性主要体现在以下几个方面：</p>
<ul>
<li>统计学习是处理海量数据的有效方法。</li>
<li>统计学习是计算机智能化的有效手段。</li>
<li>统计学习是计算机科学发展的一个重要组成部分。</li>
</ul>
<h1 id="1-2-统计学习的分类"><a href="#1-2-统计学习的分类" class="headerlink" title="1.2 统计学习的分类"></a>1.2 统计学习的分类</h1><p>统计学习或机器学习是一个范围宽阔、内容繁多、应用广泛的领域，并不存在（至少现在不存在）一个统一的理论体系涵盖所有内容。从几个角度对统计学习方法进行分类。</p>
<h2 id="1-2-1-基本分类"><a href="#1-2-1-基本分类" class="headerlink" title="1.2.1 基本分类"></a>1.2.1 基本分类</h2><ol>
<li><strong>监督学习</strong></li>
</ol>
<p>监督学习（supervised learning）是指从标注数据中学习预测模型的机器学习问题。标注数据表示输入输出的对应关系，预测模型对给定的输入产生相应的输出。监督学习的本质是学习输入到输出的映射的统计规律。</p>
<ol>
<li><strong>无监督学习</strong></li>
</ol>
<p>无监督学习（unsupervised learning）是指从无标注数据中学习预测模型的机器学习问题。无标注数据是自然得到的数据，预测模型表示数据的类别、转换或概论。无监督学习的本质是学习数据中的统计规律或潜在结构。</p>
<ol>
<li><strong>强化学习</strong></li>
</ol>
<p>强化学习（reinforcement learning）是指智能系统在与环境的连续互动中学习最优行为策略的机器学习问题。强化学习的本质是学习最优的序贯决策。</p>
<p>在每一步t，只能系统从环境中观测到一个状态（state）$s_t$与一个奖励（reward）$r_t$，采取一个动作（action）$a_t$。环境根据智能系统选择的动作，决定下一步$t+1$的状态$s_{t+1}$与奖励$r_{t+1}$。要学习的策略表示为给定的状态下采取的动作。智能系统的目标不是短期奖励的最大化，而是长期积累奖励的最大化。强化学习过程中，系统不断地试错（trial and error），以达到学习最优策略的目的。</p>
<ol>
<li>半监督学习与主动学习</li>
</ol>
<p>半监督学习（semi-supervised learning）是指利用标注数据和未标注数据学习预测模型的机器学习问题。通常有少量标注数据、大量未标注数据。半监督学习旨在利用未标注数据中的信息，辅助标注数据，进行监督学习，以较低的成本达到较好的学习效果。</p>
<p>主动学习（active learning）是指机器不断主动给出实力让教师进行标注，然后利用标注数据学习预测模型的机器学习问题。通常的监督学习使用给定的标注数据，往往是随机得到的，可以看作是“被动学习”，主动学习的目标是找出对学习最有帮助的实力让教师标注，以较小的标注代价，达到较好的学习效果。</p>
<h2 id="1-2-2-按模型分类"><a href="#1-2-2-按模型分类" class="headerlink" title="1.2.2 按模型分类"></a>1.2.2 按模型分类</h2><ol>
<li><strong>概率模型与非概率模型</strong></li>
</ol>
<p>在监督学习中，概率模型取条件概率分布形式$P(y|x)$，非概率模型去函数形式$y=f(x)$，其中$x$是输入，$y$是输出。</p>
<p>在无监督学习中，概率模型取条件概率分布形式$P(z|x)$或$P(x|z)$，非概率模型取函数形式$z=g(x)$，其中$x$是输入，$y$是输出。</p>
<p>条件概率分布$P(y|x)$和函数$y=f(x)$可以相互转化（条件概率分布$p(z|x)$和函数$z=g(x)$同样可以）。条件概率分布最大化后得到函数，函数归一化后得到条件概率分布。</p>
<p>概率模型和非概率模型的区别不在于输入与输出之间的映射关系，而在于模型的内在结构。概率模型通常可以表示为联合概率分布的形式，其中的变量表示输入、输出、隐变量甚至参数。而非概率模型则不一定存在这样的联合概率分布。</p>
<ol>
<li><strong>线性模型与非线性模型</strong></li>
</ol>
<p>如果函数$y=f(x)$或$z=g(x)$是线性函数，则称模型是线性模型，否则称模型是非线性模型。</p>
<p>深度学习（deep learning）实际是复杂神经网络的学习，也就是复杂的非线性模型的学习。</p>
<ol>
<li><strong>参数化模型与非参数化模型</strong></li>
</ol>
<p>参数化模型假设模型参数的维度固定，模型可以由有限维参数完全刻画。</p>
<p>非参数化模型假定模型参数的维度不固定或者说无穷大，随着训练数据量的增加而不断增大。</p>
<h2 id="1-2-3-按算法分类"><a href="#1-2-3-按算法分类" class="headerlink" title="1.2.3 按算法分类"></a>1.2.3 按算法分类</h2><p>统计学习根据算法，可以分为在线学习（online learning）与批量学习（batch learning）。</p>
<ol>
<li><strong>在线学习</strong></li>
</ol>
<p>在线学习是指每次接受一个样本，进行预测，之后学习模型，并不断重复该操作的机器学习。</p>
<ol>
<li><strong>批量学习</strong></li>
</ol>
<p>批量学习一次接受所有数据，学习模型，之后进行预测。</p>
<h2 id="1-2-4-按技巧分类"><a href="#1-2-4-按技巧分类" class="headerlink" title="1.2.4 按技巧分类"></a>1.2.4 按技巧分类</h2><ol>
<li><strong>贝叶斯学习</strong></li>
</ol>
<p>贝叶斯学习（Bayesian learning），又称为贝叶斯推理（Bayesian inference），是统计学、机器学习中重要的方法。其主要想法是，在概率模型的学习和推理中，利用贝叶斯定理，计算在给定数据条件下模型的条件概率，即后验概率，并应用这个原理进行模型的估计，以及对数据的预测。将模型、为观测要素及其参数用变量表示，使用模型的先验分布是贝叶斯学习的特点。</p>
<p>模型估计时，估计整个后验概率分布$P(\theta|D)$。如果需要给出一个模型，通常取后验概率最大的模型。</p>
<p>假设先验分布是均匀分布，取后验概率最大，就能从贝叶斯估计得到极大似然估计。</p>
<script type="math/tex; mode=display">
极大似然估计： \hat \theta = arg\mathop{max}\limits_{\theta}P(D|\theta)</script><script type="math/tex; mode=display">
贝叶斯估计：\hat P(\theta|D) = \frac{P(\theta)P(D|\theta)}{P(D)}</script><ol>
<li><strong>核方法</strong></li>
</ol>
<p>核方法（kernel method）是使用核函数表示和学习非线性模型的一种机器学习方法，可以用于监督学习和无监督学习。有一些线性模型的学习方法基于相似度计算，更具体地，向量内积计算。核方法可以把它们扩展到非线性模型的学习，使其应用范围更广泛。</p>
<p>把线性模型扩展到非线性模型，直接的做法是显示地定义从输入空间（低维空间）到特征空间（高维空间）的映射，在特征空间中进行内积计算。</p>
<p>核方法的技巧在于不显示地定义这个映射，而是直接定义核函数，即映射之后在特征空间的内积。这样可以简化计算，达到同样的效果。</p>
<p>核方法直接在输入空间中定义核函数$K(x_1,x_2)$，使其满足$K(x_1,x_2)=&lt;\varphi(x_1),\varphi(x_2)&gt;$。</p>
<h1 id="1-3-统计学习方法三要素"><a href="#1-3-统计学习方法三要素" class="headerlink" title="1.3 统计学习方法三要素"></a>1.3 统计学习方法三要素</h1><p>统计学习方法都是由模型、策略、和算法构成的，即统计学习方法由三要素构成，可以简单地表示为：<strong>方法 = 模型 + 策略 + 算法</strong></p>
<h2 id="1-3-1-模型"><a href="#1-3-1-模型" class="headerlink" title="1.3.1 模型"></a>1.3.1 模型</h2><p>模型的假设空间（hypothesis space）包含所有可能的条件概率分布或决策函数。</p>
<p>假设空间用$F$表示。</p>
<ul>
<li>$F$通常是由一个参数向量决定的函数族：</li>
</ul>
<script type="math/tex; mode=display">
F = \{f|Y=f_\theta(X),\theta \in R^n\}</script><p>参数向量$\theta$取值于$n$维欧氏空间$R^n$，称为参数空间（parameter space）。</p>
<ul>
<li>$F$通常也是由一个参数决定的条件概率分布族：<script type="math/tex; mode=display">
F = \{P|P_{\theta}(Y|X),\theta \in R^n\}</script></li>
</ul>
<h2 id="1-3-2-策略"><a href="#1-3-2-策略" class="headerlink" title="1.3.2 策略"></a>1.3.2 策略</h2><p>有了模型的假设空间，统计学习接着需要考虑的是按照什么样的准则学习或选择最优的模型。</p>
<p>损失函数度量模型一次预测的好坏，风险函数度量平均意义下模型预测的好坏。</p>
<ol>
<li><strong>损失函数和风险函数</strong></li>
</ol>
<p>用一个<strong>损失函数（loss function）</strong>或<strong>代价函数（cost function）</strong>来度量预测错误的程度。</p>
<p>​    <strong>(1) 0-1损失函数（0-1 loss function）</strong></p>
<script type="math/tex; mode=display">
L(Y,f(x)) = \lbrace_{0,\ \ Y=f(x)}^{1,\ \ Y \ne f(x)}</script><p>​    <strong>(2)平方损失函数（quadratic loss function）</strong></p>
<script type="math/tex; mode=display">
L(Y,f(X)) = (Y-f(X))^2</script><p>​    <strong>(3)绝对损失函数（absolute loss function）</strong></p>
<script type="math/tex; mode=display">
L(Y,f(X)) = |Y - f(X)|</script><p>​    <strong>(4)对数损失函数（logarithmic loss function）</strong></p>
<script type="math/tex; mode=display">
L(Y,f(X)) = -logP(Y|X)</script><p>损失函数值越小，模型就越好。</p>
<p>损失函数的期望是</p>
<script type="math/tex; mode=display">
R_{exp}(f) = E_p[L(Y,f(X))] = \int_{X \times Y}L(y,f(x))P(x,y)dxdy</script><p>这是理论上模型$f(x)$关于联合分布$P(X,Y)$的平均意义下的损失函数，称为<strong>风险函数（risk function）</strong>或<strong>期望损失（expected loss）</strong>。</p>
<p>学习的目标就是选择期望风险最小的模型。</p>
<p>一方面根据期望风险最小学习模型要用到联合分布，另一方面联合分布又是未知的，所以监督学习就成为一个<strong>病态问题（ill-formed problem）</strong></p>
<p>模型$f(X)$关于训练数据集的平均损失称为<strong>经验风险（empirical risk）</strong>或<strong>经验损失（empirical loss）</strong>，记作$R_{emp}$：</p>
<script type="math/tex; mode=display">
R_{emp}(f) = \frac{1}{N} \sum\limits_{i=1}^N L(y_i,f(x_i))</script><p>期望风险$R_{exp}(f)$是模型关于联合分布的期望损失，经验风险$R_{emp}(f)$是模型关于训练样本集的平均损失。根据大数定律，当样本容量$N$趋于无穷时，经验风险$R_{emp}(f)$趋于期望风险$R_{exp}(f)$。</p>
<ol>
<li><strong>经验风险最小化与结构风险最小化</strong></li>
</ol>
<ul>
<li><strong>经验风险最小化（empirical risk minimization， ERM）</strong>的策略认为，经验风险最小的模型是最优的模型。根据这一策略，按照经验风险最小化求最优模型就是求解最优化问题：</li>
</ul>
<script type="math/tex; mode=display">
\mathop{min}_{f \in F} \frac{1}{N} \sum\limits_{i=1}^{N} L(y_i,f(x_i))</script><p>​        <strong>极大似然估计（maximum likelihood estimation）</strong>就是经验风险最小化的一个例子。当模型是条件概率分布、损失函数是对数损失函数时，经验风险最小化就等价于极大似然估计。</p>
<ul>
<li><strong>结构风险最小化（structural risk minimization，SRM）</strong>是为了防止过拟合而提出来的策略。结构风险最小化等价于正则化（regularization）。结构风险在经验风险上加上表示模型复杂度的正则化项（regularizer）或罚项（penalty term）。结构风险的定义是：<script type="math/tex; mode=display">
R_{srm}(f) = \frac{1}{N}\sum\limits_{i=1}^N L(y_i,f(x_i))\ + \ \lambda J(f)</script></li>
</ul>
<p>  其中$J(f)$为模型的复杂度，是定义在假设空间$F$上的泛函。模型$f$越复杂，复杂度$J(f)$就越大；反之，模型$f$越简单，复杂度$J(f)$就越小。复杂度表示了对复杂模型的惩罚。$\lambda\ge 0$是系数，用以权衡经验风险和模型复杂度。</p>
<p>  结构风险最小化的策略认为结构风险最小的模型是最优的模型。所以求最优模型，就是求解最优化问题：</p>
<script type="math/tex; mode=display">
  \mathop{min}_{f \in F} \frac{1}{N} \sum\limits_{i=1}^{N} L(y_i,f(x_i)) \ + \ \lambda J(f)</script><h2 id="1-3-3-算法"><a href="#1-3-3-算法" class="headerlink" title="1.3.3 算法"></a>1.3.3 算法</h2><p>算法是指学习模型的具体计算方法。统计学习基于训练数据集，根据学习策略，从假设空间中选择最优模型，最后需要考虑用什么样的计算方法求解最优模型。</p>
<p>统计学习问题归结为最优化问题，统计学习的算法成为求解最优化问题的算法。</p>
<p>统计学习方法之间的不同，主要来自其模型、策略、算法的不同。确定了模型、策略、算法，统计学习的方法也就确定了。</p>
<h1 id="1-4-模型评估与模型选择"><a href="#1-4-模型评估与模型选择" class="headerlink" title="1.4 模型评估与模型选择"></a>1.4 模型评估与模型选择</h1><h2 id="1-4-1-训练误差与测试误差"><a href="#1-4-1-训练误差与测试误差" class="headerlink" title="1.4.1 训练误差与测试误差"></a>1.4.1 训练误差与测试误差</h2><p>当损失函数给定时，基于损失函数的模型的<strong>训练误差（training error）</strong>和模型的<strong>测试误差（test error）</strong>就自然成为学习方法评估的标准。统计学习方法具体采用的损失函数未必是评估时使用的损失函数。当然，让两者一致是比较理想的。</p>
<p><strong>误差率（error rate，e）</strong>与<strong>准确率（accuracy，r）</strong>的关系为：</p>
<script type="math/tex; mode=display">
r + e = 1</script><p>将学习方法对未知数据的预测能力称为<strong>泛化能力（generalization ability）</strong>。</p>
<h2 id="1-4-2-过拟合与模型选择"><a href="#1-4-2-过拟合与模型选择" class="headerlink" title="1.4.2 过拟合与模型选择"></a>1.4.2 过拟合与模型选择</h2><p>当假设空间含有不同复杂度（例如，不同的参数个数）的模型时，就要面临<strong>模型选择（model selection）</strong>的问题。</p>
<p>如果在假设空间存在“真”模型，那么所选择的模型应该逼近真模型。具体地，所选择的模型要与真模型的参数个数相同，所选择的模型的参数向量与真模型的参数向量相近。</p>
<p>如果一味追求提高对训练数据的预测能力，所选模型的复杂度则往往会比真模型更高。这种现象称为<strong>过拟合（over-fitting）</strong>。</p>
<p>过拟合是指选择的模型所包含的参数过多，以致出现这一模型对已知数据预测得很好，但对未知数据预测得很差的现象。可以说模型选择旨在避免过拟合并提供高模型的预测能力。</p>
<p>设$M$次多项式为</p>
<script type="math/tex; mode=display">
f_M(x,w)=w_0 + w_1x + w_2x^2 + ... + w_Mx^M = \sum\limits_{j = 0} ^ M w_j x^j</script><p>式中$x$是单变量输入，$w_0,w_1,…,w_M$是$M+1$个参数。</p>
<p>首先确定模型的复杂度，即确定多项式的次数；然后在给定的模型复杂度下，按照经验风险最小化的策略，求解参数，即多项式的系数。具体地，求以下经验风险最小化：</p>
<script type="math/tex; mode=display">
L(w)=\frac{1}{2}\sum\limits_{i=1}^N (f(x_i,w) - y_i)^2</script><p>这是，损失函数为平方函数，系数$\frac{1}{2}$是为了计算方便。</p>
<p>模型选择时，不仅要考虑对已知数据的预测能力，而且还要考虑对未知数据的预测能力。</p>
<h1 id="1-5-正则化与交叉验证"><a href="#1-5-正则化与交叉验证" class="headerlink" title="1.5 正则化与交叉验证"></a>1.5 正则化与交叉验证</h1><h2 id="1-5-1-正则化"><a href="#1-5-1-正则化" class="headerlink" title="1.5.1 正则化"></a>1.5.1 正则化</h2><p>模型选择的典型方法时<strong>正则化（regularization）</strong>。正则化时结构风险最小化策略的实现，是在经验风险上加一个<strong>正则化项（regularizer）</strong>或<strong>罚项（penalty term）</strong>。正则化项一般是模型复杂度的单调递增函数，模型越复杂，正则化值就越大。</p>
<p>正则化一般具有如下形式：</p>
<script type="math/tex; mode=display">
\mathop{min}_{f \in F} \frac{1}{N} \sum\limits_{i=1}^{N} L(y_i,f(x_i)) \ + \ \lambda J(f)</script><p>正则化的作用是选择经验风险与模型复杂度同时较小的模型。</p>
<p>正则化符合<strong>奥卡姆剃刀（Occam`s razor）</strong>原理。奥卡姆剃刀原理应用于模型选择时变为以下想法：在所有可能选择的模型中，能够很好地解释已知数据并且十分简单才是最好的模型，也就是应该选择的模型。</p>
<h2 id="1-5-2-交叉验证"><a href="#1-5-2-交叉验证" class="headerlink" title="1.5.2 交叉验证"></a>1.5.2 交叉验证</h2><p>如果给定的样本数据充足，进行模型选择的一种简单方法是随机地将数据集切分成三部分，分别为<strong>训练集（training set）</strong>、<strong>验证集（validation set）</strong>和<strong>测试集（test set）</strong>。</p>
<p>训练集用来训练模型，验证集用于模型的选择，而测试集用于最终对学习方法的评估。</p>
<p>在学习到的不同复杂度的模型中，选择对验证集有最小预测误差的模型。由于验证集有足够多的数据，用它对模型进行选择也是有效的。</p>
<ol>
<li><strong>简单交叉验证</strong></li>
</ol>
<p>首先随即地将已给数据分为两部分，一部分作为训练集，另一部分作为测试集（例如，70%的数据为训练集，30%的数据为测试机）；然后用训练集在各种条件下（例如，不同的参数个数）训练模型，从而得到不同的模型；在测试集上评估各个模型的测试误差，选出测试误差最小的模型。</p>
<ol>
<li><strong>$S$折交叉验证</strong></li>
</ol>
<p>首先随机地将已给数据切分为$S$个互不相交、大小相同的子集；然后利用$S-1$个子集的数据训练模型，利用余下的子集测试模型；将这一过程对可能的$S$种选择重复进行；最后选出$S$次评测中平均测试误差最小的模型。</p>
<ol>
<li><strong>留一交叉验证</strong></li>
</ol>
<p>$S$折交叉验证的特殊情形是$S = N$，称为留一交叉验证（leave-one-out cross validation），往往在数据缺乏的情况下使用。</p>
<h1 id="1-6-泛化能力"><a href="#1-6-泛化能力" class="headerlink" title="1.6 泛化能力"></a>1.6 泛化能力</h1><h2 id="1-6-1-泛化误差"><a href="#1-6-1-泛化误差" class="headerlink" title="1.6.1 泛化误差"></a>1.6.1 泛化误差</h2><p>学习方法的<strong>泛化能力（generalization ability）</strong>是指该方法学习到的模型对未知数据的预测能力，是学习方法本质上重要的性质。</p>
<p>如果学到的模型是$\hat f$，那么用这个模型对未知数据预测的误差即为<strong>泛化误差（generalization error）</strong>：</p>
<script type="math/tex; mode=display">
R_{exp}(\hat f) = E_p[L(Y,\hat f(X))] = \int_{X \times Y}L(y,\hat f(x))P(x,y)dxdy</script><p>事实上，泛化误差就是所学习到的模型的期望风险。</p>
<h2 id="1-6-2-泛化误差上界"><a href="#1-6-2-泛化误差上界" class="headerlink" title="1.6.2 泛化误差上界"></a>1.6.2 泛化误差上界</h2><p>学习方法的泛化能力分析往往是通过研究泛化误差的概率上界进行的，简称为<strong>泛化误差上界（generalization error bound）</strong>。</p>
<p>具体来说，就是通过比较两种学习方法的泛化误差上界的大小来比较它们的优劣。</p>
<p>泛化误差上界通常具有以下性质：</p>
<ul>
<li>它是样本容量的函数，当样本容量增加时，泛化上界趋于0；</li>
<li>它是假设空间容量（capacity）的函数，假设空间容量越大，模型就越难学，泛化误差上界就越大。</li>
</ul>
<p><strong>定理1.1（泛化误差上界） 对二分类问题，当假设空间是有限个函数的集合$F=\{f_1,f_2,…,f_d\}$时，对任意一个函数$f \in F$，至少以概率$1-\delta,0&lt;\delta&lt;1$，以下不等式成立：</strong></p>
<script type="math/tex; mode=display">
R(f) \leq \hat R(f) + \epsilon(d,N,\delta)</script><p><strong>其中$R(f)$为期望风险，$\hat R(f)$为经验风险，$\epsilon(d,N,\delta)=\sqrt{\frac{1}{2N}(\log d + \log \frac{1}{\delta})}$</strong></p>
<p>左端$R(f)$是泛化误差，右端即为泛化误差上界。在泛化误差上界中，第1项是训练误差，训练误差越小，泛化误差也越小。第2项$\epsilon(d,N,\delta)$是$N$的单调递减函数，当$N$趋于无穷时趋于0；同时它也是$\sqrt{\log d}$阶的函数，假设空间$F$包含的函数越多，其值越大。</p>
<h1 id="1-7-生成模型与判别模型"><a href="#1-7-生成模型与判别模型" class="headerlink" title="1.7 生成模型与判别模型"></a>1.7 生成模型与判别模型</h1><p>监督学习方法又可以分为<strong>生成方法（generative approach）</strong>和<strong>判别方法（discriminative approach）</strong>。所学到的模型分别称为<strong>生成模型（generative model）</strong>和<strong>判别模型（discriminative model）</strong>。</p>
<ul>
<li>生成方法原理上由数据学习联合概率分布$P(X,Y)$，然后求出条件概率分布$P(Y|X)$作为预测的模型，即生成模型：</li>
</ul>
<script type="math/tex; mode=display">
P(Y|X) = \frac{P(X,Y)}{P(X)}</script><p>​        这样的方法之所以称为生成方法，是因为模型表示了给定输入$X$产生输出$Y$的生成关系。</p>
<ul>
<li>判别方法由数据直接学习决策函数$f(X)$或者条件概率分布$P(Y|X)$作为预测的模型，即判别模型。判别方法关心的是对给定的输入$X$，应该预测什么样的输出$Y$。</li>
</ul>
<p>生成方法的特点：生成方法可以还原出联合概率分布$P(X,Y)$，而判别方法则不能；生成方法的学习收敛速度更快，即当样本容量增加的时候，学到的模型可以更快地收敛于真实模型；当存在隐变量时，仍可以用生成方法学习，此时判别方法就不能用。</p>
<p>判别方法的特点：判别方法直接学习的时条件概率$P(Y|X)$或决策函数$f(X)$，直接面对预测，往往学习的准确率更高；由于直接学习$P(Y|X)$或$f(X)$，可以对数据进行各种程度上的抽象、定义特征并使用特征，因此可以简化学习问题。</p>
<h1 id="1-8-监督学习应用"><a href="#1-8-监督学习应用" class="headerlink" title="1.8 监督学习应用"></a>1.8 监督学习应用</h1><h2 id="1-8-1-分类问题"><a href="#1-8-1-分类问题" class="headerlink" title="1.8.1 分类问题"></a>1.8.1 分类问题</h2><p>监督学习从数据中学习一个分类模型或分类决策函数，称为<strong>分类器（classifier）</strong>。分类器对新的输入进行输出的预测，称为<strong>分类（classification）</strong>。可能的输出称为<strong>类（class）</strong>。</p>
<p>评价分类器性能的指标一般是<strong>分类准确率（accuracy）</strong>，其定义是：对于给定的测试数据集，分类器正确分类的样本数与总样本数之比。也就是损失函数是0-1损失时测试数据集上的准确率。</p>
<p>对于二分类问题常用的评价指标是<strong>精确率（precision）</strong>和<strong>召回率（recall）</strong>。</p>
<p>4种情况出现的总数分别记作：</p>
<ul>
<li>$TP$   ——————将正类预测为正类数；</li>
<li><p>$FN$  ——————将正类预测为负类数；</p>
</li>
<li><p>$FP$  ——————将负类预测为正类数；</p>
</li>
<li>$TN$  ——————将负类预测为负类数；</li>
</ul>
<p>精确率定义为：</p>
<script type="math/tex; mode=display">
P = \frac{TP}{TP+FP}</script><p>召回率定义为：</p>
<script type="math/tex; mode=display">
R = \frac{TP}{TP+FN}</script><p>此外，还有$F_1$值，是精确率和召回率的调和均值，即</p>
<script type="math/tex; mode=display">
\frac{2}{F_1} = \frac{1}{P} + \frac{1}{R}</script><script type="math/tex; mode=display">
F_1 = \frac{2TP}{2TP + FP + FN}</script><h2 id="1-8-2-标注问题"><a href="#1-8-2-标注问题" class="headerlink" title="1.8.2 标注问题"></a>1.8.2 标注问题</h2><p><strong>标注（tagging）</strong>也是一个监督学习问题。</p>
<p>评价标准模型的指标与评价分类模型的指标一样，常用的有标注准确率、精确率和召回率。</p>
<p>标注常用的统计学习方法有：隐马尔可夫模型、条件随机场。</p>
<p>自然语言处理中的<strong>词性标注（part of speech tagging）</strong>就是一个典型的标注问题：给定一个由单词组成的句子，对这个句子中的每一个单词进行词性标注，即对每一个单词序列预测其对应的词性标记序列。</p>
<h2 id="1-8-3-回归问题"><a href="#1-8-3-回归问题" class="headerlink" title="1.8.3 回归问题"></a>1.8.3 回归问题</h2><p>回归用于预测输入变量（自变量）和输出变量（因变量）之间的关系，特别是当输入变量的值发生变化时，输出变量的值随之发生的变化。</p>
<p>回归模型正是表示从输入变量到输出变量之间映射的函数。回归问题的学习等价于函数拟合：选择一条函数曲线使其很好地拟合已知数据且很好地预测未知数据。</p>
<p>回归问题按照输入变量的个数，分为一元回归和多元回归；按照输入变量和输出变量之间关系的类型即模型的类型，分为线性回归和非线性回归。</p>
<p>回归学习常用的损失函数是平方损失函数，在此情况下，回归问题可以由著名的<strong>最小二乘法（least squares）</strong>求解。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/03/Data%20_Competition/Python_Foundation/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%97%E8%A1%A8%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/03/Data%20_Competition/Python_Foundation/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%97%E8%A1%A8%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">第三章 列表简介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-03 15:09:45" itemprop="dateCreated datePublished" datetime="2021-06-03T15:09:45+08:00">2021-06-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-02 21:52:40" itemprop="dateModified" datetime="2021-07-02T21:52:40+08:00">2021-07-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">数据竞赛</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/06/03/Data%20_Competition/Python_Foundation/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%97%E8%A1%A8%E7%AE%80%E4%BB%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/06/03/Data%20_Competition/Python_Foundation/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%97%E8%A1%A8%E7%AE%80%E4%BB%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="3-1-列表是什么"><a href="#3-1-列表是什么" class="headerlink" title="3.1 列表是什么"></a>3.1 列表是什么</h1><p><strong>列表</strong>由一系列按特定顺序排列的元素组成。你可以创建包含字母表中所有字母、数字0~9或所有家庭成员姓名的列表；也可以将任何东西加入列表中，其中的元素之间可以没有任何关系。列表通常包含多个元素，因此给列表指定一个表示复数的名称（如letters、digits 或 names）是个不错的主意。</p>
<p>在Python中，用方括号 <strong>[ ]</strong> 表示列表，并用逗号分隔其中的元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;lisi&#x27;</span>, <span class="string">&#x27;wangermazi&#x27;</span>]</span><br><span class="line">print(names)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#39;zhangsan&#39;, &#39;lisi&#39;, &#39;wangermazi&#39;]</span><br></pre></td></tr></table></figure>
<h2 id="3-1-1-访问列表元素"><a href="#3-1-1-访问列表元素" class="headerlink" title="3.1.1 访问列表元素"></a>3.1.1 访问列表元素</h2><p>要访问列表元素，可指出列表的名称，再指出元素的索引，并将后者放在方括号内。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;lisi&#x27;</span>, <span class="string">&#x27;wangermazi&#x27;</span>]</span><br><span class="line">print(names[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zhangsan</span><br></pre></td></tr></table></figure>
<h2 id="3-1-2-索引从0而不是1开始"><a href="#3-1-2-索引从0而不是1开始" class="headerlink" title="3.1.2 索引从0而不是1开始"></a>3.1.2 索引从0而不是1开始</h2><p>在Python中，第一个列表元素的索引为0，而不是1。</p>
<p>Python为访问最后一个列表元素提供了一种特殊语法。通过将索引指定为-1，可让Python返回最后一个列表元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;lisi&#x27;</span>, <span class="string">&#x27;wangermazi&#x27;</span>]</span><br><span class="line">print(names[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wangermazi</span><br></pre></td></tr></table></figure>
<p>这种约定也适用于其他负数索引。例如，索引-2返回倒数第二个列表元素，索引-3返回倒数第三个列表元素，依此类推。</p>
<h1 id="3-2-修改、添加和删除元素"><a href="#3-2-修改、添加和删除元素" class="headerlink" title="3.2 修改、添加和删除元素"></a>3.2 修改、添加和删除元素</h1><p>创建的大多数列表将是动态的，这意味着列表创建后，将随着程序的运行增删元素。</p>
<h2 id="3-2-1-修改列表元素"><a href="#3-2-1-修改列表元素" class="headerlink" title="3.2.1 修改列表元素"></a>3.2.1 修改列表元素</h2><p>要修改列表元素，可指定列表名和要修改的元素索引，再指定该元素的新值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;lisi&#x27;</span>, <span class="string">&#x27;wangermazi&#x27;</span>]</span><br><span class="line">print(names)</span><br><span class="line"></span><br><span class="line">names[<span class="number">2</span>] = <span class="string">&#x27;normal people&#x27;</span></span><br><span class="line">print(names)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#39;zhangsan&#39;, &#39;lisi&#39;, &#39;wangermazi&#39;]</span><br><span class="line">[&#39;zhangsan&#39;, &#39;lisi&#39;, &#39;normal people&#39;]</span><br></pre></td></tr></table></figure>
<h2 id="3-2-1-在列表中添加元素"><a href="#3-2-1-在列表中添加元素" class="headerlink" title="3.2.1 在列表中添加元素"></a>3.2.1 在列表中添加元素</h2><ol>
<li>在列表末尾添加元素</li>
</ol>
<p>在列表中添加新元素时，最简单的方式是将元素<strong>附加（append）</strong>到列表。给列表附加元素时它将添加到列表末尾。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;lisi&#x27;</span>, <span class="string">&#x27;wangermazi&#x27;</span>]</span><br><span class="line">print(names)</span><br><span class="line"></span><br><span class="line">names.append(<span class="string">&#x27;normal people&#x27;</span>)</span><br><span class="line">print(names)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#39;zhangsan&#39;, &#39;lisi&#39;, &#39;wangermazi&#39;]</span><br><span class="line">[&#39;zhangsan&#39;, &#39;lisi&#39;, &#39;wangermazi&#39;, &#39;normal people&#39;]</span><br></pre></td></tr></table></figure>
<ol>
<li>在列表中插入元素</li>
</ol>
<p>使用方法 <strong>insert()</strong> 可在列表的任何位置添加新元素。为此，需要指定新元素的索引和值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;lisi&#x27;</span>, <span class="string">&#x27;wangermazi&#x27;</span>]</span><br><span class="line">print(names)</span><br><span class="line"></span><br><span class="line">names.insert(<span class="number">1</span>, <span class="string">&#x27;normal people&#x27;</span>)</span><br><span class="line">print(names)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#39;zhangsan&#39;, &#39;lisi&#39;, &#39;wangermazi&#39;]</span><br><span class="line">[&#39;zhangsan&#39;, &#39;normal people&#39;, &#39;lisi&#39;, &#39;wangermazi&#39;]</span><br></pre></td></tr></table></figure>
<p>这种操作将列表中插入位置开始到列表末尾的每一个元素都右移一个位置。</p>
<h2 id="3-2-3-从列表中删除元素"><a href="#3-2-3-从列表中删除元素" class="headerlink" title="3.2.3 从列表中删除元素"></a>3.2.3 从列表中删除元素</h2><p>可以根据位置或值来删除列表中的元素。</p>
<ol>
<li><strong>使用del语句删除元素</strong></li>
</ol>
<p>如果知道要删除的元素在列表中的位置，可使用 <strong>del</strong> 语句。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;normal people&#x27;</span>, <span class="string">&#x27;lisi&#x27;</span>, <span class="string">&#x27;wangermazi&#x27;</span>]</span><br><span class="line">print(names)</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> names[<span class="number">1</span>]</span><br><span class="line">print(names)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#39;zhangsan&#39;, &#39;normal people&#39;, &#39;lisi&#39;, &#39;wangermazi&#39;]</span><br><span class="line">[&#39;zhangsan&#39;, &#39;lisi&#39;, &#39;wangermazi&#39;]</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>使用方法pop()删除元素</strong></li>
</ol>
<p>方法 <strong>pop()</strong> 删除列表末尾的元素，并让你能够接着使用它。术语<strong>弹出(pop)</strong>源自这样的类比:列表就像一个栈，而删除列表末尾的元素相当于弹出栈顶元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;lisi&#x27;</span>, <span class="string">&#x27;wangermazi&#x27;</span>, <span class="string">&#x27;normal people&#x27;</span>]</span><br><span class="line">print(names)</span><br><span class="line"></span><br><span class="line">popped_name = names.pop()</span><br><span class="line">print(popped_name)</span><br><span class="line">print(names)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&#39;zhangsan&#39;, &#39;lisi&#39;, &#39;wangermazi&#39;, &#39;normal people&#39;]</span><br><span class="line">normal people</span><br><span class="line">[&#39;zhangsan&#39;, &#39;lisi&#39;, &#39;wangermazi&#39;]</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>弹出列表中任何位置处的元素</strong></li>
</ol>
<p>可以使用pop()来删除列表中任意位置的元素，只需在圆括号中指定要删除元素的索引即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;normal people&#x27;</span>, <span class="string">&#x27;lisi&#x27;</span>, <span class="string">&#x27;wangermazi&#x27;</span>]</span><br><span class="line">print(names)</span><br><span class="line"></span><br><span class="line">popped_name = names.pop(<span class="number">1</span>)</span><br><span class="line">print(popped_name)</span><br><span class="line">print(names)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&#39;zhangsan&#39;, &#39;normal people&#39;, &#39;lisi&#39;, &#39;wangermazi&#39;]</span><br><span class="line">normal people</span><br><span class="line">[&#39;zhangsan&#39;, &#39;lisi&#39;, &#39;wangermazi&#39;]</span><br></pre></td></tr></table></figure>
<p>如果不确定该使用del语句还是pop()方法，下面是一个简单的判断标准：如果要从列表中删除一个元素，且不再以任何方式使用它，就使用del语句；如果要在删除后还能继续使用它，就使用方法pop()。</p>
<ol>
<li><strong>根据值删除元素</strong></li>
</ol>
<p>如果只知道要删除的元素的值，可使用方法 <strong>remove()</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;normal people&#x27;</span>, <span class="string">&#x27;lisi&#x27;</span>, <span class="string">&#x27;wangermazi&#x27;</span>]</span><br><span class="line">print(names)</span><br><span class="line"></span><br><span class="line">names.remove(<span class="string">&#x27;normal people&#x27;</span>)</span><br><span class="line">print(names)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#39;zhangsan&#39;, &#39;normal people&#39;, &#39;lisi&#39;, &#39;wangermazi&#39;]</span><br><span class="line"> [&#39;zhangsan&#39;, &#39;lisi&#39;, &#39;wangermazi&#39;]</span><br></pre></td></tr></table></figure>
<p>方法remove()只删除第一个指定的值。如果要删除的值可能在列表中出现多次，就需要使用循环来确保将每个值都删除。</p>
<h1 id="3-3-组织列表"><a href="#3-3-组织列表" class="headerlink" title="3.3 组织列表"></a>3.3 组织列表</h1><h2 id="3-3-1-使用方法sort-对列表永久排序"><a href="#3-3-1-使用方法sort-对列表永久排序" class="headerlink" title="3.3.1 使用方法sort()对列表永久排序"></a>3.3.1 使用方法sort()对列表永久排序</h2><p>方法 <strong>sort()</strong> 永久性地修改列表元素的排列顺序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;normal people&#x27;</span>, <span class="string">&#x27;lisi&#x27;</span>, <span class="string">&#x27;wangermazi&#x27;</span>]</span><br><span class="line">print(names)</span><br><span class="line"></span><br><span class="line">names.sort()</span><br><span class="line">print(names)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#39;zhangsan&#39;, &#39;normal people&#39;, &#39;lisi&#39;, &#39;wangermazi&#39;]</span><br><span class="line">[&#39;normal people&#39;, &#39;lisi&#39;, &#39;wangermazi&#39;, &#39;zhangsan&#39;]</span><br></pre></td></tr></table></figure>
<p>还可以按语字母顺序相反的顺序排列列表元素，只需向sort()方法传递参数 reverse = True 即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;normal people&#x27;</span>, <span class="string">&#x27;lisi&#x27;</span>, <span class="string">&#x27;wangermazi&#x27;</span>]</span><br><span class="line">print(names)</span><br><span class="line"></span><br><span class="line">names.sort(reverse = <span class="literal">True</span>)</span><br><span class="line">print(names)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#39;zhangsan&#39;, &#39;normal people&#39;, &#39;lisi&#39;, &#39;wangermazi&#39;]</span><br><span class="line">[&#39;zhangsan&#39;, &#39;wangermazi&#39;, &#39;lisi&#39;, &#39;normal people&#39;]</span><br></pre></td></tr></table></figure>
<h2 id="3-3-2-使用函数sorted-对列表临时排序"><a href="#3-3-2-使用函数sorted-对列表临时排序" class="headerlink" title="3.3.2 使用函数sorted()对列表临时排序"></a>3.3.2 使用函数sorted()对列表临时排序</h2><p>要保留列表元素原来的排序顺序，同时以特定的顺序呈现它们，可使用函数 <strong>sorted()</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;normal people&#x27;</span>, <span class="string">&#x27;lisi&#x27;</span>, <span class="string">&#x27;wangermazi&#x27;</span>]</span><br><span class="line">print(names)</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">sorted</span>(names))</span><br><span class="line"></span><br><span class="line">print(names)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&#39;zhangsan&#39;, &#39;normal people&#39;, &#39;lisi&#39;, &#39;wangermazi&#39;] #排序前</span><br><span class="line">[&#39;normal people&#39;, &#39;lisi&#39;, &#39;wangermazi&#39;, &#39;zhangsan&#39;] #排序输出结果</span><br><span class="line">[&#39;zhangsan&#39;, &#39;normal people&#39;, &#39;lisi&#39;, &#39;wangermazi&#39;] #排序后，与排序前一致</span><br></pre></td></tr></table></figure>
<p>如果要按与字母顺序相反的顺序显示列表，也可向函数sorted()传递参数 reverse = True。</p>
<h2 id="3-3-3-倒着打印列表"><a href="#3-3-3-倒着打印列表" class="headerlink" title="3.3.3 倒着打印列表"></a>3.3.3 倒着打印列表</h2><p>要反转列表元素的排列顺序，可使用方法 <strong>reverse()</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;normal people&#x27;</span>, <span class="string">&#x27;lisi&#x27;</span>, <span class="string">&#x27;wangermazi&#x27;</span>]</span><br><span class="line">print(names)</span><br><span class="line"></span><br><span class="line">names.reveres()</span><br><span class="line">print(names)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#39;zhangsan&#39;, &#39;normal people&#39;, &#39;lisi&#39;, &#39;wangermazi&#39;]</span><br><span class="line">[&#39;wangermazi&#39;, &#39;lisi&#39;, &#39;normal people&#39;, &#39;zhangsan&#39;]</span><br></pre></td></tr></table></figure>
<h2 id="3-3-4-确定列表的长度"><a href="#3-3-4-确定列表的长度" class="headerlink" title="3.3.4 确定列表的长度"></a>3.3.4 确定列表的长度</h2><p>使用函数 <strong>len()</strong> 可快速获悉列表的长度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;normal people&#x27;</span>, <span class="string">&#x27;lisi&#x27;</span>, <span class="string">&#x27;wangermazi&#x27;</span>]</span><br><span class="line">names_length = <span class="built_in">len</span>(names)</span><br><span class="line">print(names_length)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/03/Data%20_Competition/Python_Foundation/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/03/Data%20_Competition/Python_Foundation/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">第二章 变量和简单数据类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-03 15:07:57" itemprop="dateCreated datePublished" datetime="2021-06-03T15:07:57+08:00">2021-06-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-02 21:53:01" itemprop="dateModified" datetime="2021-07-02T21:53:01+08:00">2021-07-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">数据竞赛</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/06/03/Data%20_Competition/Python_Foundation/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/06/03/Data%20_Competition/Python_Foundation/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="2-1-Hello-Python-World！"><a href="#2-1-Hello-Python-World！" class="headerlink" title="2.1 Hello Python World！"></a>2.1 Hello Python World！</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;Hello Python World!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>运行上述代码时，你将看到如下输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello Python World!</span><br></pre></td></tr></table></figure>
<p>编写程序时，编辑器会以各种方式突出程序的不同部分。这种功能称为语法高亮。</p>
<h1 id="2-2-变量"><a href="#2-2-变量" class="headerlink" title="2.2 变量"></a>2.2 变量</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">message = <span class="string">&quot;Hello Python World!&quot;</span></span><br><span class="line">print(message)</span><br></pre></td></tr></table></figure>
<p>运行这个程序，输出与以前相同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello Python World!</span><br></pre></td></tr></table></figure>
<p>我们添加量一个名为message 的<strong>变量</strong>。每个变量都指向一个<strong>值</strong>——与该变量相关联的信息。</p>
<h2 id="2-2-1-变量的命名和使用"><a href="#2-2-1-变量的命名和使用" class="headerlink" title="2.2.1 变量的命名和使用"></a>2.2.1 变量的命名和使用</h2><ul>
<li>变量名只能包含字母、数字和下划线。变量名能以字母或下划线打头，但不能以数字打头。</li>
<li>变量名不能包含空格，但能使用下划线来分隔其中的单词。</li>
<li>不要将Python关键字和函数名作为变量名，即不要使用Python保留用于特殊用途的单词。</li>
<li>变量名应该既简短又具有描述性。</li>
<li>慎用小写字母l和大写字母O，因为它们可能被人看错成数字1和0。</li>
</ul>
<h2 id="2-2-2-使用变量时避免命名错误"><a href="#2-2-2-使用变量时避免命名错误" class="headerlink" title="2.2.2 使用变量时避免命名错误"></a>2.2.2 使用变量时避免命名错误</h2><ul>
<li>名称错误通常意味着两种情况：要么是使用变量前忘记给它赋值，要么是输入变量名时拼写不正确。</li>
</ul>
<h2 id="2-2-3-变量是标签"><a href="#2-2-3-变量是标签" class="headerlink" title="2.2.3 变量是标签"></a>2.2.3 变量是标签</h2><ul>
<li>变量是可以赋给值的标签，也可以说变量指向特定的值。</li>
</ul>
<h1 id="2-3-字符串"><a href="#2-3-字符串" class="headerlink" title="2.3 字符串"></a>2.3 字符串</h1><p>字符串就是一系列字符。在Python中，用引号括起的都是字符串，其中的引号可以是单引号，也可以是双引号。如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;This is a string.&quot;</span></span><br><span class="line"><span class="string">&#x27;This is also a string&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-3-1-使用方法修改字符串的大小写"><a href="#2-3-1-使用方法修改字符串的大小写" class="headerlink" title="2.3.1 使用方法修改字符串的大小写"></a>2.3.1 使用方法修改字符串的大小写</h2><ul>
<li>方法title()以首字母大写的方式显示每个单词，即将每个单词的首字母都改写为大写。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;normal people&quot;</span></span><br><span class="line">print(name.title())</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Normal People</span><br></pre></td></tr></table></figure>
<ul>
<li>方法<strong>upper()</strong>将字符串改为全部大写。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;Normal People&quot;</span></span><br><span class="line">print(name.upper())</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NORMAL PEOPLE</span><br></pre></td></tr></table></figure>
<ul>
<li>方法<strong>lower()</strong>将字符串改为全部小写。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name &#x3D; &quot;Normal People&quot;</span><br><span class="line">print(name.lower())</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">normal people</span><br></pre></td></tr></table></figure>
<h2 id="2-3-2-在字符串中使用变量"><a href="#2-3-2-在字符串中使用变量" class="headerlink" title="2.3.2 在字符串中使用变量"></a>2.3.2 在字符串中使用变量</h2><ul>
<li>要在字符串中插入变量的值，可在前引号前加上字母f，再将要插入的变量放在花括号内。这样，当Python显示字符串时，将把每个变量都替换为其值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">first_name = <span class="string">&quot;normal&quot;</span></span><br><span class="line">last_name = <span class="string">&quot;people&quot;</span></span><br><span class="line">full_name = <span class="string">f&quot;<span class="subst">&#123;first_name&#125;</span> <span class="subst">&#123;last_name&#125;</span>&quot;</span></span><br><span class="line">print(full_name)</span><br></pre></td></tr></table></figure>
<p>这种字符串名为<strong>f字符串</strong>。f是format（设置格式）的简写，因为Python通过把花括号内的变量替换为其值来设置字符串的格式。</p>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">normal people</span><br></pre></td></tr></table></figure>
<h2 id="2-3-3-使用制表符或换行符来添加空白"><a href="#2-3-3-使用制表符或换行符来添加空白" class="headerlink" title="2.3.3 使用制表符或换行符来添加空白"></a>2.3.3 使用制表符或换行符来添加空白</h2><ul>
<li>要在字符串中添加制表符，可使用字符组合<strong>\t</strong>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;Python&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;\tPython&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Python</span><br><span class="line">	Python</span><br></pre></td></tr></table></figure>
<ul>
<li>要在字符串中添加换行符，可使用字符组合<strong>\n</strong>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;Languages:\nPython\nC\nJava&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Languages:</span><br><span class="line">Python</span><br><span class="line">C</span><br><span class="line">Java</span><br></pre></td></tr></table></figure>
<h2 id="2-3-4-删除空白"><a href="#2-3-4-删除空白" class="headerlink" title="2.3.4 删除空白"></a>2.3.4 删除空白</h2><ul>
<li>删除字符串开头的空白<strong>lstrip()</strong>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;  normal people  &quot;</span></span><br><span class="line">print(name.lstrip())</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;normal people  &#39;</span><br></pre></td></tr></table></figure>
<ul>
<li>删除字符串末尾的空白<strong>rstrip()</strong>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;  normal people  &quot;</span></span><br><span class="line">print(name.rstrip())</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;  normal people&#39;</span><br></pre></td></tr></table></figure>
<ul>
<li>删除字符串两端的空白strip()：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;  normal people  &quot;</span></span><br><span class="line">print(name.rstrip())</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;normal people&#39;</span><br></pre></td></tr></table></figure>
<h1 id="2-4-数"><a href="#2-4-数" class="headerlink" title="2.4 数"></a>2.4 数</h1><p>在编程中，经常使用数来记录得分、表示可视化数据、存储Web应用信息，等等。</p>
<h2 id="2-4-1-整数"><a href="#2-4-1-整数" class="headerlink" title="2.4.1 整数"></a>2.4.1 整数</h2><ul>
<li>在Python中，可对整数执行加(+)减(-)乘(*)除(/)运算。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="number">2</span> + <span class="number">3</span>)</span><br><span class="line">print(<span class="number">3</span> - <span class="number">2</span>)</span><br><span class="line">print(<span class="number">2</span> * <span class="number">3</span>)</span><br><span class="line">print(<span class="number">3</span> / <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1</span><br><span class="line">6</span><br><span class="line">1.5</span><br></pre></td></tr></table></figure>
<p>进行除法运算时，分母不能为0</p>
<p>其他语言中如Java中，两个整数相除结果还是整数。如：3 / 2 = 1， 4 / 5 = 0</p>
<ul>
<li>Python使用两个乘号(**)表示乘方运算：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="number">3</span>**<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure>
<ul>
<li>Python还支持运算次序，因此可在同一个表达式中使用多种运算。还可以使用圆括号来修改运算次序，让Python按你指定的次序执行运算：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="number">2</span> + <span class="number">3</span> * <span class="number">4</span>)</span><br><span class="line">print((<span class="number">2</span> + <span class="number">3</span>) * <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">14 </span><br><span class="line">20</span><br></pre></td></tr></table></figure>
<p>在这些示例中，空格不影响Python计算表达式的方式。</p>
<h2 id="2-4-2-浮点数"><a href="#2-4-2-浮点数" class="headerlink" title="2.4.2 浮点数"></a>2.4.2 浮点数</h2><p>Python将所有带小数点的数称为<strong>浮点数</strong>。它指出了这样一个事实：小数点可以出现在数的任何位置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="number">0.1</span> + <span class="number">0.1</span>)</span><br><span class="line">print(<span class="number">2</span> * <span class="number">0.1</span>)</span><br><span class="line">print(<span class="number">0.2</span> + <span class="number">0.1</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0.2</span><br><span class="line">0.2</span><br><span class="line">0.30000000000000004</span><br></pre></td></tr></table></figure>
<p>但需要注意的是，结果包含的小数位数可能是不确定的。如第三个输出结果</p>
<h2 id="2-4-3-整数和浮点数"><a href="#2-4-3-整数和浮点数" class="headerlink" title="2.4.3 整数和浮点数"></a>2.4.3 整数和浮点数</h2><ul>
<li>将任意两个数相除时，结果总是浮点数，即便这两个数都是整数且能整除：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="number">4</span> / <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.0</span><br></pre></td></tr></table></figure>
<ul>
<li>在其他任何运算中，如果一个操作数是整数，另一个操作数是浮点数，结果也总是浮点数：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="number">1</span> + <span class="number">2.0</span>)</span><br><span class="line">print(<span class="number">2</span> * <span class="number">3.0</span>)</span><br><span class="line">print(<span class="number">3.0</span> ** <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3.0</span><br><span class="line">6.0</span><br><span class="line">9.0</span><br></pre></td></tr></table></figure>
<p>无论是哪种运算，只要有操作数是浮点数，Python默认得到的总是浮点数，即便结果原本为整数也是如此。</p>
<h2 id="2-4-4-数中的下划线"><a href="#2-4-4-数中的下划线" class="headerlink" title="2.4.4 数中的下划线"></a>2.4.4 数中的下划线</h2><p>书写很大的数时，可使用下划线将其中的数字分组，使其更清晰易读：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="number">14_000_000_000</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">14000000000</span><br></pre></td></tr></table></figure>
<h2 id="2-4-5-同时给多个变量赋值"><a href="#2-4-5-同时给多个变量赋值" class="headerlink" title="2.4.5 同时给多个变量赋值"></a>2.4.5 同时给多个变量赋值</h2><p>可在一行代码中给多个变量赋值，这有助于缩短程序并提高其可读性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x, y, z = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">print(<span class="string">f&quot;x = <span class="subst">&#123;x&#125;</span>, y = <span class="subst">&#123;y&#125;</span>, z = <span class="subst">&#123;z&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; 1， y &#x3D; 2, z &#x3D; 3</span><br></pre></td></tr></table></figure>
<h2 id="2-4-6-常量"><a href="#2-4-6-常量" class="headerlink" title="2.4.6 常量"></a>2.4.6 常量</h2><p><strong>常量</strong>类似于变量，但其值在程序的整个生命周期内保持不变。Python没有内置的常量类型，但Python程序员会使用全大写来指出应将某个变量视为常量，其值始终不变：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAX_CONNECTIONS = <span class="number">5000</span></span><br></pre></td></tr></table></figure>
<h1 id="2-5-注释"><a href="#2-5-注释" class="headerlink" title="2.5 注释"></a>2.5 注释</h1><p><strong>注释</strong>让你能够使用自然语言在程序中添加说明。</p>
<ul>
<li>在Python中，当行注释用井号(#)标识。井号后面的内容都会被Python解释器忽略：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我的第一个Python程序</span></span><br><span class="line">print(<span class="string">&quot;Hello Python World!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello Python World!</span><br></pre></td></tr></table></figure>
<ul>
<li>在Python中，多行注释用三对单引号(‘’’ ‘’’)或双引号(“”” “””)标识。引号内的内容都会被Python解释器忽略：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">我的第一个Python程序 </span></span><br><span class="line"><span class="string">你好 Python！</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">print(<span class="string">&quot;Hello Python World!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello Python World!</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">我的第一个Python程序 </span><br><span class="line">你好 Python！</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">print(&quot;Hello Python World!&quot;)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello Python World!</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/03/Data%20_Competition/Python_Foundation/%E7%AC%AC%E4%B8%80%E7%AB%A0-python%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/03/Data%20_Competition/Python_Foundation/%E7%AC%AC%E4%B8%80%E7%AB%A0-python%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">第一章 python编程环境搭建</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-03 15:02:10" itemprop="dateCreated datePublished" datetime="2021-06-03T15:02:10+08:00">2021-06-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-02 21:52:16" itemprop="dateModified" datetime="2021-07-02T21:52:16+08:00">2021-07-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">数据竞赛</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/06/03/Data%20_Competition/Python_Foundation/%E7%AC%AC%E4%B8%80%E7%AB%A0-python%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/06/03/Data%20_Competition/Python_Foundation/%E7%AC%AC%E4%B8%80%E7%AB%A0-python%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=" "></a> </h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/11/Machine_Learning_Notes/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/11/Machine_Learning_Notes/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">第3章 线性模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-11 15:43:01" itemprop="dateCreated datePublished" datetime="2021-05-11T15:43:01+08:00">2021-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-08 14:43:41" itemprop="dateModified" datetime="2021-06-08T14:43:41+08:00">2021-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/05/11/Machine_Learning_Notes/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/05/11/Machine_Learning_Notes/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="3-1-基本形式"><a href="#3-1-基本形式" class="headerlink" title="3.1 基本形式"></a>3.1 基本形式</h1><ul>
<li>给定由$d$个属性描述的示例$x=(x_1;x_2;…;x_d)$，其中$x_i$是$x$在第$i$个属性上的取值，线性模型(linear model)试图学得一个通过属性的线性组合来进行预测的函数，即<script type="math/tex">f(x)=w_1x_1+w_2x_2+...+w_dx_d+b</script>，一般用向量形式写成<script type="math/tex">f(x)=w^Tx+b</script>，其中$w=(w_1;w_2;…;w_d)$。$w$和$b$学得之后，模型就得以确定。</li>
<li>由于$w$直观表达了各属性在预测中的重要性，因此线性模型有很好的可解释性(comprehensibility)。亦称“可理解性“(understandability)。</li>
</ul>
<h1 id="3-2-线性回归"><a href="#3-2-线性回归" class="headerlink" title="3.2 线性回归"></a>3.2 线性回归</h1><ul>
<li>”线性回归“（linear regression）试图学得一个线性模型以尽可能准确地预测实际值输出标记。</li>
<li>对离散属性，若属性值间存在“序”（order）关系，可通过连续化将其转化为连续值，例如二值属性“身高”的取值“高”，“矮”可转化为{1.0,0.0}。若属性值间不存在序关系，假定有$k$个属性值，则通常转化为$k$维向量。例如属性“瓜类”的取值“西瓜”，“南瓜”，“黄瓜”可转化为（0,0,1），（0,1,0），（1,0,0）。</li>
<li>线性回归试图学得$f(x_i)=wx_i+b$，使得$f(x_i) \simeq y_i$，如何确定$w$和$b$呢？显然，关键在于如何衡量$f(x)$与$y$之间的差别。均方误差是回归任务中最常用的性能度量，因此我们可以试图让均方误差最小化，即<script type="math/tex">(w^*,b^*)=\underset{(w,b)}{arg \,min}\sum\limits_{i=1}^m(f(x_i)-y_i)^2</script>=$\underset{(w,b)}{arg \,min}\sum\limits_{i=1}^m(y_i-wx_i-b)^2$。</li>
<li>均方误差有非常好的几何意义，他对应了常用的欧几里得距离或简称“欧式距离”（Euclidean distance）。基于均方误差最小化来进行模型求解的方法称为“最小二乘法”（least square method）。在线性回归中，最小二乘法就是试图找到一条直线，使所有样本到直线上的欧氏距离之和最小。</li>
<li>求解$w$和$b$使$E_{(w,b)}=\sum_{i=1}^m(y_i-wx_i-b)^2$最小化的过程，称为线性回归模型的最小二乘“参数估计”（parameter estimation）。这里$E_{(w,b)}$是关于$w$和$b$的凸函数，当它关于$w$和$b$的倒数均为零时，得到$w$和$b$的最优解。</li>
<li>跟一般的情形是如本节开头的数据集$D$，样本由$d$个属性描述。这称为“多元线性回归”(multivariate linear regression)。亦称“多变量线性回归。</li>
<li>假设我们认为示例所对应的输出标记是在指数尺度上变化，那就可将输出标记的对数作为线性模型逼近的目标，即<script type="math/tex">lny=w^Tx+b</script>。这就是“对数线性回归”（log-linear regression），它实际上是在试图让$e^{w^Tx+b}$逼近$y$。这里的对数函数起到了将线性回归模型的预测值与真实标记联系起来的作用。</li>
<li>跟一般地，考虑单调可微函数$g(·)$，令<script type="math/tex">y=g^{-1}(w^Tx+b)</script>，这样得到的模型称为“广义线性模型”（generalized linear model），其中函数$g(·)$称为“联系函数”（link function）。</li>
</ul>
<h1 id="3-3-对数几率回归"><a href="#3-3-对数几率回归" class="headerlink" title="3.3 对数几率回归"></a>3.3 对数几率回归</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/07/Blog_Tool/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%AF%B9%E7%85%A7%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/07/Blog_Tool/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%AF%B9%E7%85%A7%E8%A1%A8/" class="post-title-link" itemprop="url">Latex数学公式对照表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-07 11:26:37" itemprop="dateCreated datePublished" datetime="2021-05-07T11:26:37+08:00">2021-05-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-04 09:47:25" itemprop="dateModified" datetime="2021-06-04T09:47:25+08:00">2021-06-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/blog%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">blog工具</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/05/07/Blog_Tool/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%AF%B9%E7%85%A7%E8%A1%A8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/05/07/Blog_Tool/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%AF%B9%E7%85%A7%E8%A1%A8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2FLaTeX">LaTeX</a>是一种基于<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2FTeX">TeX</a>的文档排版系统,把大片排版的格式细节隐藏在若干样式之后，以内容的逻辑结构统帅纷繁的格式，遂成为现在最流行的科技写作——尤其是数学写作的工具之一。在Markdown中插入数学公式的语法是 <script type="math/tex">数学公式</script> 和 $$$数学公式$$$。</p>
<h2 id="行内公式"><a href="#行内公式" class="headerlink" title="行内公式"></a>行内公式</h2><p>行内公式是可以让公式在文中与文字或其他东西混编，不独占一行.在数学模式下,符号会使用单独的字体,字母通常是倾斜的意大利体,数字和符号则是直立体.而且,数学符号之间的距离也与一般的水平模式不同:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>示例</th>
<th>显示</th>
</tr>
</thead>
<tbody>
<tr>
<td><script type="math/tex">2x+3y=34</script></td>
<td><img src="https://math.jianshu.com/math?formula=2x%2B3y%3D34" alt="2x+3y=34"></td>
</tr>
<tr>
<td><code>2x+3y=34</code></td>
<td>2x+3y=34</td>
</tr>
</tbody>
</table>
</div>
<p>因此,在排版数学公式时,即使没有特殊符号的算式如1+1=2,或者简单的一个字母变量<img src="https://math.jianshu.com/math?formula=x" alt="x">,也要进入数学模式,使用<script type="math/tex">1+1=2</script>,<script type="math/tex">x</script>,而不是使用排版普通文字的方式</p>
<h2 id="独立公式"><a href="#独立公式" class="headerlink" title="独立公式"></a>独立公式</h2><p>独立公式单独占一行,不和其他文字混编<br>示例: $$c=2πr$$<br>显示:<script type="math/tex">c=2πr</script></p>
<h2 id="多方公式"><a href="#多方公式" class="headerlink" title="多方公式"></a>多方公式</h2><p>在独立公式中使用\\\\来换行</p>
<p>示例:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$$</span>   </span><br><span class="line">2x+3y=<span class="number">34</span>\\   </span><br><span class="line">x+4y=<span class="number">25</span>  </span><br><span class="line"><span class="variable">$$</span></span><br></pre></td></tr></table></figure>
<p>显示:<script type="math/tex">2x+3y=34\\
x+4y=25</script></p>
<h2 id="常用符号"><a href="#常用符号" class="headerlink" title="常用符号"></a>常用符号</h2><div class="table-container">
<table>
<thead>
<tr>
<th>符号</th>
<th>示例</th>
<th>显示</th>
</tr>
</thead>
<tbody>
<tr>
<td>上下标</td>
<td>S=a_{1}^2+a_{2}^2+a_{3}^2</td>
<td><img src="https://math.jianshu.com/math?formula=S%3Da_%7B1%7D%5E2%2Ba_%7B2%7D%5E2%2Ba_%7B3%7D%5E2" alt="S=a_{1}^2+a_{2}^2+a_{3}^2"></td>
</tr>
<tr>
<td>括号</td>
<td>f(x, y) = 100 <em> \lbrace[(x + y) </em> 3] - 5\rbrace</td>
<td><img src="https://math.jianshu.com/math?formula=f(x%2C%20y" alt="f(x, y) = 100 * \lbrace[(x + y) * 3] - 5\rbrace">%20%3D%20100%20<em>%20%5Clbrace%5B(x%20%2B%20y)%20</em>%203%5D%20-%205%5Crbrace)</td>
</tr>
<tr>
<td>分数</td>
<td>\frac{1}{3} 与 \cfrac{1}{3}</td>
<td>$\frac{1}{3} 与 \cfrac{1}{3}$</td>
</tr>
<tr>
<td>开方</td>
<td>\sqrt[3]{X}和\sqrt{5 - x}</td>
<td>$\sqrt[3]{X}$<code>和</code>$\sqrt{5 - x}$</td>
</tr>
</tbody>
</table>
</div>
<h2 id="其他字符"><a href="#其他字符" class="headerlink" title="其他字符"></a>其他字符</h2><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td>\pm</td>
<td>$\pm$</td>
</tr>
<tr>
<td>\times</td>
<td>$\times$</td>
</tr>
<tr>
<td>\div</td>
<td>$\div$</td>
</tr>
<tr>
<td>\mid</td>
<td>$\mid$</td>
</tr>
<tr>
<td>\nmid</td>
<td>$\nmid$</td>
</tr>
<tr>
<td>\cdot</td>
<td>$\cdot$</td>
</tr>
<tr>
<td>\circ</td>
<td>$\circ$</td>
</tr>
<tr>
<td>\ast</td>
<td>$\ast$</td>
</tr>
<tr>
<td>\bigodot</td>
<td>$\bigodot$</td>
</tr>
<tr>
<td>\bigotimes</td>
<td>$\bigotimes$</td>
</tr>
<tr>
<td>\bigoplus</td>
<td>$\bigoplus$</td>
</tr>
<tr>
<td>\leq</td>
<td>$\leq$</td>
</tr>
<tr>
<td>\geq</td>
<td>$\geq$</td>
</tr>
<tr>
<td>\neq</td>
<td>$\neq$</td>
</tr>
<tr>
<td>\approx</td>
<td>$\approx$</td>
</tr>
<tr>
<td>\equiv</td>
<td>$\equiv$</td>
</tr>
<tr>
<td>\sum</td>
<td>$\sum$</td>
</tr>
<tr>
<td>\prod</td>
<td>$\prod$</td>
</tr>
</tbody>
</table>
</div>
<h3 id="对数运算符"><a href="#对数运算符" class="headerlink" title="对数运算符"></a>对数运算符</h3><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td>\log</td>
<td>$\log$</td>
</tr>
<tr>
<td>\lg</td>
<td>$\lg$</td>
</tr>
<tr>
<td>\ln</td>
<td>$\ln$</td>
</tr>
</tbody>
</table>
</div>
<h3 id="三角运算符"><a href="#三角运算符" class="headerlink" title="三角运算符"></a>三角运算符</h3><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td>\bot</td>
<td>$\bot$</td>
</tr>
<tr>
<td>\angle</td>
<td>$\angle$</td>
</tr>
<tr>
<td>\sin</td>
<td>$\sin$</td>
</tr>
<tr>
<td>\cos</td>
<td>$\cos$</td>
</tr>
<tr>
<td>\tan</td>
<td>$\tan$</td>
</tr>
<tr>
<td>\cot</td>
<td>$\cot$</td>
</tr>
<tr>
<td>\sec</td>
<td>$\sec$</td>
</tr>
<tr>
<td>\csc</td>
<td>$\csc$</td>
</tr>
</tbody>
</table>
</div>
<h3 id="微积分运算符"><a href="#微积分运算符" class="headerlink" title="微积分运算符"></a>微积分运算符</h3><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td>\prime</td>
<td>$\prime$</td>
</tr>
<tr>
<td>\int</td>
<td>$\int$</td>
</tr>
<tr>
<td>\iint</td>
<td>$\iint$</td>
</tr>
<tr>
<td>\iiint</td>
<td>$\iiint$</td>
</tr>
<tr>
<td>\oint</td>
<td>$\oint$</td>
</tr>
<tr>
<td>\lim</td>
<td>$\lim$</td>
</tr>
<tr>
<td>\infty</td>
<td>$\infty$</td>
</tr>
<tr>
<td>\nabla</td>
<td>$\nabla$</td>
</tr>
<tr>
<td>\mathrm{d}</td>
<td>$\mathrm{d}$</td>
</tr>
</tbody>
</table>
</div>
<h3 id="集合运算符"><a href="#集合运算符" class="headerlink" title="集合运算符"></a>集合运算符</h3><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td>\emptyset</td>
<td>$\emptyset$</td>
</tr>
<tr>
<td>\in</td>
<td>$\in$</td>
</tr>
<tr>
<td>\notin</td>
<td>$\notin$</td>
</tr>
<tr>
<td>\subset</td>
<td>$\subset$</td>
</tr>
<tr>
<td>\subseteq</td>
<td>$\subseteq$</td>
</tr>
<tr>
<td>\supseteq</td>
<td>$\supseteq$</td>
</tr>
<tr>
<td>\bigcap</td>
<td>$\bigcap$</td>
</tr>
<tr>
<td>\bigcup</td>
<td>$\bigcup$</td>
</tr>
<tr>
<td>\bigvee</td>
<td>$\bigvee$</td>
</tr>
<tr>
<td>\bigwedge</td>
<td>$\bigwedge$</td>
</tr>
<tr>
<td>\biguplus</td>
<td>$\biguplus$</td>
</tr>
<tr>
<td>\bigsqcup</td>
<td>$\bigsqcup$</td>
</tr>
</tbody>
</table>
</div>
<h3 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h3><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>大写</th>
<th>代码</th>
<th>小写</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>$A$</td>
<td>\alpha</td>
<td>$ \alpha$</td>
</tr>
<tr>
<td>B</td>
<td>$B$</td>
<td>\beta</td>
<td>$\beta$</td>
</tr>
<tr>
<td>\Gamma</td>
<td>$\Gamma$</td>
<td>\gamma</td>
<td>$\gamma$</td>
</tr>
<tr>
<td>\Delta</td>
<td>$\Delta$</td>
<td>\delta</td>
<td>$\delta$</td>
</tr>
<tr>
<td>E</td>
<td>$E$</td>
<td>\epsilon</td>
<td>$\epsilon$</td>
</tr>
<tr>
<td>Z</td>
<td>$Z$</td>
<td>\zeta</td>
<td>$\zeta$</td>
</tr>
<tr>
<td>H</td>
<td>$H$</td>
<td>\eta</td>
<td>$\eta$</td>
</tr>
<tr>
<td>\Theta</td>
<td>$\Theta$</td>
<td>\theta</td>
<td>$\theta$</td>
</tr>
<tr>
<td>I</td>
<td>$I$</td>
<td>\iota</td>
<td>$\iota$</td>
</tr>
<tr>
<td>K</td>
<td>$K$</td>
<td>\kappa</td>
<td>$\kappa$</td>
</tr>
<tr>
<td>Lambda</td>
<td>$\Lambda$</td>
<td>\lambda</td>
<td>$ \lambda$</td>
</tr>
<tr>
<td>M</td>
<td>$M$</td>
<td>\mu</td>
<td>$\mu$</td>
</tr>
<tr>
<td>N</td>
<td>$N$</td>
<td>\nu</td>
<td>$\nu$</td>
</tr>
<tr>
<td>Xi</td>
<td>$Xi$</td>
<td>\xi</td>
<td>$\xi$</td>
</tr>
<tr>
<td>O</td>
<td>$O$</td>
<td>\omicron</td>
<td>$\omicron$</td>
</tr>
<tr>
<td>\Pi</td>
<td>$\Pi$</td>
<td>\pi</td>
<td>$ \pi$</td>
</tr>
<tr>
<td>P</td>
<td>$P$</td>
<td>\rho</td>
<td>$ \rho$</td>
</tr>
<tr>
<td>\Sigma</td>
<td>$\Sigma$</td>
<td>\sigma</td>
<td>$\sigma$</td>
</tr>
<tr>
<td>T</td>
<td>$T$</td>
<td>\tau</td>
<td>$ \tau$</td>
</tr>
<tr>
<td>\Upsilon</td>
<td>$\Upsilon$</td>
<td>\upsilon</td>
<td>$ \upsilon$</td>
</tr>
<tr>
<td>\Phi</td>
<td>$\Phi$</td>
<td>\phi</td>
<td>$\phi$</td>
</tr>
<tr>
<td>X</td>
<td>$X$</td>
<td>\chi</td>
<td>$\chi$</td>
</tr>
<tr>
<td>\Psi</td>
<td>$\Psi$</td>
<td>\psi</td>
<td>$\psi$</td>
</tr>
<tr>
<td>\Omega</td>
<td>$\Omega$</td>
<td>\omega</td>
<td>$ \omega$</td>
</tr>
</tbody>
</table>
</div>
<p>原文链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e6d2368e451a">https://www.jianshu.com/p/e6d2368e451a</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/04/Machine_Learning_Notes/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/04/Machine_Learning_Notes/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/" class="post-title-link" itemprop="url">第二章 模型评估与选择</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-04 22:11:20" itemprop="dateCreated datePublished" datetime="2021-05-04T22:11:20+08:00">2021-05-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-08 14:45:29" itemprop="dateModified" datetime="2021-06-08T14:45:29+08:00">2021-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/05/04/Machine_Learning_Notes/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/05/04/Machine_Learning_Notes/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="2-1-经验误差与过拟合"><a href="#2-1-经验误差与过拟合" class="headerlink" title="2.1 经验误差与过拟合"></a>2.1 经验误差与过拟合</h1><ul>
<li><p>通常我们把分类错误为的样本数占样本总数的比例称为“错误率”（error  rate），即如果在m个样本中有a个样本分类错误，则错误率$E = a/m$;</p>
</li>
<li><p>相应的，$1 - a/m$称为“精度”（accuracy ），即：精度 = 1 - 错误率“。</p>
</li>
<li><p>更一般地，我们把学习器的实际预测输出与样本的真实输出之间的差异称为“误差”（error），学习器在训练集上的误差称为“训练误差”（training error）或“经验误差 ”（empirical error），在新样本上的误差称为“泛化误差”（generalization error）。</p>
</li>
<li><p>当学习器把训练样本学得“太好 ”了的时候 ，很可能已经把训练样本自身的一些特点当做了所有潜在 样本都会具有的一般性质，这样就会导致泛化性能下降 。这种现象在机器学习中称为 “过拟合”（overfiting）。与“过拟合 ”相对的是“欠拟合”（underfiting），这是指对训练样本的一般性质尚未学好。</p>
</li>
<li><p>过拟合亦称“过配”，欠拟合亦称“欠配”。</p>
</li>
<li><p>有多种因素可能导致过拟合，其中最常见的情况是由于学习能力过于强大，以至于把训练样本所包含的不太一般的特性都学到了，而欠拟合则通常是由于学习能力低下而造成的。</p>
</li>
<li><p>欠拟合比较容易克服，例如在决策树学习中扩展分支，在神经网络学习中增加训练轮数等，而过拟合是无法彻底避免的，我们所能做的只是“缓解”，或者说减小其风险。</p>
</li>
<li><p>机器学习面临的问题通常是NP难甚至更难，而有效的学习算法必然是在多项式时间内运行完成，若可彻底避免过拟合，则通过经验误差最小化就能获最优解，这就意味着我们构造性地证明了“$P = NP$；因此，只要相信”$P \ne NP$“，过拟合就不可避免。</p>
<p><strong>P类问题</strong>：在多项式时间内可解的问题。</p>
<p><strong>NP类问题</strong>：在多项式时间内“可验证”的问题。即不能判定这个问题到底有没有解，而是猜出一个解来在多项式时间内证明这个解是否正确。</p>
</li>
</ul>
<h1 id="2-2-评估方法"><a href="#2-2-评估方法" class="headerlink" title="2.2 评估方法"></a>2.2 评估方法</h1><ul>
<li><p>通常，我们可以通过实验测试来对学习器的泛化误差进行评估并进而做出选择。为此，需使用一个“测试集”（testing set）来测试学习器对新样本的判别能力，然后以测试集上的“测试误差”（testing error）作为泛化误差的近似。</p>
</li>
<li><p>可是，我们只有一个包含$m$个样例的数据集$D = \{(x_1,y_1),(x_2,y_2),…,(x_m,y_m)\}$，既要训练，又要测试，怎样才能做到呢？答案是：通过对$D$进行适当的处理，从中产生出训练集$S$和测试集$T$。</p>
<h2 id="2-2-1-留出法"><a href="#2-2-1-留出法" class="headerlink" title="2.2.1 留出法"></a>2.2.1 留出法</h2><ul>
<li><p>“留出法”（hold-out）直接将数据集$D$划分为两个互斥的集合，其中一个集合作为训练集$S$,另一个作为测试集$T$,即$D = S \bigcup T,S \bigcap T = \emptyset$。在$S$上训练出模型后，用$T$来评估其测试误差，作为对泛化误差的估计。</p>
</li>
<li><p>需要注意的是，训练/测试集的划分要尽可能保持数据分布的一致性，避免因数据划分过程引入额外的偏差而对最终结果产生影响，例如在分类任务中至少要保持样本类别比例相似。如果从采样（sampling）的角度来看待数据集的划分过程，则保留类别比例的采样方式通常称为“分层采样”（stratified sampling）。</p>
</li>
<li><p>单次使用留出法得到的估计结果往往不够稳定可靠，在使用留出法时，一般要采用若干次随机划分、重复进行实验评估后取平均值作为留出法的评估结果。例如进行100次随机划分，每次产生一个训练/测试集用于试验评估，100次后就得到100个结果，而留出法返回的则是这100个结果的平均。</p>
<p>同时可得估计结果的标准差。</p>
</li>
<li><p>若令训练集$S$包含绝大多数样本，则训练出的模型可能更接近于$D$训练出的模型，但由于$T$比较小，评估结果可能不够稳定准确；若令测试集$T$多包含一些样本，则训练集$S$与$D$差别更大了，被评估的模型$D$训练出的模型相比可能有较大的差别，从而降低了评估结果的保真性（fidelity）。这个问题没有完美的解决方案，常见做法是将大约$2/3$ ~ $4/5$的样本用于训练，剩余样本用于测试。</p>
</li>
</ul>
<h2 id="2-2-2-交叉验证法"><a href="#2-2-2-交叉验证法" class="headerlink" title="2.2.2 交叉验证法"></a>2.2.2 交叉验证法</h2><ul>
<li>“交叉验证法”（cross validation）先将数据集$D$划分为$k$个大小相似的互斥子集，即$D = D_1 \bigcup D_2 \bigcup … \bigcup D_k$，$D_i \bigcap D_j = \emptyset$ （$i \ne j$)。每个子集$D_i$都尽可能保持数据分布的一致性，即从$D$中通过分层采样得到。然后，每次都用$k - 1$个子集的并集作为训练集，余下的那个子集作为测试集；</li>
<li>这样就可获得$k$组训练/测试集，从而可进行$k$次训练和测试，最终返回的是这$k$个测试结果的均值。<img src="https:cdn.jsdelivr.net/gh/TheNormalPeople/BlogImage/img/20210505212210.png" alt="交叉验证法"></li>
<li>交叉验证法评估结果的稳定性和保真性在很大程度上取决于$k$的取值，通常把交叉验证法称为“$k$折交叉验证”（$k$-fold cross validation)。$k$最常用的取值是10，此时称为10折交叉验证。</li>
<li>为减小因样本划分不同而引入的差别，$k$折交叉验证通常要随机使用不用的划分重复$p$次，最终的评估结果是这$p$次$k$折交叉验证结果的均值，例如常见的有“10次10折交叉验证”。”10次10折交叉验证法“与”100次留出法“都是进行了100次训练/测试。</li>
<li>假定数据集$D$中包含$m$个样本，若令$k = m$,则得到了交叉验证法的一个特例：留一法（Leave-One-Out，简称LOO）。留一法的评估结果往往被认为比较准确，然而留一法的估计结果也未必永远比其他评估方法准确；“没有免费的午餐”定理对实验评估方法同样适用。</li>
</ul>
<h2 id="2-2-3-自助法"><a href="#2-2-3-自助法" class="headerlink" title="2.2.3 自助法"></a>2.2.3 自助法</h2><ul>
<li>“自助法”（bootstrapping）是一个比较好的解决方案，它直接以自助采样法（bootstrap sampling）为基础。</li>
<li>给定包含$m$个样本的数据集$D$,我们对它进行采样产生数据集$D^{‘}$ ，然后再将这个样本放回初始数据集$D$中，使得该样本在下次采样时仍有可能被采到；这个过程重复执行$m$次后，我们就得到了包含$m$个样本的数据集$D^{‘} $,这就是自助采样的结果。$D$中有一部分样本会在$D^{‘}$中多次出现，而另一部分样本不出现。</li>
<li>样本在$m$次采样中始终不被采到的概率是${(1 - \frac{1}{m})}^m$,取极限得到<script type="math/tex">{\lim\limits_{m \to +\infty}}{(1 - \frac{1}{m})}^m = \frac{1}{e}\approx 0.368</script></li>
<li>于是我们可将$D^{‘}$用作训练集，$D/D^{‘}$用作测试集；实际评估的模型与期望评估的模型都使用$m$个训练样本，而我们仍有数据总量约$1/3$的、没有在训练集中出现的样本用于测试。这样的测试结果，亦称“外包估计”（out-of-bag estimate）。</li>
<li>自助法在数据集较小，难以有效划分训练/测试集时很有用；此外，自助法能从初始数据集中产生多个不同的训练集，这对集成学习等方法有很大的好处。然而，自助法产生的数据集改变了初始数据集的分布，这会引入估计偏差。因此，在初始数据量足够时，留出法和交叉验证法更常用一些。</li>
</ul>
<h2 id="2-2-4-调参与最终模型"><a href="#2-2-4-调参与最终模型" class="headerlink" title="2.2.4 调参与最终模型"></a>2.2.4 调参与最终模型</h2><ul>
<li>机器学习常涉及两类参数：<ul>
<li>一类是算法的参数，亦称“超参数”数目常在10以内；</li>
<li>另一类是模型的参数，数目可能很多，例如大型“深度学习”模型甚至有上百亿个参数。</li>
</ul>
</li>
<li>两者调参方式相似，均是产生多个模型之后基于某种评估方法来进行选择；不同之处在于：<ul>
<li>前者通常是由人工设定多个参数候选值后产生模型。</li>
<li>否则这是通过学习来产生多个候选模型（例如神经网络在不同轮数停止训练）。</li>
</ul>
</li>
<li>学习算法的很多参数是在实数范围内取值，因此，对每种参数配置都训练出模型来是不可行的。现实中常用的做法，是对每个参数选定一个范围和变化步长，例如在$[0,0.2]$范围内以$0.05$为步长，则实际要评估的候选参数值有$5$个，最终是从这$5$个候选值中产生选定值。</li>
<li>给定包含$m$个样本的数据集$D$,在模型评估与选择过程中由于需要留出一部分数据进行评估测试，事实上我们只使用了一部分数据训练模型。因此，在模型选择完成后，学习算法和参数配置已选定，此时应该用数据集$D$重新训练模型。这个模型在训练过程中使用了所有$m$个样本，这才是我们最终提交给用户的模型。</li>
<li>模型评估与选择中用于评估测试的数据集常称为“验证集”（validation set）。例如，在研究对比不同算法的泛化性能时，我们用测试集上的判别效果来估计模型在实际使用时的泛化能力，而把训练数据另外划分为训练集和验证集，基于验证集上的性能来进行模型选择和调参。</li>
</ul>
</li>
</ul>
<h1 id="2-3-性能度量"><a href="#2-3-性能度量" class="headerlink" title="2.3 性能度量"></a>2.3 性能度量</h1><ul>
<li><p>对学习器的泛化性能进行评估，不仅需要有效可行的实验估计方法，还需要有衡量模型泛化能力的评价标准，这就是性能度量（performance measure）。性能度量反映了任务需求，在对比不同模型的能力时，使用不同的性能度量往往会导致不同的评判结果。</p>
</li>
<li><p>在预测任务中，给定样例集$D = \{ (x_1,y_1),(x_2,y_2),…,(x_m,y_m)\}$,其中$y_i$是示例$x_i$的真实标记。要评估学习器$f$的性能，就要把学习器预测结果$f(x)$与真实标记$y$进行比较。</p>
</li>
<li><p>回归任务最常用的性能度量是“均方误差”(mean squared error)<script type="math/tex">E(f;D) = \frac{1}{m}\sum\limits_{i=1}^{m}{(f(x_i) - y_i})^2</script></p>
<h2 id="2-3-1错误率与精度"><a href="#2-3-1错误率与精度" class="headerlink" title="2.3.1错误率与精度"></a>2.3.1错误率与精度</h2><ul>
<li>错误率和精度是分类任务中最常用的两种性能度量，既适用于二分类任务，也适用于多分类任务。</li>
<li>错误率是分类错误的样本数占样本总数的比例。精度则是分类正确的样本数占样本总数的比例。</li>
<li>对样例集$D$，分类错误率定义为$E(f;D) = \frac{1}{m}\sum\limits_{i=1}^{m}{\Pi(f(x_i) \neq y_i})$；精度则定义为$acc(f;D) = \frac{1}{m}\sum\limits_{i=1}^{m}{\Pi(f(x_i) = y_i}) = 1 - E(f;D)$ </li>
</ul>
<h2 id="2-3-2-查准率、查全率与-F1"><a href="#2-3-2-查准率、查全率与-F1" class="headerlink" title="2.3.2 查准率、查全率与$F1$"></a>2.3.2 查准率、查全率与$F1$</h2><ul>
<li>对于二分类问题，可将样例根据其真实类别与学习器预测类别的组合划分为真正例（true positive）、假正例（false positive）、真反例（true negative）、假反例（false negative）四种情形，令$TP、FP、TN、FN$分别表示其对应的样例数，则显然有$TP+FP+TN+FN$ = 样例总数。</li>
<li>分类结果的“混淆矩阵”（confusion matrix）如表所示。<img src="https:cdn.jsdelivr.net/gh/TheNormalPeople/BlogImage/img/20210509101120.png" alt="分类结果混淆矩阵"></li>
<li>查准率$P$与查全率$R$分别定义为$P = \frac{TP}{TP + FP}$，$R = \frac{TP}{TP + FN}$。查全率（precision）亦称“准确率”；查全率（recall）亦称“召回率”。</li>
<li>查准率和查全率是一对矛盾的度量。一般来说，查准率高时，查全率往往偏低；而查全率高时，查准率往往偏低。通常只有在一些简单任务中，才可能使查全率和查准率都很高。</li>
<li>以查准率为纵轴、查全率为横轴作图，就得到了查准率-查全率曲线，简称“$P-R$曲线”，显示该曲线的图称为“$P-R$图”。<img src="https:cdn.jsdelivr.net/gh/TheNormalPeople/BlogImage/img/20210509101149.png" alt="P-R曲线与平衡点示意图"></li>
<li>若一个学习器的$P-R$曲线被另一个学习器的曲线完全“包住”，则可断言后者的性能优于前者。如果两个学习器的$P-R$曲线发生了交叉，则难以一般性地断言两者孰优孰劣，只能再具体的查准率或查全率条件下进行比较。</li>
<li>“平衡点”（Break-Even Point，简称BEP）就是这样一个度量，它是“查准率 = 查全率”时的取值，例如图中学习器$C$的$BEP$是$0.64$，而基于$BEP$的比较，可认为学习器$A$优于$B$。</li>
<li>但$BEP$还是过于简化了些，更常用的是$F1$度量：$F1 = \frac{2 \times P \times R}{P + R} = \frac{2 \times TP}{样例总数 + TP - TN}$</li>
<li>$F1$度量的一般形式—$F_\beta$，能让我们表达出对查准率/查全率的不同偏好，它定义为：$F_\beta = \frac{(1+\beta^2) \times P \times R}{(\beta^2 \times P)+R}$,其中$\beta &gt; 0$度量了查全率对查准率的重要性。$\beta = 1$时退化为标准的$F1$；$\beta &gt; 1$时查全率有更大影响；$\beta &lt; 1$时查准率有更大影响。</li>
<li>很多时候我们有多个二分类混淆矩阵，我们希望在$n$个二分类混淆矩阵上综合考察查准率和查全率。一种直接的做法是先在各混淆矩阵上分别计算出查准率和查全率，计为$(P_1,R_1),(P_2,R_2),…,(P_N,R_N)$，在计算平均值，这样就得到“宏查准率”（macro-P）、“宏查全率”（macro-R），以及相应的“宏$F1$”（macro-$F1$）：<script type="math/tex">macro-P = \frac{1}{n}\sum\limits_{i = 1}^{n}P_i</script>,<script type="math/tex">macro-R = \frac{1}{n}\sum\limits_{i = 1}^{n}R_i</script>,<script type="math/tex">macro-F1 = \frac{2 \times macro-P \times macro-R}{macro-p + macro-R}</script>。</li>
<li>还可先将个混淆矩阵的对应元素进行平均，得到$TP、FP、TN、FN$的平均值，分别计为$\bar{TP}、\bar{FP}、\bar{TN}、\bar{FN}$，再基于这些平均值算出“微查准率”（micro-P）、“微查全率”（micro-R）和“微$F1$”(micro-$F1$)：（micro-$F1$）：<script type="math/tex">micro-P = \frac{\bar{TP}}{\bar{TP} + \bar{FP}}</script>,<script type="math/tex">micro-R = \frac{\bar{TP}}{\bar{TP}+\bar{FN}}</script>,<script type="math/tex">macro-F1 = \frac{2 \times micro-P \times micro-R}{micro-p + micro-R}</script>。</li>
</ul>
<h2 id="2-3-3-ROC与AUC"><a href="#2-3-3-ROC与AUC" class="headerlink" title="2.3.3 ROC与AUC"></a>2.3.3 ROC与AUC</h2><ul>
<li><p>ROC全称是“受试者工作特征”(Receiver Operating Characteristic)曲线；ROC曲线的纵轴是“真正例率”（True Positive Rate，简称TPR），横轴是“假正例率”（False Positive Rate，简称FPR），$TPR = \frac{TP}{TP + FN}$   ($\frac{预测正确正例}{真实全部正例}$) ，$FPR = \frac{FP}{TN + FP}$（$\frac{预测错误正例}{真实全部反例}$)。</p>
</li>
<li><p>显示ROC曲线的图称为“ROC图”。绘图过程很简单：给定$m^+$个正例和$m^-$个反例，根据学习器预测结果对样例进行排序，然后把分类阈值设为最大，即把所有样例均预测为反例，此时真正例率和假正例率均为0，在坐标（0,0）处标记一个点。然后，将分类阈值依次设为每个样例的预测值，即依次将每个样例划分为正例。设前一个标记点坐标为（$x,y$），当前若为真正例，则对应标记点的坐标为（$x,y + \frac{1}{m^+}$）；当前若为假正例，则对应标记点坐标为（$x+\frac{1}{m^-},y$），然后用线段连接相邻点即得。</p>
</li>
<li><p>若一个学习器的ROC曲线被您一个学习器的曲线完全“包住”，则可断言后者的性能优于前者；若两个学习器的ROC曲线发生交叉，则难以一般性地断言两者孰优孰劣。此时如果一定要进行比较，则较为合理的判据是比较ROC曲线下的面积，即AUC（Area Under ROC Curve）。<img src="https:cdn.jsdelivr.net/gh/TheNormalPeople/BlogImage/img/20210508101119.png" alt="ROC曲线与AUC示意图"></p>
</li>
<li><p>从定义可知，AUC可通过对ROC曲线下各部分的面积求和而得。假定ROC曲线是由坐标为{$(x_1,y_1),(x_2,y_2),…,(x_m,y_m)$}的点按序连接而形成（$x_1=0,x_m=1)$，则AUC可估算为：<script type="math/tex">AUC = \frac{1}{2}\sum\limits_{i=1}^{m-1}(x_{i+1}-x_i)·(y_i+y_{i+1})</script></p>
</li>
<li><p>形式化地看，AUC考虑的是样本预测的排序质量，因此它与排序误差有紧密联系。给定$m^+$个正例和$m^-$个反例，令$D^+$和$D^-$分别表示正、反例集合，则排序”损失”（loss）定义为<script type="math/tex">l_{rank} = \frac{1}{m^+m^-}\sum\limits_{x^+ \in D^+}\sum\limits_{x^- \in D^-}(\prod(f(x^+)<f(x^-))+\frac{1}{2}\prod(f(x^+)=f(x^-)))</script>，即考虑每一对正、反例，若正例的预测值小于反例，则记一个“罚分”，若相等，则记0.5个“罚分”。容易看出，$l_{rank}$对应的是ROC曲线之上的面积：若一个正例在ROC曲线上对应标记点的坐标为$(x,y)$，则$x$恰是排序在其之前的反例所占的比例，即假正例率。因此有<script type="math/tex">AUC = 1-l{rank}</script>。</p>
</li>
</ul>
</li>
</ul>
<h2 id="2-3-4-代价敏感错误率与代价曲线"><a href="#2-3-4-代价敏感错误率与代价曲线" class="headerlink" title="2.3.4 代价敏感错误率与代价曲线"></a>2.3.4 代价敏感错误率与代价曲线</h2><ul>
<li>为权衡不同类型错误所造成的的不同损失，可为错误赋予“非均等代价”（unequal cost）。</li>
<li>以二分类任务为例，我们可根据任务的领域知识设定一个“代价矩阵”（cost matrix），如图所示，其中$cost_{ij}$表示将第$i$类样本预测为第$j$类样本的代价。一般来说，$cost_{ii}=0$;若将第0类判别为第1类所造成的的损失更大，则$cost_{01}&gt;cost_{10}$；损失程度相差越大，$cost_{01}$与$cost_10$值的差别越大。<img src="https:cdn.jsdelivr.net/gh/TheNormalPeople/BlogImage/img/20210508103920.png" alt="二分类代价矩阵">一般情况下，重要的是代价比值而绝非绝对值。</li>
<li>在非均等代价下，我们所希望的不再是最简单地最小化错误次数，而是希望最小化“总体代价”（total cost）。</li>
<li>若将表中的第0类作为正类、第1类作为反类，令$D^+$与$D^-$分别代表样例集$D$的正例子集和反例子集，则“代价敏感”（cost-sensitive）错误率为<script type="math/tex">E(f;D;cost)=\frac{1}{m}(\sum\limits_{x_i\in D^+}\prod(f(x_i \ne y_i)\times cost_{01})+\sum\limits_{x_i\in D^-}\prod(f(x_i \ne y_i)\times cost_{10}))</script></li>
<li>在非均等代价下，ROC曲线不能直接反映出学习器的期望总体代价，而“代价曲线”（cost curve）则可达到该目的。代价曲线图的横轴是取值为[0,1]的正例率代价<script type="math/tex">P(+)cost=\frac{p\times cost_{01}}{p\times cost_{01}+(1-p)\times cost_{10}}</script>,其中$p$是样例为正例的概率；纵轴是取值为[0,1]的归一化代价<script type="math/tex">cost_{norm}=\frac{FNR\times p \times cost_{01}+FPR\times(1-p)\times cost_{10}}{p\times cost_{01}+(1-p)\times cost_{10}}</script>,其中FPR为假正例率，FNR=1-TPR是假反例率。</li>
<li>代价曲线的绘制很简单：ROC曲线上的每一点对应了代价平面上的一条线段，设ROC曲线上点的坐标为（FPR，TPR），则可相应计算出FNR，然后在代价平面上绘制一条从（0，FPR）到（1，FNR）的线段，线段下的面积即表示了该条件下的期望总体代价；如此将ROC曲线上的每个点转化为代价平面上的一条线段，然后去所有线段的下界，围成的面积即为在所有条件下学习器的期望总体代价。<img src="https:cdn.jsdelivr.net/gh/TheNormalPeople/BlogImage/img/20210508110328.png" alt="代价曲线与期望总体代价"></li>
</ul>
<h1 id="2-4-比较检验"><a href="#2-4-比较检验" class="headerlink" title="2.4 比较检验"></a>2.4 比较检验</h1><ul>
<li><p>有了实验评估方法和性能度量，看起来就能对学习器的性能进行评估比较了：先使用某种实验评估方法测得学习器的某个性能度量结果，然后对这些结果进行比较。</p>
</li>
<li><p>实际上，机器学习中性能比较这件事要比大家想象的复杂得多。这里面涉及几个重要因素：</p>
<ul>
<li>首先，我们希望比较的是泛化性能，然而通过实验评估方法我们获得的是测试集上的性能，两者的对比结果可能未必相同。</li>
<li>第二，测试集上的性能与测试集本身的选择有很大关系，且不论使用不同大小的测试集会得到不同的结果，即便用相同大小的测试集，若包含的测试样例不同，测试结果也会不同。</li>
<li>第三，很多机器学习算法本身有一定的随机性，即便使用相同的参数设置在同一个测试集上多次运行，其结果也会有不同。</li>
</ul>
</li>
<li><p>统计假设检验（hypothesis test）为我们进行学习器性能比较提供了重要依据。基于假设检验结果我们可推断出，若在测试集上观察到学习器A比B好，则A的泛化性能是否在统计意义上优于B，以及这个结论的把握有多大。本节默认以错误率为性能度量，用$\epsilon$表示。</p>
<h2 id="2-4-1-假设检验"><a href="#2-4-1-假设检验" class="headerlink" title="2.4.1 假设检验"></a>2.4.1 假设检验</h2><ul>
<li>假设检验中的“假设”是对学习器泛化错误率分布的某种判断或猜想，例如“$\epsilon=\epsilon_0$”。显示任务中我们并不知道学习器的泛化错误率，只能获知其测试错误率$\widehat{\epsilon}$。泛化错误率与测试错误率未必相同，但直观上，二者接近的可能性应比较大，相差很远的可能性比较小。因此，可根据测试错误率估推出泛化错误率的分布。</li>
<li>二项分布与$t$分布<img src="https:cdn.jsdelivr.net/gh/TheNormalPeople/BlogImage/img/20210508114056.png" alt="二项分布示意图"><img src="https:cdn.jsdelivr.net/gh/TheNormalPeople/BlogImage/img/20210508114107.png" alt="t分布示意图"></li>
</ul>
<h2 id="2-4-2-交叉t验证"><a href="#2-4-2-交叉t验证" class="headerlink" title="2.4.2 交叉t验证"></a>2.4.2 交叉t验证</h2><ul>
<li>自行查阅</li>
</ul>
<h2 id="2-4-3-McNemar检验"><a href="#2-4-3-McNemar检验" class="headerlink" title="2.4.3 McNemar检验"></a>2.4.3 McNemar检验</h2><ul>
<li>自行查阅</li>
</ul>
<h2 id="2-4-4-Friedman检验-与-Nemenyi后续检验"><a href="#2-4-4-Friedman检验-与-Nemenyi后续检验" class="headerlink" title="2.4.4 Friedman检验 与 Nemenyi后续检验"></a>2.4.4 Friedman检验 与 Nemenyi后续检验</h2><ul>
<li>自行查阅</li>
</ul>
</li>
</ul>
<h1 id="2-5-偏差与方差"><a href="#2-5-偏差与方差" class="headerlink" title="2.5 偏差与方差"></a>2.5 偏差与方差</h1><ul>
<li>“偏差-方差分解”（bias-variance decomposition）是解释学习算法泛化性能的一种重要工具。</li>
<li>偏差-方差分解试图对学习算法的期望泛化错误率进行拆解。</li>
<li>对测试样本$x$，令$y_D$为$x$在数据集中的标记，$y$为$x$的真实标记，$f(x;D)$为训练集$D$上学得模型$f$在$x$上的预测输出。</li>
<li>以回归任务为例，学习算法的期望预测为<script type="math/tex">\bar{f}(x)=\mathbb{E}_D[f(x;D)]</script>,使用样本数相同的不同训练集产生的方差为<script type="math/tex">var(x)=\mathbb{E}[(f(x;D)-\bar{f}(x))^2]</script>，噪声为<script type="math/tex">\epsilon^2=\mathbb{E}[(y_D-y)^2]</script>。期望输出与真实标记的差别称为偏差（bias），即<script type="math/tex">bias^2(x)=(\bar{f}(x)-y)^2</script>。</li>
<li>为方便讨论，假定噪声期望为零，即$\mathbb{E}[(y_D-y)^2]=0$，于是$E(f;D)=bias^2(x)+var(x)+\epsilon^2$，也就是说，泛化误差可以分解为偏差、方差与噪声之和。噪声期望为0，因此最后项为0。</li>
<li>偏差度量了学习算法的期望预测与真实结果的偏离程度，即刻画了学习算法本身的拟合能力</li>
<li>方差度量了同样大小的训练集的变动所导致的学习性能的变化，即刻画了数据扰动所造成的的影响。</li>
<li>噪声则表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界，即刻画了学习问题本身的难度。</li>
<li>偏差-方差分解说明，泛化性能是由学习算法的能力，数据的充分性以及学习任务本身的难度所共同决定的。</li>
<li>给定学习任务，为了取得好的泛化性能，则需使偏差较小，即能够充分拟合数据，并且使方差较小，即使得数据扰动产生的影响小。一般来说，偏差与方差是有冲突的，这称为偏差-方差窘境（bias-variance dilemma）。<img src="https:cdn.jsdelivr.net/gh/TheNormalPeople/BlogImage/img/20210509100104.png" alt="泛化误差与偏差、方差的关系示意图"></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/default-index/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/default-index/">1</a><a class="page-number" href="/default-index/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/default-index/page/4/">4</a><a class="extend next" rel="next" href="/default-index/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Normal People"
      src="/images/posthead.jpg">
  <p class="site-author-name" itemprop="name">Normal People</p>
  <div class="site-description" itemprop="description">Get busy living or get busy dying</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
        
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/TheNormalPeople" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;TheNormalPeople" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1272481411@qq.com" title="E-Mail → mailto:1272481411@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5938927274" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5938927274" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/cy19970506" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;cy19970506" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Normal People</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'y8XFURQNCoQsprRTou9DiEJu-gzGzoHsz',
      appKey     : 'QfVpjKDtJQdJrnJNnWUbVvjH',
      placeholder: "留下邮箱,有空时间回复您！",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
