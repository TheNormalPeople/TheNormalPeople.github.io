<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true,"scrollpercent":true,"b2t":true},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Get busy living or get busy dying">
<meta property="og:type" content="website">
<meta property="og:title" content="Blog">
<meta property="og:url" content="http://example.com/default-index/page/3/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="Get busy living or get busy dying">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Normal People">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/default-index/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">by Normal People</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">17</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">42</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/10/Statistical_Learning_Methods_Notes/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E9%80%BB%E8%BE%91%E6%96%AF%E8%92%82%E5%9B%9E%E5%BD%92%E4%B8%8E%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/10/Statistical_Learning_Methods_Notes/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E9%80%BB%E8%BE%91%E6%96%AF%E8%92%82%E5%9B%9E%E5%BD%92%E4%B8%8E%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">第六章 逻辑斯蒂回归与最大熵模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-10 20:24:36" itemprop="dateCreated datePublished" datetime="2021-06-10T20:24:36+08:00">2021-06-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-09 20:09:16" itemprop="dateModified" datetime="2021-06-09T20:09:16+08:00">2021-06-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">统计学习方法</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/06/10/Statistical_Learning_Methods_Notes/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E9%80%BB%E8%BE%91%E6%96%AF%E8%92%82%E5%9B%9E%E5%BD%92%E4%B8%8E%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/06/10/Statistical_Learning_Methods_Notes/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E9%80%BB%E8%BE%91%E6%96%AF%E8%92%82%E5%9B%9E%E5%BD%92%E4%B8%8E%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>逻辑斯蒂回归（logistic regression）</strong>是统计学习中的经典分类方法。</p>
<p>最大熵是概率模型学习的一个准则，将其推广到分类问题得到<strong>最大熵模型（maximum entropy model）</strong>。</p>
<p>逻辑斯蒂回归模型与最大熵模型都属于对数线性模型。</p>
<h1 id="6-1-逻辑斯蒂回归模型"><a href="#6-1-逻辑斯蒂回归模型" class="headerlink" title="6.1 逻辑斯蒂回归模型"></a>6.1 逻辑斯蒂回归模型</h1><h2 id="6-1-1-逻辑斯蒂分布"><a href="#6-1-1-逻辑斯蒂分布" class="headerlink" title="6.1.1 逻辑斯蒂分布"></a>6.1.1 逻辑斯蒂分布</h2><p>首先介绍<strong>逻辑斯蒂分布（logistic distribution）</strong>。</p>
<p><strong>定义 6.1（逻辑斯蒂分布）</strong>  设$X$是连续随机变量，$X$服从逻辑斯蒂分布是指$X$具有下列分布函数和密度函数：</p>
<script type="math/tex; mode=display">
F(x) = P(X \leq x) = \frac{1}{1 \ + \ e^{-(x - \mu)/\gamma}} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (6.1)</script><script type="math/tex; mode=display">
f(x) = F'(x) = \frac{e^{-(x - \mu)/\gamma}}{\gamma(1 \ + \ e^{-(x - \mu)/\gamma})^2} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (6.2)</script><p>式中，$\mu$为位置参数，$\gamma &gt; 0$为形状参数。</p>
<p>分布函数属于逻辑斯蒂函数，其图形是一条$S$形曲线（sigmoid curve）。该曲线以点$(\mu,\frac{1}{2})$为中心对称，即满足</p>
<script type="math/tex; mode=display">
F(-x \ + \ \mu) - \frac{1}{2} = -F(x \ + \ \mu) + \frac{1}{2}</script><p>形状参数$\gamma$的值越小，曲线在中心附近增长得越快。</p>
<h2 id="6-1-2-二项逻辑斯蒂回归模型"><a href="#6-1-2-二项逻辑斯蒂回归模型" class="headerlink" title="6.1.2 二项逻辑斯蒂回归模型"></a>6.1.2 二项逻辑斯蒂回归模型</h2><p><strong>二项逻辑斯蒂回归模型（binomial logistic regression model）</strong>是一种分类模型，由条件概率分布$P(Y|X)$表示，形式为参数化的逻辑斯蒂分布。</p>
<p><strong>定义 6.2（逻辑斯蒂回归模型）</strong>  二项逻辑斯蒂回归模型是如下的条件概率分布：</p>
<script type="math/tex; mode=display">
P(Y=1|x) = \frac{\exp(\omega·x + b)}{1 \ + \ \exp(\omega·x + b)} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (6.3)</script><script type="math/tex; mode=display">
P(Y=0|x) = \frac{1}{1 \ + \ \exp(\omega·x + b)} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (6.4)</script><p>这里，$x \in R^n$是输入，$Y \in \{0,1\}$是输出，$\omega \in R^n $和$b \in R$是参数，$\omega$称为权值向量，$b$称为偏置，$\omega·x$为$\omega$和$x$的内积。</p>
<p>对于给定的输入实例$x$，逻辑斯蒂回归比较两个条件概率值的大小，将实例$x$分到概率值较大的那一类。</p>
<p>有时为了方便，将权值向量和输入向量加以扩充，仍记作$\omega,x$，即$\omega = (\omega^{(1)},\omega^{(2)},…,\omega^{(n)},b)^T,\ x = (x^{(1)},x^{(2)},…,x^{(n)},1)$。这时，逻辑斯蒂回归模型如下：</p>
<script type="math/tex; mode=display">
P(Y=1|x) = \frac{\exp(\omega·x)}{1 \ + \ \exp(\omega·x)} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (6.5)</script><script type="math/tex; mode=display">
P(Y=0|x) = \frac{1}{1 \ + \ \exp(\omega·x)} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (6.6)</script><hr>
<p>一个事件的<strong>几率（odds）</strong>是指该事件发生的概率与该事件不发生的概率的比值。如果事件发生的概率是$p$，那么该事件的几率是$\frac{p}{1-p}$，该事件的<strong>对数几率（log odds）</strong>或<strong>logit函数</strong>是</p>
<script type="math/tex; mode=display">
logit(p) = \log\frac{p}{1-p}</script><p>对于逻辑斯蒂回归而言，由式$(6.5)$与式$(6.6)$得</p>
<script type="math/tex; mode=display">
\log\frac{P(Y=1|x)}{1\ - \ P(Y=1|x)} = \omega ·x</script><p>这就是说，在逻辑斯蒂回归模型中，输出$Y=1$的对数几率是输入$x$的线性函数。或者说，输出$Y=1$的对数几率是由输入$x$的线性函数表示的模型，即逻辑斯蒂回归模型。</p>
<h2 id="6-1-3-模型参数估计"><a href="#6-1-3-模型参数估计" class="headerlink" title="6.1.3 模型参数估计"></a>6.1.3 模型参数估计</h2><p>逻辑斯蒂回归模型学习时，对于给定的训练数据集$T = \{(x_1,y_1),(x_2,y_2),…,(x_N,y_N)\}$，其中，$x_i \in R^n, y_i \in\{0,1\} $，可以应用极大似然估计法估计模型参数，从而得到逻辑斯蒂回归模型。</p>
<p>设：</p>
<script type="math/tex; mode=display">
P(Y=1|x) = \pi(x),\ \ \  P(Y=0|x) = 1 - \pi(x)</script><p>似然函数为</p>
<script type="math/tex; mode=display">
\prod\limits_{i=1}^{N}[\pi(x_i)]^{y_i}[1-\pi(x_i)]^{1-y_i}</script><p>对数似然函数为</p>
<script type="math/tex; mode=display">
L(\omega) = \sum\limits_{i=1}^{N}[y_i \log \pi(x_i)\  + \ (1-y_i)\log(1-\pi(x_i))]</script><script type="math/tex; mode=display">
\ \ \ \ =\sum\limits_{i=1}^{N}[y_i \log \frac{\pi(x_i)}{1-\pi(x_i)}\  + \ \log(1-\pi(x_i))]</script><script type="math/tex; mode=display">
\ \ =\sum\limits_{i=1}^{N}[y_i (\omega·x_i)\  - \ \log(1+\exp(\omega · x_i))]</script><p>对$L(\omega)$求极大值，得到$\omega$的估计值。</p>
<p>这样，问题就变成了以对数似然函数为目标函数的最优化问题。逻辑斯蒂回归学习中通常采用的方法是梯度下降法及拟牛顿法。</p>
<h2 id="6-1-4-多项逻辑斯蒂回归"><a href="#6-1-4-多项逻辑斯蒂回归" class="headerlink" title="6.1.4 多项逻辑斯蒂回归"></a>6.1.4 多项逻辑斯蒂回归</h2><p>上面介绍的逻辑斯蒂回归模型是二项分类模型，用于二类分类。可以将其推广为<strong>多项逻辑斯蒂回归模型（multi-nominal logistic regression model）</strong>，用于多类分类。</p>
<p>设离散型随机变量$Y$的取值集合是$\{1,2,…,K\}$，那么多项逻辑斯蒂回归模型是</p>
<script type="math/tex; mode=display">
P(Y=k|x) = \frac{\exp(\omega_k·x)}{1 \ + \ \sum\limits_{k=1}^{K-1}\exp(\omega_k·x)}, \ \ k = 1,2,...,K-1 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (6.7)</script><script type="math/tex; mode=display">
P(Y=K|x) = \frac{1}{1 \ + \ \sum\limits_{k=1}^{K-1}\exp(\omega_k·x)}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (6.8)</script><p>这里，$x \in R^{n+1},\omega_k \in R^{n+1}$。</p>
<p>二项逻辑斯蒂回归的参数估计法也可以推广到多项逻辑斯蒂回归。</p>
<h1 id="6-2-最大熵模型"><a href="#6-2-最大熵模型" class="headerlink" title="6.2 最大熵模型"></a>6.2 最大熵模型</h1><p><strong>最大熵模型（maximum entropy model）</strong>由最大熵原理推导实现。</p>
<h2 id="6-2-1-最大熵原理"><a href="#6-2-1-最大熵原理" class="headerlink" title="6.2.1 最大熵原理"></a>6.2.1 最大熵原理</h2><p>最大熵原理认为，学习概率模型时，在所有可能的概率模型（分布）中，熵最大的模型是最好的模型。通常用约束条件来确定概率模型的集合，所以，最大熵原理也可以表述为在满足约束条件的模型集合中选取熵最大的模型。</p>
<p>假设离散随机变量$X$的概率分布是$P(X)$，则其熵是</p>
<script type="math/tex; mode=display">
H(P) = -\sum\limits_{x}P(x)\log P(x)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (6.9)</script><p>熵满足下列不等式：</p>
<script type="math/tex; mode=display">
0 \leq H(P) \leq \log|X|</script><p>式中，$|X|$是$X$的取值个数，当且仅当$X$的分布是均匀分布时右边的等号成立。这就是说，当$X$服从均匀分布时，熵最大。</p>
<p>直观地，最大熵原理认为要选择的概率模型首先必须满足已有的事实，即约束条件。在没有更多信息的情况下，那些不确定的部分都是“等可能的”。最大熵原理通过熵的最大化来表示等可能性。“等可能”不容易操作，而熵则是一个可优化的数值指标。</p>
<h2 id="6-2-2-最大熵模型的定义"><a href="#6-2-2-最大熵模型的定义" class="headerlink" title="6.2.2 最大熵模型的定义"></a>6.2.2 最大熵模型的定义</h2><p>假设分类模型是一个条件概率分布$P(Y|X),X \in \chi \subseteq R^n$表示输入，$Y \in \mathcal{Y}$表示输出，$\chi $和$\mathcal{Y}$分别是输入和输出的集合。这个模型表示的是对于给定的输入$X$，以条件概率$P(Y|X)$输出$Y$。</p>
<p>给定一个训练数据集</p>
<script type="math/tex; mode=display">
T = \{(x_1,y_1),(x_2,y_2),...,(x_N,y_N)\}</script><p>学习的目标是用最大熵原理选择最好的分类模型。</p>
<hr>
<p>首先考虑模型应该满足的条件。给定训练数据集，可以确定联合分布$P(X,Y)$的经验分布和边缘分布$P(X)$的经验分布，分别以$\tilde{P}(X,Y)$和$\tilde{P}(X)$表示。这里，</p>
<script type="math/tex; mode=display">
\tilde{P}(X=x,Y=y) = \frac{\upsilon(X=x,Y=y)}{N}</script><script type="math/tex; mode=display">
\tilde{P}(X=x)=\frac{\upsilon(X=x)}{N}</script><p>其中，$\upsilon(X=x,Y=y)$表示训练数据中样本$(x,y)$出现的频数，$\upsilon(X=x)$表示训练数据中输入$x$出现的频数，$N$表示训练样本容量。</p>
<p>用<strong>特征函数（feature function）</strong>$f(x,y)$描述输入$x$和输出$y$之间的某一个事实。其定义是</p>
<script type="math/tex; mode=display">
f(x,y) = \lbrace_{0, \ \ \ 否则}^{1,\ \ \ x与y满足某一事实}</script><p>特征函数$f(x,y)$关于经验分布$\tilde{P}(X,Y)$的期望值，用$E_{\tilde{P}}(f)$表示：</p>
<script type="math/tex; mode=display">
E_{\tilde{P}}(f) = \sum\limits_{x,y}\tilde{P}(x,y)f(x,y)</script><p>特征函数$f(x,y)$关于模型$P(Y|X)$与经验分布$\tilde{P}(X)$的期望值，用$E_P(f)$表示：</p>
<script type="math/tex; mode=display">
E_P(f)=\sum\limits_{x,y}\tilde{P}(x)P(y|x)f(x,y)</script><p>如果模型能够获取训练数据中的信息，那么就可以假设这两个期望值相等，即</p>
<script type="math/tex; mode=display">
E_P(f)=E_{\tilde{P}}(f)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (6.10)</script><p>或</p>
<script type="math/tex; mode=display">
\sum\limits_{x,y}\tilde{P}(x)P(y|x)f(x,y) = \sum\limits_{x,y}\tilde{P}(x,y)f(x,y)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (6.11)</script><p>将式$(6.10)$或式$(6.11)$作为模型学习的约束条件。假设有$n$个特征函数$f_i(x,y),\ \ i=1,2,…,n$，那么就有$n$个约束条件。</p>
<hr>
<p><strong>定义 6.3（最大熵模型）</strong> 假设满足所有约束条件的模型集合为</p>
<script type="math/tex; mode=display">
\mathcal{C} \equiv \{P\in \mathcal{P}|E_P(f_i)=E_{\tilde{P}}(f),\ \ \ i=1,2,...,n\}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (6.12)</script><p>定义在条件概率分布$P(Y|X)$上的条件熵为</p>
<script type="math/tex; mode=display">
H(P) = -\sum\limits_{x,y}\tilde{P}(x)P(y|x)\log P(y|x)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (6.13)</script><p>则模型集合$\mathcal{C}$中条件熵$H(P)$最大的模型称为最大熵模型。</p>
<h2 id="6-2-3-最大熵模型的学习"><a href="#6-2-3-最大熵模型的学习" class="headerlink" title="6.2.3 最大熵模型的学习"></a>6.2.3 最大熵模型的学习</h2><p>最大熵模型的学习过程就是求解最大熵模型的过程。最大熵模型的学习可以形式化为约束最优化问题。</p>
<p>对于给定的训练数据集$T = \{(x_1,y_1),(x_2,y_2),…,(x_N,y_N)\}$以及特征函数$f_i(x,y),i=1,2,…,n$，最大熵模型的学习等价于约束最优化问题：</p>
<script type="math/tex; mode=display">
\max\limits_{P \in \mathcal{C}}  H(P) = -\sum\limits_{x,y}\tilde{P}(x)P(y|x)\log P(y|x)</script><script type="math/tex; mode=display">
s.t.\ \ \ E_P(f_i)=E_{\tilde{P}}(f_i),\ \ \ i=1,2,...,n</script><script type="math/tex; mode=display">
\sum\limits_{y} P(y|x) = 1</script><p>按照最优化问题的习惯，将求最大值问题改写为等价的求最小值问题：</p>
<script type="math/tex; mode=display">
\min\limits_{P \in \mathcal{C}}  -H(P) = \sum\limits_{x,y}\tilde{P}(x)P(y|x)\log P(y|x)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (6.14)</script><script type="math/tex; mode=display">
s.t.\ \ \ E_P(f_i) - E_{\tilde{P}}(f_i) = 0,\ \ \ i=1,2,...,n \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (6.15)</script><script type="math/tex; mode=display">
\sum\limits_{y} P(y|x) = 1 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  (6.16)</script><p>求解约束最优化问题$(6.14)~(6.16)$，所得出的解，就是最大熵模型学习的解。<strong>具体推导省略。详见《统计学习方法-李航》98~100页。</strong></p>
<p>可以应用最优化算法求对偶函数$\Psi(\omega)$的极大化，得到$\omega^<em>$，用来表示$P^</em> \in \mathcal{C}$。这里，$P^<em>=P_{\omega^</em>}=P_{\omega^*}(y|x)$是学习到的最优模型（最大熵模型）也就是说，最大熵模型的学习归结为对偶函数$\Psi(\omega)$的极大化。</p>
<h2 id="6-2-4-极大似然估计"><a href="#6-2-4-极大似然估计" class="headerlink" title="6.2.4 极大似然估计"></a>6.2.4 极大似然估计</h2><p>对偶函数极大化等价于最大熵模型的极大似然估计。对偶函数$\Psi(\omega)$等价于对数似然函数$L_{\tilde{P}}(P_\omega)$。<strong>具体推导省略。详见《统计学习方法-李航》102~103页。</strong></p>
<p>这样，最大熵模型的学习问题就转换为具体求解对数似然函数极大化或对偶函数极大化的问题。</p>
<p>可以将最大熵模型写成更一般的形式。</p>
<script type="math/tex; mode=display">
P_{\omega}(y|x)=\frac{1}{Z_{\omega}(x)}\exp(\sum\limits_{i=1}^n \omega_if_i(x,y))\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (6.28)</script><p>其中，</p>
<script type="math/tex; mode=display">
Z_{\omega}(x)=\sum\limits_{y} \exp(\sum\limits_{i=1}^n \omega_if_i(x,y))\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (6.29)</script><p>最大熵模型与逻辑斯蒂回归模型由类似的形式，它们又称为<strong>对数线性模型（log linear model）</strong>。模型学习就是在给定的训练数据条件下对模型进行极大似然估计或正则化的极大似然估计。</p>
<h1 id="6-3-模型学习的最优化算法"><a href="#6-3-模型学习的最优化算法" class="headerlink" title="6.3 模型学习的最优化算法"></a>6.3 模型学习的最优化算法</h1><p>逻辑斯蒂回归模型、最大熵模型学习归结为以似然函数为目标函数的最优化问题，通常通过迭代算法求解。从最优化的观点看，这时的目标函数具有很好的性质。它是光滑的凸函数，因此多种最优化的方法都适用，保证能找到全局最优解。常用的方法有改进的迭代尺度法、梯度下降法、牛顿法和拟牛顿法。牛顿法或拟牛顿法一般收敛速度更快。</p>
<h2 id="6-3-1-改进的迭代尺度法"><a href="#6-3-1-改进的迭代尺度法" class="headerlink" title="6.3.1 改进的迭代尺度法"></a>6.3.1 改进的迭代尺度法</h2><p><strong>改进的迭代尺度法（improved iterative scaling，IIS）</strong>是一种最大熵模型学习的最优化算法。</p>
<h2 id="6-3-2-拟牛顿法"><a href="#6-3-2-拟牛顿法" class="headerlink" title="6.3.2 拟牛顿法"></a>6.3.2 拟牛顿法</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/08/Data%20_Competition/Python_Foundation/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E5%92%8Cwhile%E5%BE%AA%E7%8E%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/08/Data%20_Competition/Python_Foundation/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E5%92%8Cwhile%E5%BE%AA%E7%8E%AF/" class="post-title-link" itemprop="url">第七章 用户输入和while循环</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-08 16:46:39" itemprop="dateCreated datePublished" datetime="2021-06-08T16:46:39+08:00">2021-06-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-02 21:52:45" itemprop="dateModified" datetime="2021-07-02T21:52:45+08:00">2021-07-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">数据竞赛</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/06/08/Data%20_Competition/Python_Foundation/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E5%92%8Cwhile%E5%BE%AA%E7%8E%AF/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/06/08/Data%20_Competition/Python_Foundation/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E5%92%8Cwhile%E5%BE%AA%E7%8E%AF/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="7-1-函数input-的工作原理"><a href="#7-1-函数input-的工作原理" class="headerlink" title="7.1 函数input()的工作原理"></a>7.1 函数input()的工作原理</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">message = <span class="built_in">input</span>(<span class="string">&quot;tell me something:&quot;</span>)</span><br><span class="line">print(message)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tell me something:Hello Python World!   #Hello Python World!为用户在控制台的输入</span><br><span class="line">Hello Python World!</span><br></pre></td></tr></table></figure>
<p>函数input()接受一个参数——要向用户显示的<strong>提示（prompt）</strong>或说明，让用户知道该如何做。</p>
<p>程序运行到input()函数时，程序等待用户输入，并在用户按回车键后继续运行。</p>
<h2 id="7-1-1-编写清晰的程序"><a href="#7-1-1-编写清晰的程序" class="headerlink" title="7.1.1 编写清晰的程序"></a>7.1.1 编写清晰的程序</h2><p>有时候，提示可能超过一行。例如，你可能需要指出获取特定输入的原因。在这种情况下，可将提示赋给一个变量，再将该变量传递给函数input()。这样，即便提示超过一行，input()语句也会非常清晰。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">prompt = <span class="string">&quot;If you tell us who you are, we can personalize the message you see.&quot;</span></span><br><span class="line">prompt += <span class="string">&quot;\nWhat is your first name?&quot;</span></span><br><span class="line">name = <span class="built_in">input</span>(prompt)</span><br><span class="line">print(<span class="string">f&quot;hello, <span class="subst">&#123;name&#125;</span>!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">If you tell us who you are, we can personalize the message you see.</span><br><span class="line">What is your first name?zhang</span><br><span class="line">hello, zhang!</span><br></pre></td></tr></table></figure>
<h2 id="7-1-2-使用int-来获取数值输入"><a href="#7-1-2-使用int-来获取数值输入" class="headerlink" title="7.1.2 使用int()来获取数值输入"></a>7.1.2 使用int()来获取数值输入</h2><p>使用函数input()时，Python将用户输入解读为字符串。为解决这个问题，可使用函数int()，它让Python将输入视为数值。函数int()将数的字符串转换为数值表示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="built_in">input</span>(<span class="string">&quot;How old are you?&quot;</span>)</span><br><span class="line">age = <span class="built_in">int</span>(age)</span><br><span class="line"><span class="keyword">if</span>(age &gt;= <span class="number">18</span>):</span><br><span class="line">	print(<span class="string">&quot;you are a men!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">How old are you?24</span><br><span class="line">you are a men!</span><br></pre></td></tr></table></figure>
<p>还有函数float()可将字符串转为小数。</p>
<h2 id="7-1-3-求模运算符"><a href="#7-1-3-求模运算符" class="headerlink" title="7.1.3 求模运算符"></a>7.1.3 求模运算符</h2><p>处理数值信息时，求模运算符（%）是个很有用的工具，它将两个数相除并返回余数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="number">4</span> % <span class="number">3</span>)</span><br><span class="line">print(<span class="number">5</span> % <span class="number">3</span>)</span><br><span class="line">print(<span class="number">6</span> % <span class="number">3</span>)</span><br><span class="line">print(<span class="number">7</span> % <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h1 id="7-2-while循环简介"><a href="#7-2-while循环简介" class="headerlink" title="7.2 while循环简介"></a>7.2 while循环简介</h1><p>for循环用于针对集合中的每个元素都执行一个代码块，而while循环则不断运行，直到指定的条件不满足为止。</p>
<h2 id="7-2-1-使用while循环"><a href="#7-2-1-使用while循环" class="headerlink" title="7.2.1 使用while循环"></a>7.2.1 使用while循环</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cur_number = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> cur_number &lt; <span class="number">6</span>:</span><br><span class="line">	print(cur_number)</span><br><span class="line">	cur_number += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<h2 id="7-2-2-让用户选择何时退出"><a href="#7-2-2-让用户选择何时退出" class="headerlink" title="7.2.2 让用户选择何时退出"></a>7.2.2 让用户选择何时退出</h2><p>可以使用while循环让程序在用户愿意时不断运行，可以定义一个<strong>退出值</strong>，只要用户输入的不是这个值，程序就将接着运行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">while</span> message != <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">	message = <span class="built_in">input</span>(<span class="string">&quot;please input something:&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> message != <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">		print(<span class="string">f&quot;your input the message is :<span class="subst">&#123;message&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">please input something:hello</span><br><span class="line">your input the message is :hello</span><br><span class="line"></span><br><span class="line">please input something:python</span><br><span class="line">your input the message is :python</span><br><span class="line"></span><br><span class="line">please input something:world</span><br><span class="line">your input the message is :world</span><br><span class="line"></span><br><span class="line">please input something:quit</span><br></pre></td></tr></table></figure>
<h2 id="7-2-3-使用标志"><a href="#7-2-3-使用标志" class="headerlink" title="7.2.3 使用标志"></a>7.2.3 使用标志</h2><p>在要求很多条件都满足才继续运行的程序中，可定义一个变量，用于判断整个程序是否处于活动状态。这个变量称为<strong>标志（flag）</strong>，充当程序的交通信号灯。可以让程序在标志为True时继续运行，并在任何事件导致的值为False时让程序停止运行。这样，在while语句中就只需检查一个条件：标志的当前值是否为True。然后将所有其他测试（是否发生了应将标志设为False的事件）都放在其他地方，从而让程序更整洁。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">message = <span class="string">&quot;&quot;</span></span><br><span class="line">flag = <span class="literal">True</span></span><br><span class="line"><span class="keyword">while</span> flag:</span><br><span class="line">	message = <span class="built_in">input</span>(<span class="string">&quot;please input something:&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> message != <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">		print(<span class="string">f&quot;your input the message is :<span class="subst">&#123;message&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        flag = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">please input something:hello </span><br><span class="line">your input the message is :hello </span><br><span class="line"></span><br><span class="line">please input something:python</span><br><span class="line">your input the message is :python</span><br><span class="line"></span><br><span class="line">please input something:world</span><br><span class="line">your input the message is :world</span><br><span class="line"></span><br><span class="line">please input something:quit</span><br></pre></td></tr></table></figure>
<h2 id="7-2-4-使用break退出循环"><a href="#7-2-4-使用break退出循环" class="headerlink" title="7.2.4 使用break退出循环"></a>7.2.4 使用break退出循环</h2><p>break语句用于控制程序流程，可用来控制哪些代码行将执行，哪些代码行不执行，从而让程序按你的要求执行你要执行的代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">message = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	message = <span class="built_in">input</span>(<span class="string">&quot;please input something:&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> message == <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">f&quot;your input the message is :<span class="subst">&#123;message&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">please input something:hello </span><br><span class="line">your input the message is :hello </span><br><span class="line"></span><br><span class="line">please input something:python</span><br><span class="line">your input the message is :python</span><br><span class="line"></span><br><span class="line">please input something:world</span><br><span class="line">your input the message is :world</span><br><span class="line"></span><br><span class="line">please input something:quit</span><br></pre></td></tr></table></figure>
<h2 id="7-2-5-在循环中使用continue"><a href="#7-2-5-在循环中使用continue" class="headerlink" title="7.2.5 在循环中使用continue"></a>7.2.5 在循环中使用continue</h2><p>要返回循环开头，并根据条件测试结果决定是否继续执行循环，可使用continue语句，它不像break语句那样不再执行余下的代码并退出整个循环。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cur_number = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> cur_number &lt; <span class="number">10</span>:</span><br><span class="line">	cur_number += <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span>(cur_number % <span class="number">2</span> == <span class="number">0</span>):</span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">	print(cur_number)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">9</span><br></pre></td></tr></table></figure>
<h2 id="7-2-6-避免无限循环"><a href="#7-2-6-避免无限循环" class="headerlink" title="7.2.6 避免无限循环"></a>7.2.6 避免无限循环</h2><p>如果程序陷入无限循环，可按Ctrl+C，也可关闭显示程序输出的终端窗口</p>
<h1 id="7-3使用while循环处理列表和字典"><a href="#7-3使用while循环处理列表和字典" class="headerlink" title="7.3使用while循环处理列表和字典"></a>7.3使用while循环处理列表和字典</h1><p>for循环是一种遍历列表的有效方式，但不应在for循环中修改列表，否则将导致Python难以跟踪其中的元素。要在遍历列表的同时对其进行修改，可使用while循环。</p>
<h2 id="7-3-1-在列表之间移动元素"><a href="#7-3-1-在列表之间移动元素" class="headerlink" title="7.3.1 在列表之间移动元素"></a>7.3.1 在列表之间移动元素</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">unconfirmed_users = [<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;brian&#x27;</span>, <span class="string">&#x27;candace&#x27;</span>]</span><br><span class="line">confirmed_users = []</span><br><span class="line">print(unconfirmed_users)</span><br><span class="line">print(confirmed_users)</span><br><span class="line"><span class="keyword">while</span> unconfirmed_users:</span><br><span class="line">	cur_user = unconfirmed_users.pop()</span><br><span class="line">	print(<span class="string">f&quot;verifying user:<span class="subst">&#123;cur_user.title()&#125;</span>&quot;</span>)</span><br><span class="line">	confirmed_users.append(cur_user)</span><br><span class="line">print(unconfirmed_users)</span><br><span class="line">print(confirmed_users)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[&#39;alice&#39;, &#39;brian&#39;, &#39;candace&#39;]</span><br><span class="line">[]</span><br><span class="line">verifying user:Candace</span><br><span class="line">verifying user:Brian</span><br><span class="line">verifying user:Alice</span><br><span class="line">[]</span><br><span class="line">[&#39;candace&#39;, &#39;brian&#39;, &#39;alice&#39;]</span><br></pre></td></tr></table></figure>
<h2 id="7-3-2删除为特定值的所有列表元素"><a href="#7-3-2删除为特定值的所有列表元素" class="headerlink" title="7.3.2删除为特定值的所有列表元素"></a>7.3.2删除为特定值的所有列表元素</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pets = [<span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;goldfish&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;rabbit&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>]</span><br><span class="line">print(pets)</span><br><span class="line"><span class="keyword">while</span> <span class="string">&#x27;cat&#x27;</span> <span class="keyword">in</span> pets:</span><br><span class="line">	pets.remove(<span class="string">&#x27;cat&#x27;</span>)</span><br><span class="line">print(pets)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#39;dog&#39;, &#39;cat&#39;, &#39;dog&#39;, &#39;goldfish&#39;, &#39;cat&#39;, &#39;rabbit&#39;, &#39;cat&#39;]</span><br><span class="line">[&#39;dog&#39;, &#39;dog&#39;, &#39;goldfish&#39;, &#39;rabbit&#39;]</span><br></pre></td></tr></table></figure>
<h2 id="7-3-3-使用用户输入来填充字典"><a href="#7-3-3-使用用户输入来填充字典" class="headerlink" title="7.3.3 使用用户输入来填充字典"></a>7.3.3 使用用户输入来填充字典</h2><p>可使用while循环提示用户输入任意多的信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">responses = &#123;&#125;</span><br><span class="line">polling_active = <span class="literal">True</span><span class="comment">#设置一个标志，指出调查是否继续</span></span><br><span class="line"><span class="keyword">while</span> polling_active:</span><br><span class="line">    name = <span class="built_in">input</span>(<span class="string">&quot;\nWhat is your name?&quot;</span>)</span><br><span class="line">    response = <span class="built_in">input</span>(<span class="string">&quot;which mountain would you like to climb someday?&quot;</span>)</span><br><span class="line">    responses[name] = response</span><br><span class="line">    </span><br><span class="line">    repeat = <span class="built_in">input</span>(<span class="string">&quot;would you like to let another person respond?(yes/no)&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> repeat == <span class="string">&#x27;no&#x27;</span>:</span><br><span class="line">        polling_active = <span class="literal">False</span></span><br><span class="line">print(<span class="string">&quot;\n---poll results---&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> name, response <span class="keyword">in</span> responses.items():</span><br><span class="line">    print(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span> would like to climb <span class="subst">&#123;response&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">What is your name?zhangsan</span><br><span class="line"></span><br><span class="line">which mountain would you like to climb someday?Deanli</span><br><span class="line"></span><br><span class="line">would you like to let another person respond?(yes&#x2F;no)yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">What is your name?lisi</span><br><span class="line"></span><br><span class="line">which mountain would you like to climb someday?Devil&#96;s Thumb</span><br><span class="line"></span><br><span class="line">would you like to let another person respond?(yes&#x2F;no)no</span><br><span class="line"></span><br><span class="line">---poll results---</span><br><span class="line">zhangsan would like to climb Deanli</span><br><span class="line">lisi would like to climb Devil&#96;s Thumb</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/08/Java_Notes/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/08/Java_Notes/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" class="post-title-link" itemprop="url">Java集合框架</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-06-08 14:43:03 / 修改时间：14:41:21" itemprop="dateCreated datePublished" datetime="2021-06-08T14:43:03+08:00">2021-06-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Java高级教程</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/06/08/Java_Notes/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/06/08/Java_Notes/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h1><p>集合框架被设计成要满足以下几个目标。</p>
<ul>
<li>该框架必须是高性能的。基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的。</li>
<li>该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。</li>
<li>对一个集合的扩展和适应必须是简单的。</li>
</ul>
<p>为此，整个集合框架就围绕一组标准接口而设计。你可以直接使用这些接口的标准实现，诸如：LinkedList，HashSet和TreeSet等，除此之外你也可以通过这些接口实现自己的集合。</p>
<p><img src="D:/Typora/https:cdn.jsdelivr.net/gh/TheNormalPeople/BlogImage/img/20210531163613.gif" alt="Java集合框架"></p>
<p>从上面集合框架图可以看到，Java集合框架主要包括两种类型的容器</p>
<ul>
<li><strong>集合（Collection）</strong>：存储一个元素集合。Collection接口又有三种子类型。<ul>
<li>List</li>
<li>Set</li>
<li>Queue</li>
</ul>
</li>
<li><strong>图（Map）</strong>：存储键-值对映射。</li>
</ul>
<p>集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容。</p>
<ul>
<li><strong>接口</strong>：是代表集合的抽象数据类型。例如：Collection、List、Set、Map等。之所以定义多个接口，是为了以不同的方式操作集合对象。</li>
<li><strong>实现（类）</strong>：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。</li>
<li><strong>算法</strong>：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。</li>
</ul>
<p>除了集合，该框架也定义了集合Map接口和类。Map里存储的是键-值对。尽管不是集合，但是他们完全整合在集合中。</p>
<p><img src="java笔记图片/集合框架体系.png" alt="集合框架体系"></p>
<p>java集合框架位于java.util包中， 所以当使用集合框架的时候需要进行导包。</p>
<h2 id="集合接口"><a href="#集合接口" class="headerlink" title="集合接口"></a>集合接口</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">接口描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>Collection接口</strong><br />Collection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素，Java不提供直接继承自Collection的类，只提供继承于的子接口（如List和Set）。<br />Collection接口存储一组不唯一，无序的对象。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>List接口</strong><br />List接口是一个有序的Collection，使用此接口能够精确的控制每个元素插入的位置，能够通过索引（元素在List中位置，类似于数组的下标）来访问List中的元素，第一个元素的索引为0，而且允许有相同的元素。<br />List接口存储一组不唯一，有序（插入顺序）的对象。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>Set接口</strong><br />Set具有与Collection完全一样的接口，只是行为上不同，Set不保存重复的元素。<br />Set接口存储一组唯一，无序的对象。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>SortedSet接口</strong><br />继承于Set，保存有序的集合。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><strong>Map接口</strong><br />Map接口存储一组键值对象，提供key（键）到value（值）的映射。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><strong>Map.Entry接口</strong><br />描述在一个Map中的一个元素（键-值对）。是一个Map的内部接口。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"><strong>SortedMap接口</strong><br />继承于Map，使Key保持在升序排列。</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left"><strong>Enumeration接口</strong><br />这是一个传统的接口和定义的方法，通过它可以枚举（一次获得一个）对象集合中的元素。这个传统接口已被迭代器取代。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Set和List的区别</strong></p>
<ul>
<li>Set接口实例存储是无序的、不重复的数据。List接口实例存储的是有序的、可以重复的元素。</li>
<li>Set检索效率低下，删除和插入效率高，插入和删除不会引起位置改变。</li>
<li>List和数组类似，可以动态增长，根据实际存储的数据长度自动增长List的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变。</li>
</ul>
<h2 id="集合实现类（集合类）"><a href="#集合实现类（集合类）" class="headerlink" title="集合实现类（集合类）"></a>集合实现类（集合类）</h2><p>Java提供了一套实现了Collection接口的标准集合类。其中一些是具体类，这些类可以直接拿来使用，而另外一些是抽象类，提供了接口的部分实现。</p>
<p>标准集合类汇总于下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>类描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><strong>AbstractCollection</strong><br />实现了大部分的集合接口。</td>
</tr>
<tr>
<td>2</td>
<td><strong>AbstractList</strong><br />继承于AbstractCollection并且实现了大部分List接口。</td>
</tr>
<tr>
<td>3</td>
<td><strong>AbstractSequentialList</strong><br />继承于AbstractList，提供了对数据元素的链式访问而不是随机访问。</td>
</tr>
<tr>
<td>4</td>
<td><strong>LinkedList</strong><br />该类实现了List接口，允许有null（空）元素。主要用于创建链表数据结构，该类没有同步方法，如果多个线程同时访问一个List，则必须自己实现访问同步，解决方法就是在创建List时候构造一个同步的List。例如：<code>List list = Collection.synchronizedList(newLinkedList(...));</code><br />LinkedList查找效率低。</td>
</tr>
<tr>
<td>5</td>
<td><strong>ArrayList</strong><br />该类也实现了List接口，实现了可变大小的数组，随机访问和遍历元素时，提供更好的性能。该类也是非同步的，在多线程的情况下不要使用。ArrayList增长当前长度的50%，插入删除效率低。</td>
</tr>
<tr>
<td>6</td>
<td><strong>AbstractSet</strong><br />继承于AbstractCollection并且实现了大部分Set接口。</td>
</tr>
<tr>
<td>7</td>
<td><strong>HashSet</strong><br />该类实现了Set接口，不允许出现重复元素，不保证集合中元素的顺序，允许包含值为null的元素，但最多只能一个。</td>
</tr>
<tr>
<td>8</td>
<td><strong>LinkedHashSet</strong><br />具有可预知迭代顺序的Set接口的哈希表和链接列表实现。</td>
</tr>
<tr>
<td>9</td>
<td><strong>TreeSet</strong><br />该类实现了Set接口，可以实现排序等功能。</td>
</tr>
<tr>
<td>10</td>
<td><strong>AbstractMap</strong><br />实现了大部分的Map接口。</td>
</tr>
<tr>
<td>11</td>
<td><strong>HashMap</strong><br />HashMap是一个散列表，它存储的内容是键值对（key-value）映射。<br />该类实现了Map接口，根据键的HashCode值存储数据，具有很快的访问速度，最多允许一条记录的键为null，不支持线程同步。</td>
</tr>
<tr>
<td>12</td>
<td><strong>TreeMap</strong><br />继承了AbstractMap，并且使用一棵树。</td>
</tr>
<tr>
<td>13</td>
<td><strong>WeakHashMap</strong><br />继承AbstractMap类，使用弱秘钥的哈希表。</td>
</tr>
<tr>
<td>14</td>
<td><strong>LinkedHashMap</strong><br />继承于HashMap，使用元素的自然顺序对元素进行排序。</td>
</tr>
<tr>
<td>15</td>
<td><strong>IdentityHashMap</strong><br />继承AbstractMap类，比较文档时使用引用相等。</td>
</tr>
</tbody>
</table>
</div>
<p>java.util包中定义的类，如下所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>类描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><strong>Vector</strong><br />该类和ArrayList非常相似，但是该类是同步的，可以用在多线程的情况，该类允许设置默认的增长长度，默认扩容方式为原来的2倍。</td>
</tr>
<tr>
<td>2</td>
<td><strong>Stack</strong><br />栈是Vector的一个子类，它实现了一个标准的后进先出的栈。</td>
</tr>
<tr>
<td>3</td>
<td><strong>Dictionary</strong><br />Dictionary类是一个抽象类，用来存储键-值对，作用和Map类相似。</td>
</tr>
<tr>
<td>4</td>
<td><strong>Hashtable</strong><br />Hashtable是Dictionary（字典）类的子类，位于java.util包中。</td>
</tr>
<tr>
<td>5</td>
<td><strong>Properties</strong><br />Properties继承于Hashtable，表示一个持久的属性集，属性列表中每个键及其对应的值都是一个字符串。</td>
</tr>
<tr>
<td>6</td>
<td><strong>BitSet</strong><br />一个BitSet类创建一种特殊类型的数组来保存位值。BitSet中数组大小会随需要增加。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="集合算法"><a href="#集合算法" class="headerlink" title="集合算法"></a>集合算法</h2><p>集合框架定义了几种算法，可用于集合和映射。这些算法被定义为集合类的静态方法。</p>
<p>在尝试比较不兼容的类型时，一些方法能够抛出ClassCastException异常。当试图修改一个不可修改的集合时，抛出UnsupportedOperationException异常。</p>
<p>集合定义三个静态的变量：EMPTY_SET，EMPTY_LIST，EMPTY_MAP。这些变量都不可改变。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>算法描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><strong>Collection Algorithms</strong><br/>这里是一个列表中的所有算法实现。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="如何使用迭代器"><a href="#如何使用迭代器" class="headerlink" title="如何使用迭代器"></a>如何使用迭代器</h2><p>通常情况下，你会希望遍历一个集合中的元素。例如，显示集合中的每个元素。</p>
<p>一般遍历数组都是采用for循环或者增强for循环，这两个方法也可以用在集合框架，但是还有一种方法是采用迭代器遍历集合框架，它是一个对象，实现了Iterator接口或ListIterator接口。</p>
<p>迭代器，能够通过循环来得到或删除集合的元素。ListIterator继承了Iterator，以允许双向遍历列表和修改元素。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>迭代器方法描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>使用Java Iterator<br />这里通过实例列出Iterator和ListIterator接口提供的所有方法。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="遍历ArrayList"><a href="#遍历ArrayList" class="headerlink" title="遍历ArrayList"></a>遍历ArrayList</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;hahahaha&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一种遍历方法使用for-each遍历List</span></span><br><span class="line">        <span class="keyword">for</span>(String str : list)&#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种遍历，把链表变为数组相关的内容进行遍历</span></span><br><span class="line">        String[] strArray = <span class="keyword">new</span> String[list.size()];</span><br><span class="line">        list.toArray(strArray); <span class="comment">//将list变为String数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strArray.length; i++)&#123;</span><br><span class="line">            System.out.println(strArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三种遍历，使用迭代器进行相关遍历</span></span><br><span class="line">        Iterator&lt;String&gt; iter = list.iterator(); <span class="comment">//将list的迭代器赋给iter</span></span><br><span class="line">        <span class="keyword">while</span>(iter.hasNext())&#123;<span class="comment">//判断下一个元素之后有值</span></span><br><span class="line">            System.out.println(iter.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解析</strong>：三种方法都是采用遍历ArrayList集合，第三种方法是采用迭代器的方法，该方法可以不用担心在遍历的过程中会超出集合的长度。</p>
<h3 id="遍历Map"><a href="#遍历Map" class="headerlink" title="遍历Map"></a>遍历Map</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Map_IteratorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;value3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一种：普遍使用，二次取值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;通过Map.KeySet遍历key和value：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(String key : map.keySet())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;key = &quot;</span> + key + <span class="string">&quot; and value = &quot;</span> + map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种：</span></span><br><span class="line">        System.out.println(<span class="string">&quot;通过Map.entrySet使用iterator遍历key和value&quot;</span>);</span><br><span class="line">        Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            Map.Entry&lt;String, String&gt; entry = it.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;key = &quot;</span> + entry.getKey() + <span class="string">&quot; and value = &quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三种：推荐，尤其是容量大时</span></span><br><span class="line">        System.out.println(<span class="string">&quot;通过Map.entrySet遍历key和value&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String, String&gt; entry : map.entrySet())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;key = &quot;</span> + entry.getKey() + <span class="string">&quot; and value = &quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第四种</span></span><br><span class="line">        System.out.println(<span class="string">&quot;通过Map.values()遍历所有的value，但不能遍历key&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String v : map.values())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;value = &quot;</span> + v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="如果使用比较器"><a href="#如果使用比较器" class="headerlink" title="如果使用比较器"></a>如果使用比较器</h2><p>TreeSet和TreeMap的按照排序顺序来存储元素，然而，这是通过比较器来精确定义按照什么样的排序顺序。</p>
<p>这个接口可以让我们以不同的方式来排序一个集合。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>比较器方法描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>使用Java Comparator<br />这里通过实例列出Comparator接口提供的所有方法</td>
</tr>
</tbody>
</table>
</div>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java集合框架为程序员提供了预先包装的数据结构和算法来操作它们。</p>
<p>集合是一个对象，可容纳其他对象的引用。集合接口声明对每一种类型的集合可以执行的操作。</p>
<p>集合框架的类和接口均在java.util包中。</p>
<p>任何对象加入集合类后，自动转变为Object类型，所以在取出的是否，需要进行强制类型转换。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/08/Data%20_Competition/Python_Foundation/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%97%E5%85%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/08/Data%20_Competition/Python_Foundation/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%97%E5%85%B8/" class="post-title-link" itemprop="url">第六章 字典</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-08 14:42:31" itemprop="dateCreated datePublished" datetime="2021-06-08T14:42:31+08:00">2021-06-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-02 21:52:50" itemprop="dateModified" datetime="2021-07-02T21:52:50+08:00">2021-07-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">数据竞赛</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/06/08/Data%20_Competition/Python_Foundation/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%97%E5%85%B8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/06/08/Data%20_Competition/Python_Foundation/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%97%E5%85%B8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="6-1-一个简单的字典"><a href="#6-1-一个简单的字典" class="headerlink" title="6.1 一个简单的字典"></a>6.1 一个简单的字典</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">human_0 = &#123;<span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;age&#x27;</span> : <span class="number">24</span>&#125;</span><br><span class="line">print(human_0[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line">print(human_0[<span class="string">&#x27;age&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zhangsan</span><br><span class="line">24</span><br></pre></td></tr></table></figure>
<h1 id="6-2-使用字典"><a href="#6-2-使用字典" class="headerlink" title="6.2 使用字典"></a>6.2 使用字典</h1><p>在Python中，<strong>字典</strong>是一系列键值对。每个<strong>键</strong>都与一个值相关联，可使用键来访问相关联的值。与键相关联的值可以是数、字符串、列表乃至字典。事实上，可将任何Python对象用作字典中的值。</p>
<p>在Python中，字典用放在花括号（{}）中的一系列键值对表示。键值对是两个相关联的值。指定键时，Python将返回与之相关联的值。键和值之间用冒号分隔，而键值对之间用逗号分隔。</p>
<h2 id="6-2-1-访问字典中的值"><a href="#6-2-1-访问字典中的值" class="headerlink" title="6.2.1 访问字典中的值"></a>6.2.1 访问字典中的值</h2><p>要获取与键相关联的值，可依次指定字典名和放在方括号内的键</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">student_1 = &#123;<span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;lisi&#x27;</span>, <span class="string">&#x27;age&#x27;</span> : <span class="number">25</span>&#125;</span><br><span class="line">print(student_1[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line">print(student_1[<span class="string">&#x27;age&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lisi</span><br><span class="line">25</span><br></pre></td></tr></table></figure>
<h2 id="6-2-2-添加键值对"><a href="#6-2-2-添加键值对" class="headerlink" title="6.2.2 添加键值对"></a>6.2.2 添加键值对</h2><p>字典一种动态结构，可随时在其中添加键值对。要添加键值对，可依次指定字典名、用方括号括起的键和相关联的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">student_1 = &#123;<span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;lisi&#x27;</span>, <span class="string">&#x27;age&#x27;</span> : <span class="number">25</span>&#125;</span><br><span class="line">print(student_1)</span><br><span class="line">student_1[<span class="string">&#x27;height&#x27;</span>] = <span class="number">175</span></span><br><span class="line">print(student_1)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#39;name&#39; : &#39;lisi&#39;, &#39;age&#39; : 25&#125;</span><br><span class="line">&#123;&#39;name&#39; : &#39;lisi&#39;, &#39;age&#39; : 25, &#39;height&#39; : 175&#125;</span><br></pre></td></tr></table></figure>
<p>在Python3.7中，字典中元素的排列顺序与定义时相同。如果将字典打印出来或遍历其元素，将发现元素的排列顺序与添加顺序相同。</p>
<h2 id="6-2-3-先创建一个空字典"><a href="#6-2-3-先创建一个空字典" class="headerlink" title="6.2.3 先创建一个空字典"></a>6.2.3 先创建一个空字典</h2><p>在空字典中添加键值对有时候可提供便利，而有时候必须这样做。为此，可先使用一对空花括号定义一个字典，再分行添加各个键值对。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">student_1 = &#123;&#125;</span><br><span class="line">student_1[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;zhangsan&#x27;</span></span><br><span class="line">student_1[<span class="string">&#x27;age&#x27;</span>] = <span class="number">24</span></span><br><span class="line">student_1[<span class="string">&#x27;height&#x27;</span>] = <span class="number">175</span></span><br><span class="line">print(student_1)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#39;name&#39; : &#39;zhangsan&#39;, &#39;age&#39; : 24, &#39;height&#39; : 175&#125;</span><br></pre></td></tr></table></figure>
<p>使用字典来存储用户提供的数据或在编写能自动生成大量键值对的代码时，通常需要先定义一个空字典。</p>
<h2 id="6-2-4-修改字典中的值"><a href="#6-2-4-修改字典中的值" class="headerlink" title="6.2.4 修改字典中的值"></a>6.2.4 修改字典中的值</h2><p>要修改字典中的值，可依次指定字典名、用方括号括起的键，以及与该键相关联的新值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">student_1 = &#123;<span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;age&#x27;</span> : <span class="number">24</span>, <span class="string">&#x27;height&#x27;</span> : <span class="number">175</span>&#125;</span><br><span class="line">print(student_1)</span><br><span class="line">student_1[<span class="string">&#x27;age&#x27;</span>] = <span class="number">25</span></span><br><span class="line">print(student_1)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#39;name&#39; : &#39;zhangsan&#39;, &#39;age&#39; : 24, &#39;height&#39; : 175&#125;</span><br><span class="line">&#123;&#39;name&#39; : &#39;zhangsan&#39;, &#39;age&#39; : 25, &#39;height&#39; : 175&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-2-5删除键值对"><a href="#6-2-5删除键值对" class="headerlink" title="6.2.5删除键值对"></a>6.2.5删除键值对</h2><p>对于字典中不再需要的信息，可使用del语句将相应的键值对彻底删除。使用del语句时，必须指定字典名和要删除的键。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">student_1 = &#123;<span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;age&#x27;</span> : <span class="number">24</span>, <span class="string">&#x27;height&#x27;</span> : <span class="number">175</span>&#125;</span><br><span class="line">print(student_1)</span><br><span class="line"><span class="keyword">del</span> student_1[<span class="string">&#x27;height&#x27;</span>]</span><br><span class="line">print(student_1)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#39;name&#39; : &#39;zhangsan&#39;, &#39;age&#39; : 24, &#39;height&#39; : 175&#125;</span><br><span class="line">&#123;&#39;name&#39; : &#39;zhangsan&#39;, &#39;age&#39; : 24&#125;</span><br></pre></td></tr></table></figure>
<p>删除的键值对会永远消失。</p>
<h2 id="6-2-6-由类似对象组成的字典"><a href="#6-2-6-由类似对象组成的字典" class="headerlink" title="6.2.6 由类似对象组成的字典"></a>6.2.6 由类似对象组成的字典</h2><p>在前面的示例中，字典存储的是一个对象的多种信息，当也可以使用字典来存储众多对象的同一种信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">favorite_languages = &#123;<span class="string">&#x27;jen&#x27;</span> : <span class="string">&#x27;Pythone&#x27;</span>, <span class="string">&#x27;sarah&#x27;</span> : <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;edward&#x27;</span> : <span class="string">&#x27;Ruby&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-2-7-使用get-来访问值"><a href="#6-2-7-使用get-来访问值" class="headerlink" title="6.2.7 使用get()来访问值"></a>6.2.7 使用get()来访问值</h2><p>使用放在方括号内的键从字典中获取感兴趣的值时，可能会引发问题：如果指定的键不存在就会出错。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">student_1 = &#123;<span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;age&#x27;</span> : <span class="number">24</span>&#125;</span><br><span class="line">print(student_1[<span class="string">&#x27;height&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#1&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    print(student_1[&#39;height&#39;])</span><br><span class="line">KeyError: &#39;height&#39;</span><br></pre></td></tr></table></figure>
<p>方法get()的第一个参数用于指定键，是必不可少的；第二个参数为指定的键不存在时要返回的值，是可选的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">student_1 = &#123;<span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;age&#x27;</span> : <span class="number">24</span>&#125;</span><br><span class="line">studen_height = studen_1.get(<span class="string">&#x27;height&#x27;</span>, <span class="string">&#x27;There is no key-value&#x27;</span>)</span><br><span class="line">print(student_1[<span class="string">&#x27;height&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">There is no key-value</span><br></pre></td></tr></table></figure>
<p>如果指定的键有可能不存在，应考虑使用方法get()，而不要使用方括号表示法。</p>
<p>调用get()时，如果没有指定第二个参数且指定的键不存在，Python将返回值None。这个特殊值表示没有相应的值。None并非错误，而是一个表示所需值不存在的特殊值。</p>
<h1 id="6-3-遍历字典"><a href="#6-3-遍历字典" class="headerlink" title="6.3 遍历字典"></a>6.3 遍历字典</h1><p>字典可用于以各种方式存储信息，因此有多种遍历方式：可遍历字典的所有键值对，也可仅遍历键或值。</p>
<h2 id="6-3-1-遍历所有键值对"><a href="#6-3-1-遍历所有键值对" class="headerlink" title="6.3.1 遍历所有键值对"></a>6.3.1 遍历所有键值对</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">student_1 = &#123;<span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;age&#x27;</span> : <span class="number">24</span>, <span class="string">&#x27;height&#x27;</span> : <span class="number">175</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> student_1.items():</span><br><span class="line">	print(<span class="string">f&quot;key:<span class="subst">&#123;key&#125;</span>&quot;</span>)</span><br><span class="line">	print(<span class="string">f&quot;value:<span class="subst">&#123;value&#125;</span>\n&quot;</span>)</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">key:name</span><br><span class="line">value:zhangsan</span><br><span class="line"></span><br><span class="line">key:age</span><br><span class="line">value:24</span><br><span class="line"></span><br><span class="line">key:height</span><br><span class="line">value:175</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="6-3-2-遍历字典中的所有键"><a href="#6-3-2-遍历字典中的所有键" class="headerlink" title="6.3.2 遍历字典中的所有键"></a>6.3.2 遍历字典中的所有键</h2><p>在不需要使用字典中的值是，方法keys()很有用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">student_1 = &#123;<span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;age&#x27;</span> : <span class="number">24</span>, <span class="string">&#x27;height&#x27;</span> : <span class="number">175</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> student_1.keys():</span><br><span class="line">	print(key.title())</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Name</span><br><span class="line">Age</span><br><span class="line">Height</span><br></pre></td></tr></table></figure>
<p>遍历字典时，会默认遍历所有的键。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">student_1 = &#123;<span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;age&#x27;</span> : <span class="number">24</span>, <span class="string">&#x27;height&#x27;</span> : <span class="number">175</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> student_1:</span><br><span class="line">	print(key.title())</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Name</span><br><span class="line">Age</span><br><span class="line">Height #输出结果与使用方法keys()一致。</span><br></pre></td></tr></table></figure>
<p>方法keys()并非只能用于遍历：实际上，它返回一个列表，其中包含字典中的所有键。</p>
<h2 id="6-3-3-按特定顺序遍历字典中的所有键"><a href="#6-3-3-按特定顺序遍历字典中的所有键" class="headerlink" title="6.3.3 按特定顺序遍历字典中的所有键"></a>6.3.3 按特定顺序遍历字典中的所有键</h2><p>要以特定顺序返回元素，一种办法是在for循环中对返回的键进行排序。为此，可使用函数sorted()来获得按特定顺序排列的键列表的副本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">student_1 = &#123;<span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;age&#x27;</span> : <span class="number">24</span>, <span class="string">&#x27;height&#x27;</span> : <span class="number">175</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> <span class="built_in">sorted</span>(student_1.keys()):</span><br><span class="line">	print(key.title())</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Age</span><br><span class="line">Name</span><br><span class="line">Height</span><br></pre></td></tr></table></figure>
<h2 id="6-3-4-遍历字典中的所有值"><a href="#6-3-4-遍历字典中的所有值" class="headerlink" title="6.3.4 遍历字典中的所有值"></a>6.3.4 遍历字典中的所有值</h2><p>如果主要对字典包含的值感兴趣，可使用方法values()来返回一个值列表，不包含任何键。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">student_1 = &#123;<span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;age&#x27;</span> : <span class="number">24</span>, <span class="string">&#x27;height&#x27;</span> : <span class="number">175</span>&#125;</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> student_1.values():</span><br><span class="line">	print(value)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zhang</span><br><span class="line">24</span><br><span class="line">175</span><br></pre></td></tr></table></figure>
<p>这种做法提取字典中所有的值，而没有考虑是否重复。涉及的值很少时，这也许不是问题，但如果被调查者很多，最终的列表可能包含大量重复项。为剔除重复项，可使用<strong>集合(set)</strong>。集合中的每个元素都必须是独一无二的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">languages = &#123;<span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;C++&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>&#125;</span><br><span class="line">print(languages)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#39;Python&#39;, &#39;Java&#39;, &#39;C++&#39;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6-4-嵌套"><a href="#6-4-嵌套" class="headerlink" title="6.4 嵌套"></a>6.4 嵌套</h1><p>有时候，需要将一系列字典存储在列表中，或将列表作为值存储在字典中，这称为<strong>嵌套</strong>。</p>
<h2 id="6-4-1-字典列表"><a href="#6-4-1-字典列表" class="headerlink" title="6.4.1 字典列表"></a>6.4.1 字典列表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">student_1 = &#123;<span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;age&#x27;</span> : <span class="number">24</span>, <span class="string">&#x27;height&#x27;</span> : <span class="number">175</span>&#125;</span><br><span class="line">student_2 = &#123;<span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;lisi&#x27;</span>, <span class="string">&#x27;age&#x27;</span> : <span class="number">25</span>, <span class="string">&#x27;height&#x27;</span> : <span class="number">178</span>&#125;</span><br><span class="line">student_3 = &#123;<span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;wangwu&#x27;</span>, <span class="string">&#x27;age&#x27;</span> : <span class="number">26</span>, <span class="string">&#x27;height&#x27;</span> : <span class="number">180</span>&#125;</span><br><span class="line">students = [student_1, student_2, student_3]</span><br><span class="line"><span class="keyword">for</span> student <span class="keyword">in</span> students:</span><br><span class="line">    print(student)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#39;name&#39; : &#39;zhangsan&#39;, &#39;age&#39; : 24, &#39;height&#39; : 175&#125;</span><br><span class="line">&#123;&#39;name&#39; : &#39;lisi&#39;, &#39;age&#39; : 25, &#39;height&#39; : 178&#125;</span><br><span class="line">&#123;&#39;name&#39; : &#39;wangwu&#39;, &#39;age&#39; : 26, &#39;height&#39; : 180&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-4-2-在字典中存储列表"><a href="#6-4-2-在字典中存储列表" class="headerlink" title="6.4.2 在字典中存储列表"></a>6.4.2 在字典中存储列表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">favorite_languages = &#123;</span><br><span class="line">	<span class="string">&#x27;zhangsan&#x27;</span> : [<span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>],</span><br><span class="line">	<span class="string">&#x27;lisi&#x27;</span> : [<span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;C&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;wangwu&#x27;</span> : [<span class="string">&#x27;C++&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>]</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">for</span> name, languages <span class="keyword">in</span> favorite_languages.items():</span><br><span class="line">    print(<span class="string">f&quot;<span class="subst">&#123;name.title()&#125;</span>`s favorite languages are:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> language <span class="keyword">in</span> languages:</span><br><span class="line">        print(<span class="string">f&quot;\t<span class="subst">&#123;language&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Zhangsan&#96;s favorite languages are:</span><br><span class="line">	Python</span><br><span class="line">	Java</span><br><span class="line">Lisi&#96;s favorite languages are:</span><br><span class="line">	Java</span><br><span class="line">	C</span><br><span class="line">Wangwu&#96;s favorite languages are:</span><br><span class="line">	C++</span><br><span class="line">	Python</span><br></pre></td></tr></table></figure>
<h2 id="6-4-3-在字典中存储字典"><a href="#6-4-3-在字典中存储字典" class="headerlink" title="6.4.3 在字典中存储字典"></a>6.4.3 在字典中存储字典</h2><p>与在字典中存储列表类似，这里就不做演示。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/08/Statistical_Learning_Methods_Notes/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%86%B3%E7%AD%96%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/08/Statistical_Learning_Methods_Notes/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%86%B3%E7%AD%96%E6%A0%91/" class="post-title-link" itemprop="url">第五章 决策树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-06-08 10:48:14 / 修改时间：10:47:31" itemprop="dateCreated datePublished" datetime="2021-06-08T10:48:14+08:00">2021-06-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">统计学习方法</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/06/08/Statistical_Learning_Methods_Notes/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%86%B3%E7%AD%96%E6%A0%91/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/06/08/Statistical_Learning_Methods_Notes/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%86%B3%E7%AD%96%E6%A0%91/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="5-1-决策树模型与学习"><a href="#5-1-决策树模型与学习" class="headerlink" title="5.1 决策树模型与学习"></a>5.1 决策树模型与学习</h1><p>决策树（decision tree）是一种基本的分类与回归方法。</p>
<p>决策树学习通常包括$3$个步骤：特征选择、决策树的生成和决策树的修剪。</p>
<h2 id="5-1-1-决策树模型"><a href="#5-1-1-决策树模型" class="headerlink" title="5.1.1 决策树模型"></a>5.1.1 决策树模型</h2><p><strong>定义5.1（决策树）</strong>  分类决策树模型是一种描述对实例进行分类的树形结构。决策树由<strong>结点（node）</strong>和<strong>有向边（directed edge）</strong>组成。结点有两种类型：<strong>内部结点（internal node）</strong>和<strong>叶结点（leaf node）</strong>。内部结点表示一个特征或属性，叶结点表示一个类。</p>
<p>用决策树分类，从根结点开始，对实例的某一特征进行测试，根据测试结果，将实例分配到其子结点；这时，每一个子结点对应着该特征的一个取值。如此递归地对实例进行测试并分配，直至达到叶结点。最后将实例分到叶结点的类中。</p>
<h2 id="5-1-2-决策树与if-then规则"><a href="#5-1-2-决策树与if-then规则" class="headerlink" title="5.1.2 决策树与if-then规则"></a>5.1.2 决策树与if-then规则</h2><p>可以将决策树看成一个if-then规则的集合。将决策树转换成if-then规则的过程是这样的：</p>
<ul>
<li>由决策树的根结点到叶结点的每一条路径构建一条规则；</li>
<li>路径上内部结点的特征对应着规则的条件，而叶结点的类对应着规则的结论。</li>
</ul>
<p>决策树的路径或其对应的if-then规则集合具有一个重要的性质：<strong>互斥并且完备</strong>。这就是说，每一个实例都被一条路径或一条规则所覆盖，而且只被一条路径或一条规则所覆盖。这里所谓覆盖是指实例的特征与路径上的特征一致或实例满足规则的条件。</p>
<h2 id="5-1-3-决策树与条件概率分布"><a href="#5-1-3-决策树与条件概率分布" class="headerlink" title="5.1.3 决策树与条件概率分布"></a>5.1.3 决策树与条件概率分布</h2><p>决策树还表示给定特征条件下类的条件概率分布。这一条件概率分布定义在特征空间的一个<strong>划分（partition）</strong>上。将特征空间划分为互不相交的<strong>单元（cell）</strong>或<strong>区域（region）</strong>，并在每个单元定义一个类的概率分布就构成了一个条件概率分布。决策树的一条路径对应于划分中的一个单元。决策树所表示的条件概率分布由各个单元给定条件下类的条件概率分布组成。</p>
<p>假设$X$为表示特征的随机变量，$Y$为表示类的随机变量，那么这个条件概率分布可以表示为$P(Y|X)$。$X$取值于给定划分下单元的集合，$Y$取值于类的集合。</p>
<p>各叶结点（单元）上的条件概率往往偏向某一个类，即属于某一类的概率较大。决策树分类时将该结点的实例强行分到条件概率大的那一类去。</p>
<h2 id="5-1-4-决策树学习"><a href="#5-1-4-决策树学习" class="headerlink" title="5.1.4 决策树学习"></a>5.1.4 决策树学习</h2><p>假设给定训练数据集</p>
<script type="math/tex; mode=display">
D = \{(x_1,y_1),(x_2,y_2),...,(x_N,y_N)\}</script><p>其中，$x_i=(x_i^{(1)},x_i^{(2)},…x_i^{(n)})^T$为输入实例（特征向量），$n$为特征个数，$y_i \in \{1,2,…,K\}$为类标记，$i=1,2,…,N,N$为样本容量。</p>
<p>决策树学习本质上是从训练数据集中归纳出一组分类规则。</p>
<p>与训练数据集不相矛盾的决策树（即能对训练数据进行正确分类的决策树）可能有多个，也可能一个都没有。我们需要的是一个与训练数据矛盾较小的决策树，同时具有很好的泛化能力。</p>
<p>从另一个角度看，决策树学习是由训练数据集估计条件概率模型。基于特征空间划分的类的条件概率模型有无穷多个。我们选择的条件概率模型应该不仅对训练数据有很好的拟合，而且对未知数据有很好的预测。</p>
<p>决策树学习用损失函数表示这一目标。决策树学习的损失函数通常是正则化的极大似然函数。决策树学习的策略是以损失函数为目标函数的最小化。现实中决策树学习算法通常采用启发式方法，近似求解这一最优化问题。这样得到的决策树是<strong>次最优（sub-optimal）</strong>的。</p>
<p>决策树学习的算法通常是一个递归地选择最优特征，并根据该特征对训练数据进行分割，使得对各个子数据集有一个最好的分类过程。这一过程对应着对特征空间的划分，也对应着决策树的构建。</p>
<ul>
<li><p>开始，构建根结点，将所有训练数据都放在根结点。选择一个最优特征，按照这一特征将训练数据集分割成子集，使得各个子集有一个在当前条件下最好的分类。</p>
</li>
<li><p>如果这些子集已经能够被正确分类，那么构建叶结点，并将这些子集分到对应的叶结点中去；</p>
</li>
<li>如果还有子集不能被基本正确分类，那么久对这些子集选择新的最优特征，继续对其进行分割，构建相应的结点。</li>
<li>如此递归下去，直至所有训练数据子集都被基本正确分类，或者没有合适的特征为止。</li>
<li>最后每个子集都被分到叶结点上，即都有了明确的类。</li>
</ul>
<p>以上方法生成的决策树可能对训练数据有很好的分类能力，但对未知的测试数据却未必有很好的分类能力，即可能发生过拟合想象。我们需要对已生成的树自下而上进行剪枝，将树变得跟简单，从而使它具有更好的泛化能力。具体地，就是去掉过于细分的叶结点，使其回退到父结点，甚至更高的结点，然后将父结点或更高的结点改为新的叶结点。</p>
<h1 id="5-2-特征选择"><a href="#5-2-特征选择" class="headerlink" title="5.2 特征选择"></a>5.2 特征选择</h1><h2 id="5-2-1-特征选择问题"><a href="#5-2-1-特征选择问题" class="headerlink" title="5.2.1 特征选择问题"></a>5.2.1 特征选择问题</h2><p>如果利用一个特征进行分类的结果与随机分类的结果没有很大差别，称这个特征是没有分类能力的。经验上扔掉这样的特征对决策树学习的精度影响不大。</p>
<p>特征选择是决定用哪个特征来划分特征空间。通常特征选择的准则是信息增益或信息增益比。</p>
<h2 id="5-2-2-信息增益"><a href="#5-2-2-信息增益" class="headerlink" title="5.2.2 信息增益"></a>5.2.2 信息增益</h2><p><strong>熵（entropy）</strong>是表示随机变量不确定性的度量。</p>
<ul>
<li>设$X$是一个取有限个值的离散随机变量，其概率分布为</li>
</ul>
<script type="math/tex; mode=display">
P(X=x_i) = p_i, \ \ \ i = 1,2,...,n</script><p>​        则随机变量$X$的熵定义为</p>
<script type="math/tex; mode=display">
H(X) = - \sum\limits_{i=1}^{n} p_i \log p_i \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.1)</script><p>​        若$p_i = 0$，则定义$0\log 0 = 0$。通常，式$(5.1)$中的对数以$2$为底或以$e$为底（自然对数）这时熵的单位分别称作<strong>比特（bit）</strong>或<strong>纳特（nat）</strong>。</p>
<p>​        熵只依赖于$X$的分布，而与$X$的取值无关，所以也可将$X$的熵记作$H(p)$，即</p>
<script type="math/tex; mode=display">
H(p) = - \sum\limits_{i=1}^{n} p_i \log p_i \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.2)</script><p>​        熵越大，随机变量的不确定性就越大。从定义可验证</p>
<script type="math/tex; mode=display">
0 \leq H(p) \leq \log n \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.3)</script><ul>
<li>设有随机变量$(X,Y)$，其联合概率分布为<script type="math/tex; mode=display">
P(X=x_i,Y=y_i) = p_{ij},\ \ \ i=1,2,...,n; \ \ \ j = 1,2,...,m</script>条件熵$H(Y|X)$表示在已知随机变量$X$的条件下随机变量$Y$的不确定性。定义为$X$给定条件下$Y$的条件概率分布的熵对$X$的数学期望<script type="math/tex; mode=display">
H(Y|X) = \sum\limits_{i=1}^{n}p_iH(Y|X=x_i) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.5)</script>这里，$p_i=P(X=x_i),i=1,2,…,n$。</li>
</ul>
<p>当熵和条件熵中的概率估计由数据估计（特别是极大似然估计）得到时，所对应的熵与条件熵分别称为<strong>经验熵（empirical entropy）</strong>和<strong>经验条件熵（empirical conditional entropy）</strong>。</p>
<p><strong>信息增益（information gain）</strong>表示得知特征$X$的信息而使得类$Y$的信息的不确定性减少的程度。</p>
<p><strong>定义 5.2（信息增益）</strong>  特征$A$对训练数据集$D$的信息增益$g(D,A)$，定义为集合$D$的经验熵$H(D)$与特征$A$给定条件下$D$的经验条件熵$H(D|A)$之差，即</p>
<script type="math/tex; mode=display">
g(D,A)=H(D)-H(D|A) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.6)</script><p>一般地，熵$H(Y)$与条件熵$H(Y|X)$之差称为<strong>互信息（mutual information）</strong>。决策树学习中的信息增益等价于训练数据集中类与特征的互信息。</p>
<p>给定训练数据集$D$和特征$A$：</p>
<ul>
<li>经验熵$H(D)$，表示对数据集$D$进行分类的不确定性。</li>
<li>经验条件熵$H(D|A)$，表示在特征$A$给定的条件下对数据集$D$进行分类的不确定性。</li>
<li>信息增益$g(D,A)$，表示由于特征$A$而使得对数据集$D$的分类的不确定性减少的程度。</li>
</ul>
<p>显然，对于数据集$D$而言，信息增益依赖于特征，不同的特征往往具有不同的信息增益。信息增益大的特征具有更强的分类能力。</p>
<p>根据信息增益准则的特征选择方法是：对训练数据集（或子集）$D$，计算其每个特征的信息增益，并比较它们的大小，选择信息增益最大的特征。</p>
<p>设训练数据集为$D$，$|D|$表示其样本容量，即样本个数。设有$K$个类$C_k,k=1,2,…,K,$$|C_k|$为属于类$C_k$的样本个数，$\sum\limits_{k=1}^{K}|C_k|=|D|$。设特征$A$有$n$个不同的取值$\{a_1,a_2,…,a_n\}$，根据特征A的取值将$D$划分为$n$个子集$D_1,D_2,…,D_n$，$|D_i|$为$D_i$的样本数，$\sum\limits_{i=1}^{n}|D_i|=|D|$。记子集$D_i$中属于类$C_k$的样本的集合为$D_{ik}$，即$D_{ik} = D_i \bigcap C_k,|D_{ik}|$为$D_{ik}$的样本个数。于是信息增益的算法如下：</p>
<p><strong>算法 5.1（信息增益的算法）</strong></p>
<p><strong>输入</strong>：训练数据集$D$和特征$A$；</p>
<p><strong>输出</strong>：特征$A$对训练数据集$D$的信息增益$g(D,A)$。</p>
<p>​    （1）计算数据集$D$的经验熵$H(D)$</p>
<script type="math/tex; mode=display">
H(D) = - \sum\limits_{k=1}^{K} \frac{|C_k|}{|D|} \log_2 \frac{|C_k|}{|D|}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.7)</script><p>​    （2）计算特征$A$对数据集$D$的经验条件熵$H(D|A)$</p>
<script type="math/tex; mode=display">
H(D|A)=\sum\limits_{i=1}^{n} \frac{|D_i|}{|D|} H(D_i) = -\sum\limits_{i=1}^{n} \frac{|D_i|}{|D|}\sum\limits_{k=1}^{K}\frac{|D_{ik}|}{|D_i|} \log_2 \frac{|D_{ik}|}{|D_i|}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.8)</script><p>​    （3）计算信息增益</p>
<script type="math/tex; mode=display">
g(D,A) = H(D) - H(D|A)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.9)</script><h2 id="5-2-3-信息增益比"><a href="#5-2-3-信息增益比" class="headerlink" title="5.2.3 信息增益比"></a>5.2.3 信息增益比</h2><p>以信息增益作为划分训练数据集的特征，存在偏向于选择取值较多的特征的问题。信息增益比（information gain ratio）可以对这一问题进行校正。</p>
<p><strong>定义 5.3（信息增益比）</strong>  特征$A$对训练数据集$D$的信息增益比$g_R(D,A)$定义为其信息增益$g(D,A)$与训练数据集$D$关于特征$A$的值的熵$H_A(D)$之比，即</p>
<script type="math/tex; mode=display">
g_R(D,A) = \frac{g(D,A)}{H_A(D)} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.10)</script><p>其中，$H_A(D) = -\sum\limits_{i=1}^{n}\frac{|D_i|}{|D|} \log_2 \frac{|D_i|}{|D|}$，$n$是特征$A$取值的个数。</p>
<h1 id="5-3-决策树的生成"><a href="#5-3-决策树的生成" class="headerlink" title="5.3 决策树的生成"></a>5.3 决策树的生成</h1><h2 id="5-3-1-ID3算法"><a href="#5-3-1-ID3算法" class="headerlink" title="5.3.1 ID3算法"></a>5.3.1 ID3算法</h2><p><strong>ID3算法</strong>的核心是在决策树各个结点上应用信息增益准则选择特征，递归地构建决策树。</p>
<ul>
<li>从根结点（root node）开始，对结点计算所有可能的特征信息增益，选择信息增益最大的特征作为结点的特征，由该特征的不同取值建立结点；</li>
<li>再对子结点递归地调用以上方法，构建决策树；</li>
<li>直到所有特征的信息增益均很小或没有特征可以选择为止。</li>
</ul>
<p><strong>ID3</strong>相当于用极大似然法进行概率模型的选择。</p>
<p><strong>算法 5.2（ID3算法）</strong></p>
<p><strong>输入</strong>：训练数据集$D$，特征集$A$阈值$\epsilon$；</p>
<p><strong>输出</strong>：决策树$T$。</p>
<p>​    （1）若$D$中所有实例属于同一类$C_k$，则$T$为单节点树，并将类$C_k$作为该结点的类标记，返回$T$；</p>
<p>​    （2）若$A = \emptyset$，则$T$为单节点树，并将$D$中实例数最大的类$D_k$作为该结点的类标记，返回$T$；</p>
<p>​    （3）否则，按算法5.1计算$A$中各特征对$D$的信息增益，选择信息增益最大的特征$A_g$；</p>
<p>​    （4）如果$A_g$的信息增益小于阈值$\epsilon$，则置$T$为单结点树，并将$D$中实例数最大的类$C_k$作为该结点的类标记，返回$T$；</p>
<p>​    （5）否则，对$A_g$的每一可能值$a_i$，依$A_g = a_i$将$D$分割为若干非空子集$D_i$，将$D_i$中实例数最大的类作为标记，构建子结点，由结点及子结点构成树$T$，返回$T$；</p>
<p>​    （6）对第$i$个子结点，以$D_i$为训练集，以$A-\{A_g\}$为特征集，递归地调用步（1）~ 步（5），得到子树$T_i$,返回$T_i$。</p>
<p>ID3算法只有树的生成，所以该算法生成的树容易产生过拟合。</p>
<h2 id="5-3-2-C4-5的生成算法"><a href="#5-3-2-C4-5的生成算法" class="headerlink" title="5.3.2 C4.5的生成算法"></a>5.3.2 C4.5的生成算法</h2><p>算法5.3（C4.5的生成算法）</p>
<p>输入：训练数据集$D$，特征集$A$阈值$\epsilon$；</p>
<p>输出：决策树$T$。</p>
<p>​    （1）若$D$中所有实例属于同一类$C_k$，则$T$为单节点树，并将类$C_k$作为该结点的类标记，返回$T$；</p>
<p>​    （2）若$A = \emptyset$，则$T$为单节点树，并将$D$中实例数最大的类$D_k$作为该结点的类标记，返回$T$；</p>
<p>​    （3）否则，按式$(5.10)$计算$A$中各特征对$D$的信息增益比，选择信息增益比最大的特征$A_g$；</p>
<p>​    （4）如果$A_g$的信息增益比小于阈值$\epsilon$，则置$T$为单结点树，并将$D$中实例数最大的类$C_k$作为该结点的类，返回$T$；</p>
<p>​    （5）否则，对$A_g$的每一可能值$a_i$，依$A_g = a_i$将$D$分割为若干非空子集$D_i$，将$D_i$中实例数最大的类作为标记，构建子结点，由结点及子结点构成树$T$，返回$T$；</p>
<p>​    （6）对结点$i$，以$D_i$为训练集，以$A-\{A_g\}$为特征集，递归地调用步（1）~ 步（5），得到子树$T_i$,返回$T_i$。</p>
<h1 id="5-4-决策树的剪枝"><a href="#5-4-决策树的剪枝" class="headerlink" title="5.4 决策树的剪枝"></a>5.4 决策树的剪枝</h1><p>在决策树学习中将已生成的树进行简化的过程称为剪枝（pruning）。具体地，，剪枝从已生成的树上裁掉一些子树或叶结点，并将其根结点或父结点作为新的叶结点，从而简化分类树模型。</p>
<p>决策树的剪枝往往通过极小化决策树整体的<strong>损失函数（loss function）</strong>或<strong>代价函数（cost function）</strong>来实现。</p>
<p>设树$T$的叶结点个数为$|T|$，$t$是树$T$的叶结点，该叶结点有$N_t$个样本点，其中$k$类的样本点有$N_{tk}$个，$k=1,2,…,K$，$H_t(T)$为叶结点$t$上的经验熵，$\alpha \geq 0$为参数，则决策树学习的损失函数可以定义为</p>
<script type="math/tex; mode=display">
C_{\alpha}(T) = \sum\limits_{t=1}^{|T|}N_t H_t(T) + \alpha|T| \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.11)</script><p>其中经验熵为</p>
<script type="math/tex; mode=display">
H_t(T) = - \sum\limits_{k}\frac{N_{tk}}{N_t} \log \frac{N_{tk}}{N_t}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.12)</script><p>在损失函数中，将式$(5.11)$右端的第1项记作</p>
<script type="math/tex; mode=display">
C(T)=\sum\limits_{t=1}^{|T|}N_t H_t(T)=-\sum\limits_{t=1}^{|T|}\sum\limits_{k=1}^{K}N_{tk} \log \frac{N_{tk}}{N_t}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.13)</script><p>这时有</p>
<script type="math/tex; mode=display">
C_{\alpha}(T) = C(T)+\alpha|T| \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.14)</script><p>式$(5.14)$中，$C(T)$表示模型对训练数据的预测误差，即模型与训练数据的拟合程度，$|T|$表示模型复杂度，参数$\alpha \geq 0$控制两者之间的影响。较大的$\alpha$促使选择较简单的模型（树），较小的$\alpha$促使选择较复杂的模型（树）。$\alpha = 0$意味着只考虑模型与训练数据的拟合程度，不考虑模型的复杂度。</p>
<p>剪枝，就是当$\alpha$确定时，选择损失函数最小的模型，即损失函数最小的子树。当$\alpha$值确定时</p>
<ul>
<li>子树越大，往往与训练数据的拟合越好，但是模型的复杂度就越高；</li>
<li>子树越小，模型的复杂度就越低，但是往往与训练数据的拟合不好。</li>
</ul>
<p>损失函数正好表示了对两者的平衡。</p>
<p>决策树生成只考虑了通过提高信息增益（或信息增益比）对训练数据进行更好的拟合。而决策树剪枝通过优化损失函数还考虑了减小模型复杂度。决策树生成学习局部的模型，而决策树剪枝学习整体的模型。</p>
<p>式$(5.11)$或式$(5.14)$定义的损失函数的极小化等价于正则化的极大似然估计。所以，利用损失函数最小原则进行剪枝就是用正则化的极大似然估计进行模型选择。</p>
<p><strong>算法 5.4（树的剪枝算法）</strong></p>
<p><strong>输入</strong>：生成算法产生的整个树$T$，参数$\alpha$；</p>
<p><strong>输出</strong>：修剪后的子树$T_\alpha$。</p>
<p>​    （1）计算每个结点的经验熵。</p>
<p>​    （2）递归地从树的叶结点向上回缩。设一组叶结点回缩到其父结点之前与之后的整体树分别为$T_B$与$T_A$，其对应的损失函数值分别是$C_{\alpha}(T_B)$与$C_{\alpha}(T_A)$，如果</p>
<script type="math/tex; mode=display">
C_{\alpha}(T_A) \leq C_{\alpha}(T_B) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.15)</script><p>则进行剪枝，即将父结点变为新的叶结点。</p>
<p>​    （3）返回（2），直至不能继续为止，得到损失函数最小的子树$T_{\alpha}$。</p>
<h1 id="5-5CART算法"><a href="#5-5CART算法" class="headerlink" title="5.5CART算法"></a>5.5CART算法</h1><p><strong>分类与回归树（classification and regression tree，CART）</strong>同样由特征选择、树的生成及剪枝组成，既可以用于分类也可以用于回归。</p>
<p>CART是在给定输入随机变量$X$条件下输出随机变量$Y$的条件概率分布的学习方法。CART假设决策树是二叉树，内部结点特征的取值为“是”和“否”，左分支是取值为“是”的分支，右分支是取值为“否”的分支。这样的决策树等价于递归地二分每个特征，将输入空间即特征空间划分为有限个单元，并在这些单元上确定预测的概率分布，也就是在输入给定的条件下输出的条件概率分布。</p>
<p>CART算法由以下两步组成：</p>
<ul>
<li>决策树生成：基于训练数据集生成决策树，生成的决策树要尽量大；</li>
<li>决策树剪枝：用验证数据集对已生成的树进行剪枝并选择最优子树，这时用损失函数最小作为剪枝的标准。</li>
</ul>
<h2 id="5-5-1-CART生成"><a href="#5-5-1-CART生成" class="headerlink" title="5.5.1 CART生成"></a>5.5.1 CART生成</h2><p>对回归树用平方误差最小化准则，对分类树用<strong>基尼指数（Gini index）</strong>最小化准则，进行特征选择，生成二叉树。</p>
<ol>
<li><strong>回归树的生成</strong></li>
</ol>
<p>一颗回归树对应着输入空间（即特征空间）的一个划分以及在划分的单元上的输出值。假设已将输入空间划分为$M$个单元$R_1,R_2,…,R_M$，并且在每个单元$R_m$上有一个固定的输出值$c_m$，于是回归树模型可表示为</p>
<script type="math/tex; mode=display">
f(x)=\sum\limits_{m=1}^{M} c_m I(x \in R_m)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.16)</script><p>当输入空间的划分确定时，可以用平方误差$\sum\limits_{x_i \in R_m}(y_i-f(x_i))^2$来表示回归树对于训练数据的预测误差，用平方误差最小的准则求解每个单元上的最优输出值。单元$R_m$上的$c_m$的最优值$\hat c_m$是$R_m$上的所有输入实例$x_i$对应的输出$y_i$的均值，即</p>
<script type="math/tex; mode=display">
\hat c_m = ave(y_i|x_i \in R_m)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.17)</script><p>这里采用启发式的方法对输入空间进行划分。选择第$j$个变量$x^{(j)}$和它取的值$s$，作为<strong>切分变量（splitting variable）</strong>和<strong>切分点（splitting point）</strong>，并定义两个区域：</p>
<script type="math/tex; mode=display">
R_1(j,s) = \{x|x^{(j)} \leq s\} \ \ \  和 \ \ \ R_2(j,s) = \{x|x^{(j)} > s\}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.18)</script><p>然后寻找最优切分变量$j$和最优切分点$s$。具体地，求解</p>
<script type="math/tex; mode=display">
\min\limits_{j,s}[\min\limits_{c_1}\sum\limits_{x_i\in R_1(j,s)}(y_i - c_1)^2 + \min\limits_{c_2}\sum\limits_{x_i\in R_2(j,s)}(y_i - c_2)^2]\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.19)</script><p>对固定输入变量$j$可以找到最优切分点$s$。</p>
<script type="math/tex; mode=display">
\hat c_1 = ave(y_i|x_i \in R_1(j,s)) \ \ \ 和 \ \ \ \hat c_2 = ave(y_i|x_i \in R_2(j,s))\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.20)</script><p>遍历所有输入变量，找到最优的切分变量$j$，构成一个对$(j,s)$。依次将输入空间划分为两个区域。接着，对每个区域重复上述划分过程，直到满足停止条件为止。这样就生成一颗回归树。这样的回归树通常称为<strong>最小二乘回归树（least squares regression tree）</strong>。</p>
<p><strong>算法 5.5（最小二乘回归树生成算法）</strong></p>
<p><strong>输入</strong>：训练数据集$D$；</p>
<p><strong>输出</strong>：回归树$f(x)$。</p>
<p>在训练数据集所在的输入空间中，递归地将每个区域划分为两个子区域并决定每个子区域上的输出值，构建二叉决策树：</p>
<p>​    （1）选择最优切分变量$j$与切分点$s$，求解</p>
<script type="math/tex; mode=display">
\min\limits_{j,s}[\min\limits_{c_1}\sum\limits_{x_i\in R_1(j,s)}(y_i - c_1)^2 + \min\limits_{c_2}\sum\limits_{x_i\in R_2(j,s)}(y_i - c_2)^2]</script><p>遍历变量$j$，对固定的切分变量$j$扫描切分点$s$，选择使上式达到最小值的对$(j,s)$。</p>
<p>​    （2）用选定的对$(j,s)$划分区域并决定相应的输出值：</p>
<script type="math/tex; mode=display">
R_1(j,s) = \{x|x^{(j)} \leq s\}, \ \ \ R_2(j,s) = \{x|x^{(j)} > s\}</script><script type="math/tex; mode=display">
\hat c_m = \frac{1}{N_m}\sum\limits_{x_i\in R_m(j,s)} y_i, \ \ \ x \in R_m, \ \ \ m=1,2</script><p>​    （3）继续对两个子区域调用步骤(1),(2)，直至满足停止条件。</p>
<p>​    （4）将输入空间划分为$M$个区域$R_1,R_2,…,R_M$，生成决策树：</p>
<script type="math/tex; mode=display">
f(x)=\sum\limits_{m=1}^{M} c_m I(x \in R_m)</script><hr>
<ol>
<li><strong>分类树的生成</strong></li>
</ol>
<p>分类树用基尼指数选择最优特征，同时决定该特征的最优二值切分点。</p>
<p><strong>定义 5.4（基尼指数）</strong>  分类问题中，假设有$K$个类，样本点属于第$k$类的概率为$p_k$，则概率分布的基尼指数定义为</p>
<script type="math/tex; mode=display">
Gini(p) = \sum\limits_{k = 1}^{K} p_k(1-p_k) = 1 - \sum\limits_{k = 1}^{K} p_k^2\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.22)</script><p>对于二分类问题，若样本点属于第1个类的概率是$p$，则概率分布的基尼指数为</p>
<script type="math/tex; mode=display">
Gini(p) = 2p(1-p)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.23)</script><p>对于给定的样本集合$D$，其基尼指数为</p>
<script type="math/tex; mode=display">
Gini(D) = 1 - \sum\limits_{k = 1}^{K} (\frac{|C_k|}{|D|})^2 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.24)</script><p>这里，$C_k$是$D$中属于第$k$类的样本子集，$K$是类的个数。</p>
<p>如果样本集合$D$根据特征$A$是否取某一可能值$a$被分割成$D_1$和$D_2$两部分，即</p>
<script type="math/tex; mode=display">
D_1 =\{(x,y)\in D|A(x)=a \}, \ \ \ D_2 = D - D_1</script><p>则在特征$A$的条件下，集合$D$的基尼指数定义为</p>
<script type="math/tex; mode=display">
Gini(D,A)=\frac{|D_1|}{|D|}Gini(D_1) \ +  \ \frac{|D_2|}{|D|}Gini(D_2)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.25)</script><p>基尼指数$Gini(D)$表示集合$D$的不确定性，基尼指数$Gini(D,A)$表示经$A=a$分割后集合$D$的不确定性。基尼指数值越大，样本集合的不确定性也就越大，这一点与熵相似。</p>
<p>基尼指数和熵之半的曲线很接近，都可以近似地代表分类错误率。</p>
<p><strong>算法 5.6（CART生成算法）</strong></p>
<p><strong>输入</strong>：训练数据集$D$，停止计算的条件；</p>
<p><strong>输出</strong>：CART决策树。</p>
<p>根据训练数据集，从根结点开始，递归地对每个结点进行以下操作，构建二叉决策树：</p>
<p>​    （1）设结点的训练数据集为$D$，计算现有特征对该数据集的基尼指数。此时，对每一个特征$A$，对其可能取的每个值$a$，根据样本点对$A=a$的测试为“是”或“否”将$D$分割成$D_1$和$D_2$两部分，利用式$(5.25)$计算$A=a$时的基尼指数。</p>
<p>​    （2）在所有可能的特征$A$以及它们所有可能的切分点$a$中，选择基尼指数最小的特征及其对应的切分点作为最优特征与最优切分点。依最优特征与最优切分点，从现结点生成两个子结点，将训练数据集依特征分配到两个子结点中去。</p>
<p>​    （3）对两个子结点递归地调用(1),(2)，直至满足停止条件。</p>
<p>​    （4）生成CART决策树。</p>
<p>算法停止计算的条件是结点中的样本个数小于预定阈值，或样本集的基尼指数小于预定阈值（样本基本属于同一类），或者没有更多特征。</p>
<h2 id="5-5-2-CART剪枝"><a href="#5-5-2-CART剪枝" class="headerlink" title="5.5.2 CART剪枝"></a>5.5.2 CART剪枝</h2><p>CART剪枝算法由两步组成：</p>
<ul>
<li>首先从生成算法产生的决策树$T_0$底端开始不断剪枝，直到$T_0$的根结点，形成一个子树序列$\{T_0,T_1,…,T_n\}$；</li>
<li>然后通过交叉验证法在独立的验证数据集上对子树序列进行测试，从中选择最优子树。</li>
</ul>
<hr>
<ol>
<li><strong>剪枝，形成一个子树序列</strong></li>
</ol>
<p>在剪枝过程中，计算子树的损失函数：</p>
<script type="math/tex; mode=display">
C_\alpha(T) = C(T) + \alpha|T|\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.26)</script><p>其中，$T$为任意子树，$C(T)$为对训练数据的预测误差（如基尼指数），$|T|$为子树的叶结点个数，$\alpha \geq 0$为参数，$C_\alpha(T)$为参数是$\alpha$时的子树$T$的整体损失。参数$\alpha$权衡训练数据的拟合程度与模型的复杂度。</p>
<p>对固定的$\alpha$，一定存在使损失函数$C_\alpha(T)$最小的子树，将其表示为$T_\alpha$。$T_\alpha$在损失函数$C_\alpha(T)$最小的意义下是最优的。</p>
<ul>
<li>当$\alpha$大的时候，最优子树$T_\alpha$偏小；</li>
<li>当$\alpha$小的时候，最优子树$T_\alpha$偏大；</li>
<li>当$\alpha=0$时，整体树是最优的。</li>
<li>当$\alpha \longrightarrow \infty$时，根结点组成的单结点树是最优的。</li>
</ul>
<p>Breiman等人证明：可以用递归的方法对树进行剪枝。具体地，从整体树$T_0$开始剪枝。对$T_0$的任意内部结点$t$，以$t$为单结点树的损失函数是</p>
<script type="math/tex; mode=display">
C_\alpha(t) = C(t) + \alpha\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.27)</script><p>以$t$为根结点的子树$T_t$的损失函数是</p>
<script type="math/tex; mode=display">
C_\alpha(T_t) = C(T_t) + \alpha|T_t|\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.28)</script><p>当$\alpha = 0$及$\alpha$充分小时，有不等式</p>
<script type="math/tex; mode=display">
C_\alpha(T_t) < C_\alpha(t)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.29)</script><p>当$\alpha$增大时，在某一$\alpha$有</p>
<script type="math/tex; mode=display">
C_\alpha(T_t) = C_\alpha(t)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.30)</script><p>当$\alpha$再增大时，不等式$(5.29)$反向。只要$\alpha = \frac{C(t)-C(T_t)}{|T_t|-1}$，$T_t$与$t$有相同的损失函数值，而$t$的结点少，因此$t$比$T_t$更可取，对$T_t$进行剪枝。</p>
<p>为此，对$T_0$中每一内部结点$t$，计算</p>
<script type="math/tex; mode=display">
g(t)=\frac{C(t)-C(T_t)}{|T_t|-1}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5.31)</script><p>它表示剪枝后整体损失函数减少的程度。在$T_0$中减去$g(t)$最小的$T_t$，将得到的子树作为$T_1$，同时将最小的$g(t)$设为$\alpha_1$。$T_1$为区间$[\alpha_1,\alpha_2)$的最优子树。</p>
<p>如此剪枝下去，直至得到根结点。在这一过程中，不断地增加$\alpha$的值，产生新的区间。</p>
<hr>
<ol>
<li><strong>在剪枝得到的子树序列</strong>$T_0,T_1,…,T_n$<strong>中通过交叉验证选取最优子树</strong>$T_\alpha$</li>
</ol>
<p>具体地，利用独立的验证数据集，测试子树序列$T_0,T_1,…,T_n$中各棵子树的平方误差或基尼指数。平方误差或基尼指数最小的决策树被认为是最优的决策树。在子树序列中，每棵子树$T_0,T_1,…,T_n$都对应于一个参数$\alpha_1,\alpha_2,…,\alpha_n$。所以，当最优子树$T_k$确定时，对应的$\alpha_k$也确定了，即得到最优决策树$T_\alpha$。</p>
<hr>
<p><strong>算法 5.7（CART剪枝算法）</strong></p>
<p><strong>输入</strong>：CART算法生成的决策树$T_0$；</p>
<p><strong>输出</strong>：最优决策树$T_\alpha$。</p>
<p>​    （1）设$k=0,T=T_0$。</p>
<p>​    （2）设$\alpha = +\infty$。</p>
<p>​    （3）自下而上地对各个内部结点$t$计算$C(T_t),|T_t|$以及</p>
<script type="math/tex; mode=display">
g(t)=\frac{C(t)-C(T_t)}{|T_t|-1}</script><script type="math/tex; mode=display">
\alpha = \min(\alpha,g(t))</script><p>这里，$T_t$表示以$t$为根结点的子树，$C(T_t)$是对训练数据的预测误差，$|T_t|$是$T_t$的叶结点个数。</p>
<p>​    （4）对$g(t) = \alpha$的内部结点$t$进行剪枝，并对叶结点$t$以多数表决法决定其类，得到树$T$。</p>
<p>​    （5）设$k = k+1,\alpha_k = \alpha,T_k = T$。</p>
<p>​    （6）如果$T_k$不是由根结点及两个叶结点构成的树，则回到步骤(2)；否则令$T_k =T_n$。</p>
<p>​    （7）采用交叉验证法在子树序列$T_0,T_1,…,T_n$中选取最优子树$T_\alpha$。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/06/Statistical_Learning_Methods_Notes/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/06/Statistical_Learning_Methods_Notes/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B3%95/" class="post-title-link" itemprop="url">第四章 朴素贝叶斯法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-06-06 11:02:41 / 修改时间：11:10:55" itemprop="dateCreated datePublished" datetime="2021-06-06T11:02:41+08:00">2021-06-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">统计学习方法</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/06/06/Statistical_Learning_Methods_Notes/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B3%95/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/06/06/Statistical_Learning_Methods_Notes/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B3%95/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>朴素贝叶斯（naive Bayes）法</strong>是基于贝叶斯定理与特征条件独立假设的分类方法。</p>
<p>对于给定的训练数据集，首先基于特征条件独立假设学习输入输出的联合概率分布；然后基于此模型，对给定的输入$x$，利用贝叶斯定理求出后验概率最大的输出$y$。</p>
<h1 id="4-1-朴素贝叶斯法的学习与分类"><a href="#4-1-朴素贝叶斯法的学习与分类" class="headerlink" title="4.1 朴素贝叶斯法的学习与分类"></a>4.1 朴素贝叶斯法的学习与分类</h1><h2 id="4-1-1-基本方法"><a href="#4-1-1-基本方法" class="headerlink" title="4.1.1 基本方法"></a>4.1.1 基本方法</h2><p>设</p>
<ul>
<li><p>输入空间$\chi \subseteq R^n$为$n$维向量的集合，输出空间为类标记集合$\mathcal{Y} = \{c_1,c_2,…,c_K\}$。</p>
</li>
<li><p>输入为特征向量$x \in \chi$，输出为类标记（class lable）$y \in \mathcal{Y}$。</p>
</li>
<li><p>$X$是定义在输入空间$\chi$上的随机向量，$Y$是定义在输出空间$\mathcal{Y}$上的随机变量。</p>
</li>
<li><p>$P(X,Y)$是$X$和$Y$的联合概率分布。</p>
</li>
<li><p>训练数据集</p>
<script type="math/tex; mode=display">
T = \{(x_1,y_1),(x_2,y_2),...,(x_N,y_N)\}</script><p>由$P(X,Y)$独立同分布产生。</p>
</li>
</ul>
<p>朴素贝叶斯法通过训练数据集学习联合分布概率分布$P(X,Y)$。具体地，学习以下先验概率分布及条件概率分布。</p>
<p><strong>先验概率分布</strong>：</p>
<script type="math/tex; mode=display">
P(Y = c_k), \ \ \ k = 1,2,...,K\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (4.1)</script><p><strong>条件概率分布</strong>：</p>
<script type="math/tex; mode=display">
P(X=x|Y=c_k) = P(X^{(1)} = x^{(1)},...,X^{(n)} = x^{(n)}|Y=c_k)\ \ \ k = 1,2,...,K\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (4.2)</script><p>于是学习到联合概率分布$P(X,Y)$。</p>
<p>朴素贝叶斯法对条件概率分布作了条件独立性的假设。由于这是一个较强的假设，朴素贝叶斯法也由此得名。</p>
<p><strong>条件独立性假设</strong>：</p>
<script type="math/tex; mode=display">
P(X=x|Y=c_k) = P(X^{(1)} = x^{(1)},...,X^{(n)} = x^{(n)}|Y=c_k) = \prod\limits_{j=1}^{n}P(X^{(j)} = x^{(j)}|Y=c_k) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (4.3)</script><p>朴素贝叶斯法实际上学习到生成数据的机制，所以属于生成模型。条件独立假设等于是说用于分类的特征在类确定的条件下都是条件独立的。这一假设使朴素贝叶斯法变得简单，但有时会牺牲一定的分类准确率。</p>
<p>朴素贝叶斯法分类时，对给定的输入$x$，通过学习到的模型计算后验概率分布$P(Y=c_k|X=x)$，将后验概率最大的类作为$x$的类输出。</p>
<p><strong>后验概率计算根据贝叶斯定理进行</strong>：</p>
<script type="math/tex; mode=display">
P(Y=c_k|X=x) = \frac{P(X=x|Y=c_k)P(Y=c_k)}{\sum\limits_{k}P(X=x|Y=c_k)P(Y=c_k)}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (4.4)</script><p>将式$(4.3)$代入式$(4.4)$，有</p>
<script type="math/tex; mode=display">
P(Y=c_k|X=x) = \frac{P(Y=c_k)\prod\limits_jP(X^{(j)}=x^{(j)}|Y=c_k)}{\sum\limits_kP(Y=c_k)\prod\limits_jP(X^{(j)}=x^{(j)}|Y=c_k)}, \ \ \ k = 1,2,...,K \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (4.5)</script><p>这就是<strong>朴素贝叶斯法分类的基本公式</strong>。</p>
<p><strong>朴素贝叶斯分类器</strong>可表示为：</p>
<script type="math/tex; mode=display">
y=f(x)=arg\max_{c_k}\frac{P(Y=c_k)\prod\limits_jP(X^{(j)}=x^{(j)}|Y=c_k)}{\sum\limits_kP(Y=c_k)\prod\limits_jP(X^{(j)}=x^{(j)}|Y=c_k)}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (4.6)</script><p>在式$(4.6)$中分母对所有$c_k$都是相同的，所以</p>
<script type="math/tex; mode=display">
y=arg\max_{c_k}{P(Y=c_k)\prod\limits_jP(X^{(j)}=x^{(j)}|Y=c_k)}\ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (4.7)</script><h2 id="4-1-2-后验概率最大化的含义"><a href="#4-1-2-后验概率最大化的含义" class="headerlink" title="4.1.2 后验概率最大化的含义"></a>4.1.2 后验概率最大化的含义</h2><p>朴素贝叶斯法将实例分到后验概率最大的类中。这等价于期望风险最小化。假设选择0-1损失函数：</p>
<script type="math/tex; mode=display">
L(Y,f(X)) = \lbrace_{0,\ \ Y=f(X)}^{1,\ \ Y \neq f(X)}</script><p>式中$f(X)$是分类决策函数。这时，期望风险函数为</p>
<script type="math/tex; mode=display">
R_{exp}(f)=E[L(Y,f(X))]</script><p>期望是对联合分布$P(X,Y)$取的。由此取条件期望</p>
<script type="math/tex; mode=display">
R_{exp}(f) = E_X \sum\limits_{k=1}^{K}[L(c_k,f(X))]P(c_k|X)</script><p>为了使期望风险最小化，只需对$X=x$逐个极小化，由此得到：</p>
<script type="math/tex; mode=display">
f(x) = arg \min\limits_{y \in \mathcal{Y}} \sum\limits_{k=1}^{K} L(c_k,y)P(c_k|X=x)</script><script type="math/tex; mode=display">
\ \   =arg \min\limits_{y \in \mathcal{Y}} \sum\limits_{k=1}^{K}P(y \neq c_k|X=x)</script><script type="math/tex; mode=display">
\ \ \ \ \ \ \  = arg \min\limits_{y \in \mathcal{Y}} (1 - P(y = c_k|X=x))</script><script type="math/tex; mode=display">
= arg \max\limits_{y \in \mathcal{Y}} P(y = c_k|X=x)</script><p>这样一来，根据期望风险最小化准则就得到了后验概率最大化准则：</p>
<script type="math/tex; mode=display">
f(x)=agr\max\limits_{c_k}P(c_k|X=x)</script><p>即朴素贝叶斯法所才用的原理。</p>
<h1 id="4-2-朴素贝叶斯法的参数估计"><a href="#4-2-朴素贝叶斯法的参数估计" class="headerlink" title="4.2 朴素贝叶斯法的参数估计"></a>4.2 朴素贝叶斯法的参数估计</h1><h2 id="4-2-1-极大似然估计"><a href="#4-2-1-极大似然估计" class="headerlink" title="4.2.1 极大似然估计"></a>4.2.1 极大似然估计</h2><p>在朴素贝叶斯法中，学习意味着估计$P(Y=c_k)$和$P(X^{(j)}=x^{(j)}|Y=c_k)$。可以应用极大似然估计法估计相应的概率。</p>
<ul>
<li><p>先验概率的$P(Y=c_k)$的极大似然估计是：</p>
<script type="math/tex; mode=display">
P(Y=c_k) = \frac{\sum\limits_{i=1}^{N}I(y_i=c_k)}{N},  \ \ \ k = 1,2,...,K\ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (4.8)</script></li>
<li><p>设第$j$个特征$x^{(j)}$可能取值的集合为$\{a_{j1},a_{j2},…,a_{jS_j}\}$,条件概率$P(X^{(j)}=a_{jl}|Y=c_k)$的极大似然估计是：</p>
<script type="math/tex; mode=display">
P(X^{(j)}=a_{jl}|Y=c_k) = \frac{\sum\limits_{i=1}^{N}I(x_i^{(j)}=a_{jl},y_i=c_k)}{\sum\limits_{i=1}^{N}I(y_i=c_k)}</script><script type="math/tex; mode=display">
\\ \  \\ \\   j=1,2,...,n;\ \ \ l=1,2,...,S_j;\ \ \ k = 1,2,...,K \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (4.9)</script><p>式中，$x_i^{(j)}$是第$i$个样本的第$j$个特征；$a_{jl}$是第$j$个特征可能取的第$l$个值；$I$为指示函数。</p>
</li>
</ul>
<h2 id="4-2-2-学习与分类算法"><a href="#4-2-2-学习与分类算法" class="headerlink" title="4.2.2 学习与分类算法"></a>4.2.2 学习与分类算法</h2><p><strong>算法 4.1（朴素贝叶斯算法（naive Bayes algorithm））</strong></p>
<p><strong>输入</strong>：训练数据$T = \{(x_1,y_1),(x_2,y_2),…,(x_N,y_N)\}$，其中$x_i=(x_i^{(1)},x_i^{(2)},…x_i^{(n)})^T$，$x_i^{(j)}$是第$i$个样本的第$j$个特征，$x_i^{(j)} \in \{a_{j1},a_{j2},…a_{jS_j} \}$，$a_{jl}$是第$j$个特征可能取的第$l$个值，$j = 1,2,…,n; \ \ l=1,2,…,S_j,\ \ y_i \in \{c_1,c_2,…,c_K\}$；实例$x$；</p>
<p><strong>输出</strong>：实例$x$的分类。</p>
<p>​    （1）计算先验概率及条件概率</p>
<script type="math/tex; mode=display">
P(Y=c_k) = \frac{\sum\limits_{i=1}^{N}I(y_i=c_k)}{N},  \ \ \ k = 1,2,...,K</script><script type="math/tex; mode=display">
P(X^{(j)}=a_{jl}|Y=c_k) = \frac{\sum\limits_{i=1}^{N}I(x_i^{(j)}=a_{jl},y_i=c_k)}{\sum\limits_{i=1}^{N}I(y_i=c_k)}\\ \  \\ \ \\      j=1,2,...,n;\ \ \ l=1,2,...,S_j;\ \ \ k = 1,2,...,K</script><p>​    （2）对于给定的实例$x=(x^{(1)},x^{(2)},…,x^{(n)})^T$，计算</p>
<script type="math/tex; mode=display">
{P(Y=c_k)\prod\limits_{j=1}^{n}P(X^{(j)}=x^{(j)}|Y=c_k)}, \ \ \ k = 1,2,...,K</script><p>​    （3）确定实例$x$的类</p>
<script type="math/tex; mode=display">
y=arg\max_{c_k}{P(Y=c_k)\prod\limits_{j=1}^{n}P(X^{(j)}=x^{(j)}|Y=c_k)}</script><h2 id="4-2-3-贝叶斯估计"><a href="#4-2-3-贝叶斯估计" class="headerlink" title="4.2.3 贝叶斯估计"></a>4.2.3 贝叶斯估计</h2><p>用极大似然估计可能会出现所要估计的概率值为$0$的情况。这时会影响到后验概率的计算结果，使分类产生偏差。解决这一问题的方法是采用贝叶斯估计。</p>
<ul>
<li><strong>条件概率的贝叶斯估计</strong>是 ：</li>
</ul>
<script type="math/tex; mode=display">
P_{\lambda}(X^{(j)}=a_{jl}|Y=c_k) = \frac{\sum\limits_{i=1}^{N}I(x_i^{(j)}=a_{jl},y_i=c_k) + \lambda}{\sum\limits_{i=1}^{N}I(y_i=c_k) + S_j \lambda}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (4.10)</script><p>式中$\lambda \geq 0$。等价于在随机变量各个取值的频数上赋予一个正数$\lambda &gt; 0$。当$\lambda = 0$时就是极大似然估计。 常取$\lambda = 1$，这时称为<strong>拉普拉斯平滑(Laplacian smoothing)</strong>。显然对任何$l = 1,2,…,S_j,\ k=1,2,…,K，$有</p>
<script type="math/tex; mode=display">
P_{\lambda}(X^{(j)}=a_{jl}|Y=c_k) > 0 \\ \sum\limits_{l=1}^{S_j}P_{\lambda}(X^{(j)}=a_{jl}|Y=c_k) = 1</script><p>表明式$(4.10)$确为一种概率分布。</p>
<ul>
<li><strong>先验概率的贝叶斯估计</strong>是：<script type="math/tex; mode=display">
P_{\lambda}(Y=c_k) = \frac{\sum\limits_{i=1}^{N}I(y_i=c_k)\ + \ \lambda}{N\ + \ K\lambda} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (4.11)</script></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/05/Statistical_Learning_Methods_Notes/%E7%AC%AC%E4%B8%89%E7%AB%A0-k%E8%BF%91%E9%82%BB%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/05/Statistical_Learning_Methods_Notes/%E7%AC%AC%E4%B8%89%E7%AB%A0-k%E8%BF%91%E9%82%BB%E6%B3%95/" class="post-title-link" itemprop="url">第三章 K近邻法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-05 22:24:26" itemprop="dateCreated datePublished" datetime="2021-06-05T22:24:26+08:00">2021-06-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-08 14:40:28" itemprop="dateModified" datetime="2021-06-08T14:40:28+08:00">2021-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">统计学习方法</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/06/05/Statistical_Learning_Methods_Notes/%E7%AC%AC%E4%B8%89%E7%AB%A0-k%E8%BF%91%E9%82%BB%E6%B3%95/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/06/05/Statistical_Learning_Methods_Notes/%E7%AC%AC%E4%B8%89%E7%AB%A0-k%E8%BF%91%E9%82%BB%E6%B3%95/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>$k$近邻法（$k$-nearest neighbor​，$k$-$NN$）是一种基本分类与回归方法。</p>
<p>$k$近邻法的输入为实例的特征向量，对应于特征空间的点；输出为实例的类别，可以取多类。</p>
<p>分类时，对新的实例，根据其$k$个最近邻的训练实例的类别，通过多数表决等方式进行预测。因此，$k$近邻法不具有显式的学习过程。</p>
<p>$k$近邻法实际上利用训练数据集对特征向量空间进行划分，并作为其分类的“模型”。</p>
<p>$k$值的选择、距离度量及分类决策规则是$k$近邻法的三个基本要素。</p>
<h1 id="3-1-k-近邻算法"><a href="#3-1-k-近邻算法" class="headerlink" title="3.1 $k$近邻算法"></a>3.1 $k$近邻算法</h1><p>$k$近邻算法简单、直观：给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例最邻近的$k$个实例，这$k$个实例的多数属于某个类，就把该输入实例分为这个类。</p>
<p><strong>算法3.1（$k$近邻法）</strong></p>
<p><strong>输入</strong>：训练数据集$T = \{(x_1,y_1),(x_2,y_2),…,(x_N,y_N)\}$，其中，$x_i \in \chi = R^n$为实例的特征向量, $y \in Y = \{c_1,c_2,…,c_K\}$为实例的类别，$i=1,2,…,N$；实例特征向量$x$;</p>
<p><strong>输出</strong>：实例$x$所属的类$y$。</p>
<p>​    （1）根据给定的距离度量，在训练集$T$中找出与$x$最邻近的$k$个点，涵盖这$k$个点的$x$的领域记作$N_k(x)$; </p>
<p>​    （2）在$N_k(x)$中根据分类决策规则（如多数表决）决定$x$的类别$y$；</p>
<script type="math/tex; mode=display">
y = arg\max\limits_{c_j} \sum\limits_{x_i \in N_k(x)} I(y_i = c_j), \ \ \ \ i=1,2,...,N;j=1,2,...,K \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (3.1)</script><p>​        式（3.1）中$I$为指示函数，即当$y_i = c_j$时$I$为$1$，否则$I$为$0$。</p>
<p>$k$近邻法的特殊情况是$k = 1$的情形，称为最近邻算法。</p>
<p>$k$近邻法没有显示的学习过程。</p>
<h1 id="3-2-k-近邻模型"><a href="#3-2-k-近邻模型" class="headerlink" title="3.2 $k$近邻模型"></a>3.2 $k$近邻模型</h1><p>$k$近邻法使用的模型实际上对应于对特征空间的划分。模型由三个基本要素——距离度量、$k$值的选择和分类决策规则决定。</p>
<h2 id="3-2-1-模型"><a href="#3-2-1-模型" class="headerlink" title="3.2.1 模型"></a>3.2.1 模型</h2><p>特征空间中，对每个训练实例点$x_i$，距离该点比其他点更近的所有点组成一个区域，叫作<strong>单元（cell）</strong>。每个训练实例点拥有一个单元，所有训练实例点的单元构成对特征空间的一个划分。最近邻法将实例$x_i$的类$y_i$作为单元中所有点的<strong>类标记（class label）</strong>。这样，每个单元的实例点的类别是确定的。</p>
<h2 id="3-2-2-距离度量"><a href="#3-2-2-距离度量" class="headerlink" title="3.2.2 距离度量"></a>3.2.2 距离度量</h2><p>特征空间中两个实例点的距离是两个实例点相似程度的反映。$k$近邻模型的特征空间一般是$n$维实数向量空间$R^n$。使用的距离是欧氏距离，但也可以是其他距离，如跟一般的$L_p$<strong>距离（</strong>$L_p$ <strong>distance）</strong>或<strong>Minkowski距离（Minkowski distance）</strong>。</p>
<p>设特征空间$\chi$是$n$维实数向量空间$R^n$，$x_i,x_j \in \chi,x_i = (x_i^{(1)},x_i^{(2)},…,x_i^{(n)})^T,x_j = (x_j^{(1)},x_j^{(2)},…,x_j^{(n)})^T,x_i,x_j$的$L_p$距离定义为</p>
<script type="math/tex; mode=display">
L_p(x_i,x_j) = (\sum\limits_{l=1}^n |x_i^{(l)} - x_j^{(l)}|^2)^{\frac{1}{p}} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (3.2)</script><p>这里$p \geq 1$。</p>
<ul>
<li><p>当$p = 2$时，称为<strong>欧氏距离（Euclidean distance）</strong>，即</p>
<script type="math/tex; mode=display">
L_2(x_i,x_j) = (\sum\limits_{l=1}^n |x_i^{(l)} - x_j^{(l)}|^2)^{\frac{1}{2}} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (3.3)</script></li>
<li><p>当$p = 1$时，称为曼<strong>哈顿距离（Manhattan distance）</strong>，即</p>
<script type="math/tex; mode=display">
L_1(x_i,x_j) = \sum\limits_{l=1}^n |x_i^{(l)} - x_j^{(l)}| \ \ \ \ \ \ \ \ \ \ \ \ \  \ \  \ \ \ \ \ \ \ \ \ \ \ \ \ \ (3.4)</script></li>
<li><p>当$p = \infty$时，它是<strong>各个坐标距离的最大值</strong>，即</p>
<script type="math/tex; mode=display">
L_\infty(x_i,x_j) = \max\limits_{l} |x_i^{(l)} - x_j^{(l)}| \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (3.5)</script></li>
</ul>
<p>由不同的距离度量所确定的最近邻点是不同的。</p>
<h2 id="3-2-3-k-值的选择"><a href="#3-2-3-k-值的选择" class="headerlink" title="3.2.3 $k$值的选择"></a>3.2.3 $k$值的选择</h2><p>$k$值的选择会对$k$近邻法的结果产生重大影响。</p>
<ul>
<li>如果选择较小的$k$值，就相当于用较小的邻域中的训练实例进行预测，“学习“的近似误差（approximation error）会减小，只有与输入实例较近（相似的）训练实例才会对预测结果起作用。但缺点是”学习“的估计误差（estimation error）会增大，预测结果会对近邻的实例点非常敏感。如果邻近的实例点恰巧是噪声，预测就会出错。换句话说，$k$值的减小就意味着整体模型变得复杂，容易发生过拟合。</li>
<li>如果选择较大的$k$值，就相当于用较大邻域中的训练实例进行预测。其优点是可以减少学习的估计误差，但缺点是学习的近似误差会增大。这时与输入实例较远的（不相似的）训练实例也会对预测起作用，使预测发生错误。$k$值增大就意味着整体的模型变得简单。</li>
</ul>
<p>在应用中，$k$值一般取一个比较小的数值。通常采用交叉验证法来选取最优的$k$值。</p>
<h2 id="3-2-4-分类决策规则"><a href="#3-2-4-分类决策规则" class="headerlink" title="3.2.4 分类决策规则"></a>3.2.4 分类决策规则</h2><p>$k$近邻法中的分类决策规则往往是多数表决，即由输入实例的$k$个邻近的训练实例中多数类决定输入实例的类。</p>
<p><strong>多数表决规则（majority voting rule）</strong>有如下解释：如果分类的损失函数为0-1损失函数，分类函数为</p>
<script type="math/tex; mode=display">
f:R^n \longrightarrow \{c_1,c_2,...,c_K\}</script><p>那么误分类的概率是</p>
<script type="math/tex; mode=display">
P(Y \neq f(X)) = 1 - P(Y = f(X))</script><p>对给定的实例$x \in \chi$，其最近邻的$k$个训练实例点构成集合$N_k(x)$。如果涵盖$N_k(x)$的区域的类别是$c_j$，那么误分类率是</p>
<script type="math/tex; mode=display">
\frac{1}{k}\sum\limits_{x_i \in N_k(x)} I(y_i \neq c_j) = 1-\frac{1}{k}\sum\limits_{x_i \in N_k(x)} I(y_i = c_j)</script><p>要使误分类率最小即经验风险最小，就要使$\sum\limits_{x_i \in N_k(x)} I(y_i = c_j)$最大，所以多数表决规则等价于经验风险最小化。</p>
<h1 id="3-3-k-近邻法的实现：-kd-树"><a href="#3-3-k-近邻法的实现：-kd-树" class="headerlink" title="3.3 $k$近邻法的实现：$kd$树"></a>3.3 $k$近邻法的实现：$kd$树</h1><p>实现$k$近邻法时，主要考虑的问题是如果对训练数据进行快速$k$近邻搜索。</p>
<p>$k$近邻法最简单的实现方法是<strong>线性扫描（linear scan）</strong>。这时要计算输入实例与每一个训练实例的距离。</p>
<h2 id="3-3-1-构造-kd-树"><a href="#3-3-1-构造-kd-树" class="headerlink" title="3.3.1 构造$kd$树"></a>3.3.1 构造$kd$树</h2><p>$kd$树是一种对$k$维空间中的实例点进行存储以便对其进行快速检索的树形数据结构。</p>
<p>$kd$树是二叉树，表示对$k$维空间的一个<strong>划分（partition）</strong>。</p>
<p>构造$kd$树相当于不断地用垂直于坐标轴的超平面将$k$维空间切分，构成一系列的$k$维超矩形区域。$kd$树的每个节点对应于一个$k$维超矩形区域。</p>
<p>构造$kd$树的方法如下：</p>
<ul>
<li>构造根节点，使根节点对应于$k$维空间中包含所有实例点的超矩形区域；</li>
<li>通过下面的递归方法，不断地对$k$维空间进行切分，生成子节点。</li>
<li>在超矩形区域（结点）上选择一个坐标轴和在此坐标轴上的一个切分点，确定一个超平面，这个超平面通过选定的切分点并垂直于选定的坐标轴，将当前超矩形区域切分为左右两个子区域（子结点）；这时，实例被分到两个子区域。这个过程直到子区域内没有实例时终止（终止时的结点为叶结点）。在此过程中，将实例保存在相应的结点上。</li>
</ul>
<p>kd树是存储k维空间数据的树结构，这里的k与k近邻法的k意义不同。</p>
<p>选择训练实例点在选定坐标轴上的<strong>中位数（median）</strong>为切分点，这样得到的$kd$树是平衡的。注意，平衡的$kd$树搜索时的效率未必是最优的。</p>
<p><strong>算法3.2（构造平衡$kd$树）</strong></p>
<p><strong>输入</strong>：$k$维空间数据集$T = \{x_1,x_2,…,x_N\}$，其中$x_i = (x_i^{(1)},x_i^{(2)},…,x_i^{(n)})^T,i=1,2,…,N$；</p>
<p><strong>输出</strong>：$kd$树。</p>
<p>​    （1）开始：构造根节点，根节点对应于包含$T$的$k$维空间的超矩形区域。</p>
<p>​      选择$x^{(1)}$为坐标轴，以$T$中所有实例的$x^{(1)}$坐标的中位数为切分点，将根节点对应的超矩形区域切分为两个子区域。切分由通过切分点并与坐标轴$x^{(1)}$垂直的超平面实现。</p>
<p>​      由根节点生成深度为1的左、右子结点：左子结点对应坐标$x^{(1)}$小于切分点的子区域，右子结点对应于坐标$x^{(1)}$大于切分点的子区域。</p>
<p>​      将落在切分超平面上的实例点保存在根结点。</p>
<p>​    （2）重复：对深度为$j$的结点，选择$x^{(l)}$为切分的坐标轴，$l=j(mod k) + 1$，以该节点的区域中所有实例的$x^{(l)}$坐标的中位数为切分点，将该结点对应的超矩形区域切分为两个子区域。切分由通过切分点并与坐标轴$x^{(l)}$垂直的超平面实现。</p>
<p>​       由该结点生成深度为$j+1$的左、右子结点：左子结点对应坐标$x^{(l)}$小于切分点的子区域，右子结点对应于坐标$x^{(l)}$大于切分点的子区域。</p>
<p>​       将落在切分超平面上的实例点保存在该结点。</p>
<p>​    （3）直到两个子区域没有实例存在时停止。从而形成$kd$树的区域划分。</p>
<h2 id="3-3-2-搜索-kd-树"><a href="#3-3-2-搜索-kd-树" class="headerlink" title="3.3.2 搜索$kd$树"></a>3.3.2 搜索$kd$树</h2><p>给定一个目标点，搜索其最近邻。首先找到包含目标点的叶结点；然后从该叶结点出发，依次回退到父节点；不断查找与目标点最邻近的结点，当确定不可能存在更近的结点时终止。这样搜索就被限制在空间的局部区域上，效率大为提高。</p>
<p>包含目标点的叶结点对应包含目标点的最小超矩形区域。以此叶结点的实例点作为当前最近点。目标点的最近邻一定在以目标点为中心并通过当前最近点的超球体的内部。然后返回当前结点的父结点，如果父结点的另一子结点的超矩形区域与超球体相交，那么在相交的区域内寻找与目标点更近的实例点。如果存在这样的点，将此点作为新的当前最近点。算法转到更上一级的父结点，继续上述过程。如果父结点的另一子结点的超矩形区域与超球体不相交，或不存在比当前最近点更近的点，则停止搜索。</p>
<p><strong>算法3.3（用$kd$树的最近邻搜索）</strong></p>
<p><strong>输入</strong>：已构造的$kd$树，目标点$x$;</p>
<p><strong>输出</strong>：$x$的最近邻。</p>
<p>​    （1）在$kd$树中找出包含目标点$x$的叶结点：从根结点出发，递归地向下访问$kd$树。若目标点$x$当前维的坐标小于切分点的坐标，则移动到左子结点，否则移动到右子结点。知道子结点为叶结点为止。</p>
<p>​    （2）以此叶结点为“当前最近点”。</p>
<p>​    （3）递归地向上回退，在每个结点进行以下操作：</p>
<p>​            （a）如果该结点保存的实例点比当前最近点距离目标点更近，则以该实例点为“当前最近点”。</p>
<p>​            （b）当前最近点一定存在于该结点一个子结点对应的区域。检查该子结点的父结点的另一子结点对应的区域是否有更近的点。具体地，检查另一子结点对    应的区域是否与以目标点为球心、以目标点与“当前最近点”间的距离为半径的超球体相交。</p>
<p>​               如果相交，可能在另一个子结点对应的区域内存在距目标点更近的点，移动到另一个子结点。接着，递归地进行最近邻搜索。</p>
<p>​               如果不相交，，向上回退。</p>
<p>（4）但回退到根结点时，搜索结束。最后的”当前最近点“即为$x$的最近邻点。</p>
<p>如果实例点是随机分布的，$kd$树搜索的平均计算复杂度是$O(logN)$，这里$N$是训练实例数。</p>
<p>$kd$树更适用于训练实例数远大于空间维数时的$k$近邻搜索。当空间维数接近训练实例数时，它的效率会迅速下降，几乎接近线性扫描。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/05/Data%20_Competition/Python_Foundation/%E7%AC%AC%E4%BA%94%E7%AB%A0-if%E8%AF%AD%E5%8F%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/05/Data%20_Competition/Python_Foundation/%E7%AC%AC%E4%BA%94%E7%AB%A0-if%E8%AF%AD%E5%8F%A5/" class="post-title-link" itemprop="url">第五章 if语句</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-05 09:57:10" itemprop="dateCreated datePublished" datetime="2021-06-05T09:57:10+08:00">2021-06-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-02 21:52:28" itemprop="dateModified" datetime="2021-07-02T21:52:28+08:00">2021-07-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">数据竞赛</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/06/05/Data%20_Competition/Python_Foundation/%E7%AC%AC%E4%BA%94%E7%AB%A0-if%E8%AF%AD%E5%8F%A5/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/06/05/Data%20_Competition/Python_Foundation/%E7%AC%AC%E4%BA%94%E7%AB%A0-if%E8%AF%AD%E5%8F%A5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="5-1-一个简单示例"><a href="#5-1-一个简单示例" class="headerlink" title="5.1 一个简单示例"></a>5.1 一个简单示例</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&quot;zhang&quot;</span>, <span class="string">&quot;wang&quot;</span>, <span class="string">&quot;li&quot;</span>, <span class="string">&quot;chen&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">	<span class="keyword">if</span> name == <span class="string">&quot;chen&quot;</span>:</span><br><span class="line">		print(name.upper())</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		print(name)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zhang</span><br><span class="line">wang</span><br><span class="line">li</span><br><span class="line">CHEN</span><br></pre></td></tr></table></figure>
<h1 id="5-2-条件测试"><a href="#5-2-条件测试" class="headerlink" title="5.2 条件测试"></a>5.2 条件测试</h1><p>每条if语句的核心都是一个值为True或False的表达式，这种表达式称为<strong>条件测试</strong>。</p>
<h2 id="5-2-1-检查是否相等"><a href="#5-2-1-检查是否相等" class="headerlink" title="5.2.1 检查是否相等"></a>5.2.1 检查是否相等</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;chen&quot;</span></span><br><span class="line">print(name == <span class="string">&quot;chen&quot;</span>)</span><br><span class="line">print(name == <span class="string">&quot;wang&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<p>这个<strong>相等运算符</strong>在两边的值相等时返回True，否则返回False。</p>
<h2 id="5-2-2-检查是否相等时忽略大小写"><a href="#5-2-2-检查是否相等时忽略大小写" class="headerlink" title="5.2.2 检查是否相等时忽略大小写"></a>5.2.2 检查是否相等时忽略大小写</h2><p>在Python中检查是否相等时区分大小写。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;chen&quot;</span></span><br><span class="line">print(name == <span class="string">&quot;Chen&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">False</span><br></pre></td></tr></table></figure>
<p>如果想忽略大小写，可以使用upper()与lower()函数将变量转换后的副本比较，且不会影响原变量。</p>
<h2 id="5-2-3-检查是否不等"><a href="#5-2-3-检查是否不等" class="headerlink" title="5.2.3 检查是否不等"></a>5.2.3 检查是否不等</h2><p>要判断两个值是否不等，可结合使用惊叹号和等号（!=），其中的惊叹号表示<strong>不</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;chen&quot;</span></span><br><span class="line"><span class="keyword">if</span> name != <span class="string">&quot;li&quot;</span>:</span><br><span class="line">	print(<span class="string">&quot;the name is wrong!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">the name is wrong!</span><br></pre></td></tr></table></figure>
<h2 id="5-2-4-数值比较"><a href="#5-2-4-数值比较" class="headerlink" title="5.2.4 数值比较"></a>5.2.4 数值比较</h2><p>条件语句中可包含各种数学比较，如等于、不等于、小于、小于等于、大于、大于等于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">24</span></span><br><span class="line">print(age == <span class="number">24</span>)</span><br><span class="line">print(age != <span class="number">30</span>)</span><br><span class="line">print(age &lt; <span class="number">18</span>)</span><br><span class="line">print(age &lt;= <span class="number">42</span>)</span><br><span class="line">print(age &gt; <span class="number">30</span>)</span><br><span class="line">print(age &gt;= <span class="number">17</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">True</span><br><span class="line">True</span><br><span class="line">False</span><br><span class="line">True</span><br><span class="line">False</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<h2 id="5-2-5-检查多个条件"><a href="#5-2-5-检查多个条件" class="headerlink" title="5.2.5 检查多个条件"></a>5.2.5 检查多个条件</h2><ol>
<li><strong>使用and检查多个条件</strong></li>
</ol>
<p>如果每个测试都通过了，整个表达式就为True；如果至少一个测试没有通过，整个表达式就为False。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">age1 = <span class="number">24</span></span><br><span class="line"><span class="keyword">if</span>(age &lt; <span class="number">30</span>) <span class="keyword">and</span> (age &gt; <span class="number">18</span>):</span><br><span class="line">	print(<span class="string">&quot;you are young!&quot;</span>)</span><br><span class="line"><span class="keyword">if</span>(age &gt;= <span class="number">30</span>) <span class="keyword">and</span> (age &lt;= <span class="number">100</span>):</span><br><span class="line">	print(<span class="string">&quot;you are so old!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">you are young!</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>使用or检查多个条件</strong></li>
</ol>
<p>关键字or也能检查多个条件，但只要至少一个条件满足，就能通过整个测试。仅当两个测试都没有通过时，使用or的表达式才为False。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">24</span>, <span class="number">34</span>]</span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> numbers:</span><br><span class="line">    <span class="keyword">if</span>(number &lt; <span class="number">30</span>) <span class="keyword">or</span> (number &gt; <span class="number">50</span>):</span><br><span class="line">        print(<span class="string">&quot;you are right!&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&quot;wrong!!!!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">you are right!</span><br><span class="line">wrong!!!!</span><br></pre></td></tr></table></figure>
<h2 id="5-2-6-检查特定值是否包含在列表中"><a href="#5-2-6-检查特定值是否包含在列表中" class="headerlink" title="5.2.6 检查特定值是否包含在列表中"></a>5.2.6 检查特定值是否包含在列表中</h2><p>要判断特定的值是否已包含在列表中，可使用关键字<strong>in</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&quot;zhang&quot;</span>, <span class="string">&quot;wang&quot;</span>, <span class="string">&quot;li&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;chen&quot;</span> <span class="keyword">in</span> names:</span><br><span class="line">	print(<span class="string">&quot;chen in list!&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	print(<span class="string">&quot;chen not in list!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chen not in list!</span><br></pre></td></tr></table></figure>
<h2 id="5-2-7-检查特定值是否不包含在列表中"><a href="#5-2-7-检查特定值是否不包含在列表中" class="headerlink" title="5.2.7 检查特定值是否不包含在列表中"></a>5.2.7 检查特定值是否不包含在列表中</h2><p>还有些时候，确定特定的值未包含在列表中很重要。在这种情况下，可使用关键字<strong>not in</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&quot;zhang&quot;</span>, <span class="string">&quot;wang&quot;</span>, <span class="string">&quot;li&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;chen&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> names:</span><br><span class="line">	print(<span class="string">&quot;chen not in list!&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	print(<span class="string">&quot;chen in list!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chen not in list!</span><br></pre></td></tr></table></figure>
<h2 id="5-2-8-布尔表达式"><a href="#5-2-8-布尔表达式" class="headerlink" title="5.2.8 布尔表达式"></a>5.2.8 布尔表达式</h2><p>布尔表达式是条件测试的别名。与条件表达式一样，布尔表达式的结果要么为True，要么为False。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool_value1 = <span class="literal">True</span></span><br><span class="line">bool_value2 = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h1 id="5-3-if语句"><a href="#5-3-if语句" class="headerlink" title="5.3 if语句"></a>5.3 if语句</h1><p>if语句有很多种，选择使用哪种取决于要测试的条件数。</p>
<h2 id="5-3-1-简单的if语句"><a href="#5-3-1-简单的if语句" class="headerlink" title="5.3.1 简单的if语句"></a>5.3.1 简单的if语句</h2><p>最简单的if语句只有一个测试和一个操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> conditional_test:</span><br><span class="line">	do something</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">19</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">	print(<span class="string">&quot;you are a men!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">you are a men!</span><br></pre></td></tr></table></figure>
<h2 id="5-3-2-if-else语句"><a href="#5-3-2-if-else语句" class="headerlink" title="5.3.2 if-else语句"></a>5.3.2 if-else语句</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">17</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">	print(<span class="string">&quot;you are a men!&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	print(<span class="string">&quot;you are so young!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">you are so young!</span><br></pre></td></tr></table></figure>
<h2 id="5-3-3-if-elif-else结构"><a href="#5-3-3-if-elif-else结构" class="headerlink" title="5.3.3 if-elif-else结构"></a>5.3.3 if-elif-else结构</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">12</span></span><br><span class="line"><span class="keyword">if</span> age &lt; <span class="number">4</span>:</span><br><span class="line">	print(<span class="string">&quot;your cost is ￥0!&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> age &lt; <span class="number">18</span>:</span><br><span class="line">	print(<span class="string">&quot;your cost is ￥25!&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	print(<span class="string">&quot;your cost is ￥40!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">your cost is ￥25!</span><br></pre></td></tr></table></figure>
<h2 id="5-3-4-使用多个elif代码块"><a href="#5-3-4-使用多个elif代码块" class="headerlink" title="5.3.4 使用多个elif代码块"></a>5.3.4 使用多个elif代码块</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">12</span></span><br><span class="line"><span class="keyword">if</span> age &lt; <span class="number">4</span>:</span><br><span class="line">	price = <span class="number">0</span></span><br><span class="line"><span class="keyword">elif</span> age &lt; <span class="number">18</span>:</span><br><span class="line">	price = <span class="number">25</span></span><br><span class="line"><span class="keyword">elif</span> age &lt; <span class="number">65</span></span><br><span class="line">	price = <span class="number">40</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	price = <span class="number">20</span></span><br><span class="line">print(<span class="string">f&quot;your cost is ￥<span class="subst">&#123;price&#125;</span>!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">your cost is ￥25!</span><br></pre></td></tr></table></figure>
<h2 id="5-3-5-省略else代码块"><a href="#5-3-5-省略else代码块" class="headerlink" title="5.3.5 省略else代码块"></a>5.3.5 省略else代码块</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">12</span></span><br><span class="line"><span class="keyword">if</span> age &lt; <span class="number">4</span>:</span><br><span class="line">	price = <span class="number">0</span></span><br><span class="line"><span class="keyword">elif</span> age &lt; <span class="number">18</span>:</span><br><span class="line">	price = <span class="number">25</span></span><br><span class="line"><span class="keyword">elif</span> age &lt; <span class="number">65</span></span><br><span class="line">	price = <span class="number">40</span></span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">65</span>:</span><br><span class="line">	price = <span class="number">20</span></span><br><span class="line">print(<span class="string">f&quot;your cost is ￥<span class="subst">&#123;price&#125;</span>!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">your cost is ￥25!</span><br></pre></td></tr></table></figure>
<h2 id="5-3-6测试多个条件"><a href="#5-3-6测试多个条件" class="headerlink" title="5.3.6测试多个条件"></a>5.3.6测试多个条件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&quot;zhang&quot;</span>, <span class="string">&quot;wang&quot;</span>, <span class="string">&quot;li&quot;</span>, <span class="string">&quot;chen&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;chen&quot;</span> <span class="keyword">in</span> names:</span><br><span class="line">	print(<span class="string">&quot;chen in the list!&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;zhao&quot;</span> <span class="keyword">in</span> names:</span><br><span class="line">	print(<span class="string">&quot;zhao in the list!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chen in the list!</span><br></pre></td></tr></table></figure>
<p>总之，如果只想执行一个代码块，就是用if-elif-else结构；如果要执行多个代码块，就使用一系列独立的if语句。</p>
<h1 id="5-4-使用if语句处理列表"><a href="#5-4-使用if语句处理列表" class="headerlink" title="5.4 使用if语句处理列表"></a>5.4 使用if语句处理列表</h1><p>通过结合使用if语句和列表，对列表中特定的值做特殊处理，可高效地管理不断变化的情形。</p>
<h2 id="5-4-1-检查特殊元素"><a href="#5-4-1-检查特殊元素" class="headerlink" title="5.4.1 检查特殊元素"></a>5.4.1 检查特殊元素</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&quot;zhang&quot;</span>, <span class="string">&quot;wang&quot;</span>, <span class="string">&quot;li&quot;</span>, <span class="string">&quot;chen&quot;</span>]</span><br><span class="line">my_name = <span class="string">&quot;chen&quot;</span></span><br><span class="line"><span class="keyword">if</span> my_name <span class="keyword">in</span> names:</span><br><span class="line">	print(<span class="string">f&quot;mr.<span class="subst">&#123;my_name&#125;</span>,you are in the list!&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	print(<span class="string">f&quot;mr.<span class="subst">&#123;my_name&#125;</span>,you are not in the list!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mr.chen,you are in the list!</span><br></pre></td></tr></table></figure>
<h2 id="5-4-2-确定列表不是空的"><a href="#5-4-2-确定列表不是空的" class="headerlink" title="5.4.2 确定列表不是空的"></a>5.4.2 确定列表不是空的</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">names = []</span><br><span class="line"><span class="keyword">if</span> names:</span><br><span class="line">	print(<span class="string">&quot;list is not empty!&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	print(<span class="string">&quot;list is empty!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list is empty!</span><br></pre></td></tr></table></figure>
<p>在if语句中将列表名用作条件表达式时，Python将在列表至少包含一个元素时返回True，并在列表为空时返回False。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/04/Java_Notes/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/04/Java_Notes/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">Java数据结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-04 21:50:01" itemprop="dateCreated datePublished" datetime="2021-06-04T21:50:01+08:00">2021-06-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-31 16:34:52" itemprop="dateModified" datetime="2021-05-31T16:34:52+08:00">2021-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Java高级教程</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/06/04/Java_Notes/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/06/04/Java_Notes/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java数据结构"><a href="#Java数据结构" class="headerlink" title="Java数据结构"></a>Java数据结构</h1><p>Java工具包提供了强大的数据结构。在Java中的数据结构主要包括以下几种接口和类：</p>
<ul>
<li>枚举（Enumeration）</li>
<li>位集合（BitSet）</li>
<li>向量（Vector）</li>
<li>栈（Stack）</li>
<li>字典（Dictionary）</li>
<li>哈希表（Hashtable）</li>
<li>属性（Properties）</li>
</ul>
<p>以上这些类是传统遗留的，在Java2中引入了一种新的框架-集合框架（Collection）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/04/Statistical_Learning_Methods_Notes/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%84%9F%E7%9F%A5%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/04/Statistical_Learning_Methods_Notes/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%84%9F%E7%9F%A5%E6%9C%BA/" class="post-title-link" itemprop="url">第二章 感知机</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-06-04 20:34:57 / 修改时间：21:19:35" itemprop="dateCreated datePublished" datetime="2021-06-04T20:34:57+08:00">2021-06-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">统计学习方法</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/06/04/Statistical_Learning_Methods_Notes/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%84%9F%E7%9F%A5%E6%9C%BA/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/06/04/Statistical_Learning_Methods_Notes/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%84%9F%E7%9F%A5%E6%9C%BA/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>感知机（perceptron）</strong>是二类分类的线性分类模型，其输入为实例的特征向量，输出为实例的类别，取 $+1$ 和 $-1$ 二值。</p>
<p>感知机对应输入空间（特征空间）中将实例划分为正负两类的<strong>分离超平面（separating hyperplane）</strong>，属于判别模型。感知机学习旨在求出将训练数据进行线性划分的分离超平面。</p>
<p>导入基于误分类的损失函数，利用梯度下降法对损失函数进行极小化，求得感知机模型。</p>
<h1 id="2-1-感知机模型"><a href="#2-1-感知机模型" class="headerlink" title="2.1 感知机模型"></a>2.1 感知机模型</h1><p><strong>定义2.1（感知机）</strong>  假设输入空间（特征空间）是$\chi \subseteq R^n$,输出空间是$Y=\{+1, -1\}$。输入$x \in \chi$表示实例的特征向量，对应于输入空间（特征空间）的点；</p>
<p>输出$y \in Y$表示实例的类别。由输入空间到输出空间的如下函数：</p>
<script type="math/tex; mode=display">
f(x) = sign(\omega·x + b) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (2.1)</script><p>称为感知机。其中，$\omega$和$b$为感知机模型参数，$\omega \in R^n$叫作全职（weight）或权值向量（weight vector），$b \in R$叫作偏置（bias），$\omega·x$表示$\omega$和$x$的内积。$sign$是符号函数，即</p>
<script type="math/tex; mode=display">
sign(x) = \lbrace_{ -1,\ \ x < 0 }^{+1,\ \ x \geq 0}  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (2.2)</script><p>感知机模型的假设空间定义在特征空间中的所有<strong>线性分类模型（linear classification model）</strong>或<strong>线性分类器（linear classifier）</strong>，即函数集合：</p>
<script type="math/tex; mode=display">
\{f|f(x) = \omega·x + b\}</script><p>感知机由如下几何解释：线性方程</p>
<script type="math/tex; mode=display">
\omega·x + b = 0</script><p>对应于特征空间$R^n$中的一个超平面$S$,其中$\omega$是超平面的法向量，$b$是超平面的截距。</p>
<ul>
<li><p>感知机学习，由训练数据集（实力的特征向量及类别）求得感知机模型（2.1），即求得模型参数$\omega,b$。</p>
</li>
<li><p>感知机预测，通过学习得到的感知机模型，对于新的输入实例给出其对应的输出类别。</p>
</li>
</ul>
<h1 id="2-2-感知机学习策略"><a href="#2-2-感知机学习策略" class="headerlink" title="2.2 感知机学习策略"></a>2.2 感知机学习策略</h1><h2 id="2-2-1-数据集的线性可分性"><a href="#2-2-1-数据集的线性可分性" class="headerlink" title="2.2.1 数据集的线性可分性"></a>2.2.1 数据集的线性可分性</h2><p><strong>定义2.2（数据集的线性可分性）</strong>  给定一个数据集</p>
<script type="math/tex; mode=display">
T = \{(x_1,y_1),(x_2,y_2),...,(x_N,y_N)\}</script><p>其中，$x_i \in \chi = R^n, y \in Y = \{+1, -1\}, i=1,2,…,N$，如果存在某个超平面$S$</p>
<script type="math/tex; mode=display">
\omega·x + b = 0</script><p>能够将数据集的正实例点和负实例点完全正确地划分到超平面的两侧，即对所有$y_i=+1$的实例$i$，有$\omega·x + b &gt; 0$，对所有$y_i = -1$的实例$i$，有$\omega·x + b &lt; 0$，则称数据集$T$为线性可分数据集（linearly separable data set）；否则，称数据集$T$线性不可分。</p>
<h2 id="2-2-2-感知机学习策略"><a href="#2-2-2-感知机学习策略" class="headerlink" title="2.2.2 感知机学习策略"></a>2.2.2 感知机学习策略</h2><p>为了找出这样的超平面，即确定感知机模型参数$\omega,b$，需要确定一个学习策略，即定义（经验）损失函数并将损失函数极小化。</p>
<p>损失函数的选择是误分类点到超平面$S$的总距离，这是感知机所采用的。</p>
<ul>
<li>假设超平面$s$的误分类点集合为$M$，那么所有误分类点到超平面$S$的总距离为</li>
</ul>
<script type="math/tex; mode=display">
-\frac{1}{||\omega||}\sum\limits_{x_i \in M} y_i(\omega·x_i + b)</script><p>​        不考虑$\frac{1}{||\omega||}$，就得到感知机学习的损失函数。</p>
<ul>
<li>感知机$sign(\omega·x + b)$学习的损失函数定义为</li>
</ul>
<script type="math/tex; mode=display">
L(\omega,b) =-\sum\limits_{x_i \in M} y_i(\omega·x_i + b) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (2.4)</script><p>​        这个损失函数就是感知机学习的经验风险函数。</p>
<p>显然，损失函数$L(\omega,b)$是非负的。如果没有误分类点，损失函数值是$0$。而且，误分类点越少，误分类点离超平面越近，损失函数值就越小。</p>
<p>一个特定的样本点的损失函数：在误分类时是参数$\omega,b$的线性函数，在正确分类时是$0$。因此，给定训练数据集$T$，损失函数$L(\omega,b)$是$\omega,b$的连续可导函数。</p>
<p>感知机学习的策略是在假设空间中选取使损失函数（2.4）最小的模型参数$\omega,b$，即感知机模型。</p>
<h1 id="2-3-感知机学习算法"><a href="#2-3-感知机学习算法" class="headerlink" title="2.3 感知机学习算法"></a>2.3 感知机学习算法</h1><p>感知机学习算法是对以下最优化问题的算法。</p>
<script type="math/tex; mode=display">
\min\limits_{\omega,b} L(\omega,b) = - \sum\limits_{x_i \in M} y_i(\omega·x_i + b) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (2.5)</script><p>感知机学习算法是误分类驱动的，具体采用随机梯度下降法（stochastic gradient descent）。首先，任意选取一个超平面$\omega_0,b_0$，然后用梯度下降法不断地极小化目标函数(2.5)。极小化过程中不是一次使$M$中所有误分类点的梯度下降，而是一次随机选取一个误分类点使其梯度下降。</p>
<ul>
<li>假设误分类点集合$M$是固定的，那么损失函数$L(\omega,b)$的梯度由</li>
</ul>
<script type="math/tex; mode=display">
\bigtriangledown_{\omega}L(\omega,b) = - \sum\limits_{x_i \in M}y_i x_i</script><script type="math/tex; mode=display">
\bigtriangledown_{b}L(\omega,b) = - \sum\limits_{x_i \in M}y_i</script><p>​        给出。</p>
<ul>
<li><p>随机取一个误分类点$(x_i,y_i)$，对$\omega,b$进行更新：</p>
<script type="math/tex; mode=display">
\omega \longleftarrow \omega \ + \ \eta y_i x_i \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (2.6)</script><script type="math/tex; mode=display">
b \longleftarrow b\ + \ \eta y_i \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (2.7)</script></li>
</ul>
<p>式中$\eta(0&lt;\eta \le 1)$是步长，在统计学习中又称为学习率（learning rate）。这样，通过迭代可以期待损失函数$L(\omega,b)$不断减小，直到为$0$。</p>
<p><strong>算法 2.1（感知机学习算法的原始形式）</strong></p>
<p><strong>输入</strong>：训练数据集$T = \{(x_1,y_1),(x_2,y_2),…,(x_N,y_N)\}$，其中，$x_i \in \chi = R^n, y \in Y = \{+1, -1\}, i=1,2,…,N$；学习率$\eta(0&lt;\eta \le 1)$；</p>
<p><strong>输出</strong>：$\omega,b$；感知机模型$f(x)=sign(\omega·x + b)$。</p>
<p>​    （1）选取初值$\omega_0,b_0$；</p>
<p>​    （2）在训练集中选取数据$(x_i,y_i)$；</p>
<p>​    （3）如果$y_i(\omega·x_i + b) \leq 0$，</p>
<script type="math/tex; mode=display">
\omega \longleftarrow \omega \ + \ \eta y_i x_i  \\   b \longleftarrow b\ + \ \eta y_i</script><p>​    （4）转至（2），直至训练集中没有误分类点。</p>
<p>这种学习算法直观上有如下解释：当一个实例点被误分类，即位于分离超平面的错误一侧时，则调整$\omega,b$的值，使分离超平面向该误分类点的一侧移动，以减少该误分类点与超平面间的距离，直至超平面越过该误分类点使其被正确分类。</p>
<p>感知机学习算法由于采用不同的初值或选取不同的误分类点，解可以不同。</p>
<h2 id="2-3-2-算法的收敛性"><a href="#2-3-2-算法的收敛性" class="headerlink" title="2.3.2 算法的收敛性"></a>2.3.2 算法的收敛性</h2><p>为了便于叙述与推导，将偏置$b$并入权重向量$\omega$，记作$\hat\omega = (\omega^T,b)^T$，同样也将输入向量加以扩充，加进常数$1$，记作$\hat x=(x^T,1)^T$。这样，$\hat x \in R^{n+1},\hat\omega \in R^{n+1}$。显然，$\hat\omega·\hat x = \omega·x + b$。</p>
<p><strong>定理 2.1（Novikoff）</strong>  设训练数据集$T = \{(x_1,y_1),(x_2,y_2),…,(x_N,y_N)\}$，其中，$x_i \in \chi = R^n, y \in Y = \{+1, -1\}, i=1,2,…,N$，则</p>
<p>​    （1）存在满足条件$||\hat\omega_{opt}||=1$的超平面$\hat\omega_{opt}·\hat x =\omega_{opt}·x+b_{opt} = 0$将训练数据集完全正确分开；且存在$\gamma&gt;0$，对所有$i=1,2,…,N$</p>
<script type="math/tex; mode=display">
y_i(\hat\omega_{opt}·\hat x_i) = y_i(\omega_{opt}·x_i+b_{opt}) \geq \gamma \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (2.8)</script><p>​    （2）令$R=\max\limits_{1\leq i \leq N}||\hat x_i||$，则感知机算法2.1在训练数据集上的误分类次数$k$满足不等式</p>
<script type="math/tex; mode=display">
k \leq(\frac{R}{\gamma})^2) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (2.9)</script><p>定理表明，误分类的次数$k$是有上界的，经过有限次搜索可以找到将训练数据完全正确分开的分离超平面。也就是说，当训练数据集线性可分时，感知机学习算法原始形式迭代是收敛的。</p>
<p>感知机学习算法存在许多解，这些解既依赖与初值的选择，也依赖于迭代过程中误分类点的选择顺序。为了得到唯一的超平面，需要对分离超平面增加约束条件。</p>
<p>当训练集线性不可分时，感知机学习算法不收敛，迭代结果会放生震荡。</p>
<h2 id="2-3-3-感知机学习算法的对偶形式"><a href="#2-3-3-感知机学习算法的对偶形式" class="headerlink" title="2.3.3 感知机学习算法的对偶形式"></a>2.3.3 感知机学习算法的对偶形式</h2><p>对偶形式的基本想法是，将$\omega$和$b$表示为实例$x_i$和标记$y_i$的线性组合的形式，通过求解其系数而求得$\omega$和$b$。</p>
<p>在算法2.1中可假设初始值$\omega_0,b_0$均为0。对误分类点$(x_i,y_i)$通过</p>
<script type="math/tex; mode=display">
\omega \longleftarrow \omega \ + \ \eta y_i x_i  \\   b \longleftarrow b\ + \ \eta y_i</script><p>逐步修改$\omega,b$，设修改$n$次，则$\omega,b$关于$(x_i,y_i)$的增量分别是$\alpha_i y_i x_i$和$\alpha_i y_i$，这里$\alpha_i = n_i\eta$，$n_i$是点$(x_i,y_i)$被误分类的次数。最后学习到的$\omega,b$可以分别表示为</p>
<script type="math/tex; mode=display">
\omega = \sum\limits_{i=1}^N \alpha_i y_i x_i \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (2.14) \\ b = \sum\limits_{i=1}^N \alpha_i y_i \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (2.15)</script><p>这里，$\alpha_i \geq 0,i=1,2,…,N$，当$\eta = 1$时，表示第$i$个实例点由与误分而进行更新的次数。实例点更新次数越多，意味着它距离分离超平面越近，也就越难正确分类。换句话说，这样的实例对学习结果影响最大。</p>
<p><strong>算法 2.2（感知机学习算法的对偶形式）</strong></p>
<p><strong>输入</strong>：训练数据集$T = \{(x_1,y_1),(x_2,y_2),…,(x_N,y_N)\}$，其中，$x_i \in \chi = R^n, y \in Y = \{+1, -1\}, i=1,2,…,N$；学习率$\eta(0&lt;\eta \le 1)$；</p>
<p><strong>输出</strong>：$\alpha,b$；感知机模型$f(x)=sign(\sum\limits_{j=1}^N \alpha_j y_j x_j · x + b)$，其中$\alpha = (\alpha_1, \alpha_2,…,\alpha_N)^T$。</p>
<p>​    （1）$\alpha \longleftarrow 0, b \longleftarrow 0$；</p>
<p>​    （2）在训练集中选取数据$(x_i,y_i)$；</p>
<p>​    （3）如果$y_i(\sum\limits_{j=1}^N \alpha_j y_j x_j · x + b) \leq 0$，</p>
<script type="math/tex; mode=display">
\alpha_i \longleftarrow \alpha_i \ + \ \eta \\ b \longleftarrow b \ + \ \eta y_i</script><p>​    （4）转至（2）直到没有误分类数据。</p>
<p>对偶形式中训练实例仅以内积的形式出现。为了方便，可以预先将训练集中实例间的内积计算出来并以矩阵的形式存储，这个矩阵就是所谓的$Gram$矩阵（Gram matrix）</p>
<script type="math/tex; mode=display">
G = [x_i · x_j]_{N \times N}</script><p>与原始形式一样，感知机学习算法的对偶形式迭代是收敛的，存在多个解。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/default-index/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/default-index/">1</a><a class="page-number" href="/default-index/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/default-index/page/4/">4</a><a class="page-number" href="/default-index/page/5/">5</a><a class="extend next" rel="next" href="/default-index/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Normal People"
      src="/images/posthead.jpg">
  <p class="site-author-name" itemprop="name">Normal People</p>
  <div class="site-description" itemprop="description">Get busy living or get busy dying</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/TheNormalPeople" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;TheNormalPeople" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1272481411@qq.com" title="E-Mail → mailto:1272481411@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5938927274" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5938927274" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/cy19970506" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;cy19970506" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Normal People</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'y8XFURQNCoQsprRTou9DiEJu-gzGzoHsz',
      appKey     : 'QfVpjKDtJQdJrnJNnWUbVvjH',
      placeholder: "留下邮箱,有空时间回复您！",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
