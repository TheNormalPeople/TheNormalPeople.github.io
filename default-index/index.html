<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true,"scrollpercent":true,"b2t":true},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Get busy living or get busy dying">
<meta property="og:type" content="website">
<meta property="og:title" content="Blog">
<meta property="og:url" content="http://example.com/default-index/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="Get busy living or get busy dying">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Normal People">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/default-index/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">by Normal People</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">17</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">42</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/05/BigData/Kafka/kafka/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/05/BigData/Kafka/kafka/" class="post-title-link" itemprop="url">Kafka</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-05 15:04:43 / 修改时间：22:46:59" itemprop="dateCreated datePublished" datetime="2023-04-05T15:04:43+08:00">2023-04-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BigData/" itemprop="url" rel="index"><span itemprop="name">BigData</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BigData/Kafka/" itemprop="url" rel="index"><span itemprop="name">Kafka</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/04/05/BigData/Kafka/kafka/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/04/05/BigData/Kafka/kafka/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-Kafka概述"><a href="#一-Kafka概述" class="headerlink" title="一.Kafka概述"></a>一.Kafka概述</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p>Kafka最新定义：Kafka是一个开源的分布式事件流平台（Event Streaming Flatform），被数千家公司用于高性能==数据管道==、==流分析==、==数据集成==和==关键任务应用==。</p>
<h2 id="2-消息队列"><a href="#2-消息队列" class="headerlink" title="2.消息队列"></a>2.消息队列</h2><h3 id="1）消息队列的应用场景"><a href="#1）消息队列的应用场景" class="headerlink" title="1）消息队列的应用场景"></a>1）消息队列的应用场景</h3><p>传统的消息队列的主要应用场景包括：缓存/消峰、解耦和异步通信。</p>
<p><img src="https://raw.githubusercontent.com/TheNormalPeople/BlogImage/main/img/20230405222431.png" alt="缓冲消峰"></p>
<p><img src="https://raw.githubusercontent.com/TheNormalPeople/BlogImage/main/img/20230405222453.png" alt="解耦"></p>
<p><img src="https://raw.githubusercontent.com/TheNormalPeople/BlogImage/main/img/20230405222540.png" alt="异步通信"></p>
<h3 id="2）消息队列的两种模式"><a href="#2）消息队列的两种模式" class="headerlink" title="2）消息队列的两种模式"></a>2）消息队列的两种模式</h3><p><img src="https://raw.githubusercontent.com/TheNormalPeople/BlogImage/main/img/20230405222556.png" alt="消息队列的两种模式"></p>
<h2 id="3-Kafka基础架构"><a href="#3-Kafka基础架构" class="headerlink" title="3.Kafka基础架构"></a>3.Kafka基础架构</h2><p><img src="https://raw.githubusercontent.com/TheNormalPeople/BlogImage/main/img/20230405222607.png" alt="Kafka基础架构"></p>
<h3 id="1）Producer"><a href="#1）Producer" class="headerlink" title="1）Producer"></a>1）Producer</h3><p>消息生产者，就是向Kafka broker发消息的客户端。</p>
<h3 id="2）Consumer"><a href="#2）Consumer" class="headerlink" title="2）Consumer"></a>2）Consumer</h3><p>消息消费者，向Kafka broker取消息的客户端。</p>
<h3 id="3）Consumer-Group（CG）"><a href="#3）Consumer-Group（CG）" class="headerlink" title="3）Consumer Group（CG）"></a>3）Consumer Group（CG）</h3><p>消费者组，由多个consumer组成。==消费者组内每个消费者负责消费不同分区的数据，一个分区只能由一个组内消费者消费==；消费者组之间互不影响。所有的消费者都属于某个消费者组，即==消费者组是逻辑上的一个订阅者==。</p>
<h3 id="4）Broker"><a href="#4）Broker" class="headerlink" title="4）Broker"></a>4）Broker</h3><p>==一台Kafka服务器就是一个broker==。一个集群由多个broker组成。==一个broker可以容纳多个topic==。</p>
<h3 id="5）Topic"><a href="#5）Topic" class="headerlink" title="5）Topic"></a>5）Topic</h3><p>可以理解为一个队列，生产者和消费者面向的都是一个topic。</p>
<h3 id="6）Partition"><a href="#6）Partition" class="headerlink" title="6）Partition"></a>6）Partition</h3><p>为了实现扩展性，一个非常大的topic可以分布到多个broker（即服务器）上，==一个topic可以分为多个partition，每个partition是一个有序的队列==。</p>
<h3 id="7）Replica"><a href="#7）Replica" class="headerlink" title="7）Replica"></a>7）Replica</h3><p>副本。==一个topic的每个分区都有若干个副本，一个Leader和若干个Follower==。</p>
<h3 id="8）Leader"><a href="#8）Leader" class="headerlink" title="8）Leader"></a>8）Leader</h3><p>每个分区多个副本的“主”，==生产者发送数据的对象，以及消费者消费数据的对象都是Leader==。</p>
<h3 id="9）Follower"><a href="#9）Follower" class="headerlink" title="9）Follower"></a>9）Follower</h3><p>每个分区多个副本中的“从”，==实时从Leader中同步数据，保持和Leader数据的同步==。Leader发生故障时，某个Follower会成为新的Leader。</p>
<h1 id="二-Kafka生产者"><a href="#二-Kafka生产者" class="headerlink" title="二.Kafka生产者"></a>二.Kafka生产者</h1><h2 id="1-生产者消息发送流程"><a href="#1-生产者消息发送流程" class="headerlink" title="1.生产者消息发送流程"></a>1.生产者消息发送流程</h2><h3 id="1）发送原理"><a href="#1）发送原理" class="headerlink" title="1）发送原理"></a>1）发送原理</h3><p>在消息发送的过程中，涉及到了两个线程——==main线程==和==Sender线程==。</p>
<ul>
<li><p>在main线程中创建了一个双端队列RecordAccumulator。main线程将消息发送给RecordAccumulator；</p>
</li>
<li><p>Sender线程不断从RecordAccumulator中拉取消息发送到Kafka Broker。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/TheNormalPeople/BlogImage/main/img/20230405223559.png" alt="消费者发送流程"></p>
<h2 id="2-异步发送API"><a href="#2-异步发送API" class="headerlink" title="2.异步发送API"></a>2.异步发送API</h2><h3 id="1）带回调函数的异步发送"><a href="#1）带回调函数的异步发送" class="headerlink" title="1）带回调函数的异步发送"></a>1）带回调函数的异步发送</h3><p>回调函数会在producer收到ack时调用，为异步调用，该方法有两个参数，分别是==元数据信息（RecordMetadata）==和==异常信息（Exception）==，<strong>如果Exception为null，说明消息发送成功，如果Exception不为null，说明消息发送失败</strong>。</p>
<p>==注意：消息发送失败会自动重试，不需要我们在回调函数中手动重试。==</p>
<h2 id="3-同步发送API"><a href="#3-同步发送API" class="headerlink" title="3.同步发送API"></a>3.同步发送API</h2><h2 id="4-生产者分区"><a href="#4-生产者分区" class="headerlink" title="4.生产者分区"></a>4.生产者分区</h2><h3 id="1）分区好处"><a href="#1）分区好处" class="headerlink" title="1）分区好处"></a>1）分区好处</h3><p><img src="https://raw.githubusercontent.com/TheNormalPeople/BlogImage/main/img/20230405223613.png" alt="Kafka分区好处"></p>
<ul>
<li><strong>默认的分区器 DefaultPartitioner</strong>  </li>
</ul>
<p><img src="https://raw.githubusercontent.com/TheNormalPeople/BlogImage/main/img/20230405223626.png" alt="Kafka分区原则"></p>
<h2 id="5-生产经验"><a href="#5-生产经验" class="headerlink" title="5.生产经验"></a>5.生产经验</h2><h3 id="1）生产者如何提高吞吐量"><a href="#1）生产者如何提高吞吐量" class="headerlink" title="1）生产者如何提高吞吐量"></a>1）生产者如何提高吞吐量</h3><p><img src="https://raw.githubusercontent.com/TheNormalPeople/BlogImage/main/img/20230405223640.png" alt="生产者如何提高吞吐量"></p>
<ul>
<li>批次写入</li>
<li>数据压缩</li>
<li>增大缓冲区</li>
</ul>
<h3 id="2）数据可靠性"><a href="#2）数据可靠性" class="headerlink" title="2）数据可靠性"></a>2）数据可靠性</h3><p><img src="https://raw.githubusercontent.com/TheNormalPeople/BlogImage/main/img/20230405223655.png" alt="ACK应答级别"></p>
<p><img src="https://raw.githubusercontent.com/TheNormalPeople/BlogImage/main/img/20230405223712.png" alt="ACK应答级别之可靠性总结"></p>
<h3 id="3）数据去重"><a href="#3）数据去重" class="headerlink" title="3）数据去重"></a>3）数据去重</h3><p><img src="https://raw.githubusercontent.com/TheNormalPeople/BlogImage/main/img/20230405223735.png" alt="数据传递语义"></p>
<p><img src="https://raw.githubusercontent.com/TheNormalPeople/BlogImage/main/img/20230405223816.png" alt="幂等性原理"></p>
<p>==注：开启参数<strong>enable.idempotence</strong> 默认为true，false关闭。==</p>
<p><img src="https://raw.githubusercontent.com/TheNormalPeople/BlogImage/main/img/20230405223828.png" alt="kafka事务原理"></p>
<h3 id="4）数据有序"><a href="#4）数据有序" class="headerlink" title="4）数据有序"></a>4）数据有序</h3><p><img src="https://raw.githubusercontent.com/TheNormalPeople/BlogImage/main/img/20230405223843.png" alt="数据有序"></p>
<h3 id="5）数据乱序"><a href="#5）数据乱序" class="headerlink" title="5）数据乱序"></a>5）数据乱序</h3><p><img src="https://raw.githubusercontent.com/TheNormalPeople/BlogImage/main/img/20230405224624.png" alt="数据乱序"></p>
<h1 id="三-Kafka-Broker"><a href="#三-Kafka-Broker" class="headerlink" title="三.Kafka Broker"></a>三.Kafka Broker</h1><h2 id="1-Kafka-Broker工作流程"><a href="#1-Kafka-Broker工作流程" class="headerlink" title="1.Kafka Broker工作流程"></a>1.Kafka Broker工作流程</h2><h3 id="1）Zookeeper存储的Kafka信息"><a href="#1）Zookeeper存储的Kafka信息" class="headerlink" title="1）Zookeeper存储的Kafka信息"></a>1）Zookeeper存储的Kafka信息</h3><p><img src="kafka/Zookeeper%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84Kafka%E4%BF%A1%E6%81%AF.png" alt="Zookeeper中存储的Kafka信息"></p>
<ul>
<li><strong>/kafka/brokers/ids 记录有哪些服务器</strong>。</li>
<li><strong>/kafka/brokers/topics/xxx/partition/0/state 记录谁是Leader，有哪些服务器可用</strong>。</li>
<li><strong>/kafka/controller 辅助选举Leader</strong>。</li>
<li><strong>offset存储在kafka主题中</strong>。</li>
</ul>
<h3 id="2）Kafka-Broker总体工作流程"><a href="#2）Kafka-Broker总体工作流程" class="headerlink" title="2）Kafka Broker总体工作流程"></a>2）Kafka Broker总体工作流程</h3><p><img src="https://raw.githubusercontent.com/TheNormalPeople/BlogImage/main/img/20230405223854.png" alt="Kafka Broker总体工作流程"></p>
<h2 id="2-Kafka副本"><a href="#2-Kafka副本" class="headerlink" title="2.Kafka副本"></a>2.Kafka副本</h2><h3 id="1）副本基本信息"><a href="#1）副本基本信息" class="headerlink" title="1）副本基本信息"></a>1）副本基本信息</h3><p>（1）Kafka副本作用：<strong>提高数据可靠性</strong>。</p>
<p>（2）Kafka默认副本1个，生产环境一般配置为2个，保证数据可靠性；太多副本会增加磁盘存储空间，增加网络上数据传输，降低效率。</p>
<p>（3）Kafka中副本分为：Leader和Follower。<strong>Kafka生产者只会把数据发往Leader，然后Follower找Leader进行同步数据。</strong></p>
<p>（4）Kafka分区中的所有副本统称为AR（Assigned Repllicas）。</p>
<p>​    ==AR = ISR + OSR==</p>
<p>​    ==ISR==，<strong>表示和Leader保持同步的Follower集合</strong>。如果Follower长时间未向Leader发送通信请求或同步数据，则该Follower将被踢出ISR。该时间阈值由replica.lag.time.max.ms参数设定，默认30s。<strong>Leader发生故障之后，就会从ISR中选举新的Leader</strong>。</p>
<p>​    ==OSR==，表示Follower与Leader副本同步时，延迟过多的副本。</p>
<h3 id="2）Leader和Follower故障处理细节"><a href="#2）Leader和Follower故障处理细节" class="headerlink" title="2）Leader和Follower故障处理细节"></a>2）Leader和Follower故障处理细节</h3><p><img src="https://raw.githubusercontent.com/TheNormalPeople/BlogImage/main/img/20230405223909.png" alt="Follower故障处理细节"></p>
<p><img src="https://raw.githubusercontent.com/TheNormalPeople/BlogImage/main/img/20230405223921.png" alt="Leader故障处理细节"></p>
<h2 id="3-文件存储"><a href="#3-文件存储" class="headerlink" title="3.文件存储"></a>3.文件存储</h2><h3 id="1）文件存储机制"><a href="#1）文件存储机制" class="headerlink" title="1）文件存储机制"></a>1）文件存储机制</h3><ul>
<li><p><strong>Topic数据的存储机制</strong>  </p>
<p><img src="https://raw.githubusercontent.com/TheNormalPeople/BlogImage/main/img/20230405223932.png" alt="Kafka文件存储机制"></p>
</li>
<li><p><strong>index文件和log文件详解</strong>  </p>
<p><img src="https://raw.githubusercontent.com/TheNormalPeople/BlogImage/main/img/20230405223951.png" alt="index文件和log文件详解"></p>
</li>
</ul>
<h3 id="2）文件清理策略"><a href="#2）文件清理策略" class="headerlink" title="2）文件清理策略"></a>2）文件清理策略</h3><p>Kafka中默认的日志保存时间为7天，可以通过调整如下参数修改保存时间。</p>
<ul>
<li><p><strong>log.retention.hours</strong>，最低优先级小时，<strong>默认7天</strong>。</p>
</li>
<li><p><strong>log.retention.minutes</strong>，分钟。</p>
</li>
<li><p><strong>log.retention.ms</strong>，最高优先级毫秒。</p>
</li>
<li><p><strong>log.retention.check.interval.ms</strong>，负责设置检查周期，默认5分钟。</p>
</li>
</ul>
<p>那么日志一旦超过了设置的时间，怎么处理呢？</p>
<p><strong>Kafka中提供的日志清理策略有==delete==和==compact==两种</strong>。</p>
<p>delete日志删除：将过期数据删除</p>
<ul>
<li>[x] ==log.cleanup.policy = delete 所有数据启用删除策略==</li>
</ul>
<p>（1）<strong>基于时间：默认打开</strong>。以segment中所有记录中的最大时间戳作为该文件时间戳。</p>
<p>（2）<strong>基于大小：默认关闭</strong>。超过设置的所有日志总大小，删除最早的segment。</p>
<p>log.retention.bytes，默认等于-1，表示无穷大。</p>
<p><strong>思考：</strong>如果一个segment中有一部分数据过期，一部分没有过期，怎么处理？</p>
<ul>
<li>[x] ==compact日志压缩==  </li>
</ul>
<p><img src="https://raw.githubusercontent.com/TheNormalPeople/BlogImage/main/img/20230405224003.png" alt="compact日志压缩"></p>
<h2 id="4-高效读写数据"><a href="#4-高效读写数据" class="headerlink" title="4.高效读写数据"></a>4.高效读写数据</h2><ul>
<li>[x] <strong>Kafka本身是分布式集群，可以采用分区技术，并行度高</strong></li>
<li>[x] <strong>读数据采用稀疏索引，可以快速定位要消费的数据</strong></li>
<li>[x] <strong>顺序写磁盘</strong></li>
<li>[x] <strong>页缓存 + 零拷贝技术</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/TheNormalPeople/BlogImage/main/img/20230405224020.png" alt="页缓存+零拷贝技术"></p>
<h1 id="四-Kafka消费者"><a href="#四-Kafka消费者" class="headerlink" title="四.Kafka消费者"></a>四.Kafka消费者</h1><h2 id="1-Kafka消费方式"><a href="#1-Kafka消费方式" class="headerlink" title="1.Kafka消费方式"></a>1.Kafka消费方式</h2><p><img src="https://raw.githubusercontent.com/TheNormalPeople/BlogImage/main/img/20230405224151.png" alt="Kafka消费方式"></p>
<h2 id="2-Kafka消费者工作流程"><a href="#2-Kafka消费者工作流程" class="headerlink" title="2.Kafka消费者工作流程"></a>2.Kafka消费者工作流程</h2><h3 id="1）消费者总体工作流程"><a href="#1）消费者总体工作流程" class="headerlink" title="1）消费者总体工作流程"></a>1）消费者总体工作流程</h3><p><img src="https://raw.githubusercontent.com/TheNormalPeople/BlogImage/main/img/20230405224203.png" alt="Kafka消费者总体工作流程"></p>
<h3 id="2）消费者组原理"><a href="#2）消费者组原理" class="headerlink" title="2）消费者组原理"></a>2）消费者组原理</h3><p><img src="https://raw.githubusercontent.com/TheNormalPeople/BlogImage/main/img/20230405224217.png" alt="消费者组01"></p>
<p><img src="https://raw.githubusercontent.com/TheNormalPeople/BlogImage/main/img/20230405224229.png" alt="消费者组02"></p>
<p><img src="https://raw.githubusercontent.com/TheNormalPeople/BlogImage/main/img/20230405224241.png" alt="消费者组初始化流程"></p>
<p><img src="https://raw.githubusercontent.com/TheNormalPeople/BlogImage/main/img/20230405224252.png" alt="消费者组详细消费流程"></p>
<h2 id="3-消费者API"><a href="#3-消费者API" class="headerlink" title="3.消费者API"></a>3.消费者API</h2><p><strong>注意：在消费者API代码中必须配置消费者组id。命令行启动消费者不填写消费者组id会被自动填写随机的消费者组id。</strong></p>
<h2 id="4-分区的分配以及再平衡"><a href="#4-分区的分配以及再平衡" class="headerlink" title="4.分区的分配以及再平衡"></a>4.分区的分配以及再平衡</h2><p><img src="https://raw.githubusercontent.com/TheNormalPeople/BlogImage/main/img/20230405224311.png" alt="分区的分配及以及再平衡"></p>
<p><strong>说明：Kafka默认的分区分配策略就是Range + CooperativeSticky，所以不需要修改策略。</strong></p>
<h3 id="1）Range以及再平衡"><a href="#1）Range以及再平衡" class="headerlink" title="1）Range以及再平衡"></a>1）Range以及再平衡</h3><p><img src="https://raw.githubusercontent.com/TheNormalPeople/BlogImage/main/img/20230405224336.png" alt="分区分配策略之Range"></p>
<p><strong>注意：分区数可以增加，但是不能减少。</strong></p>
<h3 id="2）RoundRobin以及再平衡"><a href="#2）RoundRobin以及再平衡" class="headerlink" title="2）RoundRobin以及再平衡"></a>2）RoundRobin以及再平衡</h3><p><img src="https://raw.githubusercontent.com/TheNormalPeople/BlogImage/main/img/20230405224348.png" alt="分区分配策略之RoundRobin"></p>
<h3 id="3）Sticky以及再平衡"><a href="#3）Sticky以及再平衡" class="headerlink" title="3）Sticky以及再平衡"></a>3）Sticky以及再平衡</h3><p><strong>粘性分区定义：</strong>可以理解为分配的结果带有“粘性的”。即在执行一次新的分配之前，考虑上一次分配的结果，尽量少的调整分配的变动，可以节省大量的开销。</p>
<p>粘性分区是Kafka从0.11.x版本开始引入这种分配策略，首先会尽量均衡的放置分区到消费者上面，在出现同一消费者组内消费者出现问题的时候，会尽量保持原有分配的分区不变化。</p>
<h2 id="5-offset位移"><a href="#5-offset位移" class="headerlink" title="5.offset位移"></a>5.offset位移</h2><h3 id="1）offset的默认维护位置"><a href="#1）offset的默认维护位置" class="headerlink" title="1）offset的默认维护位置"></a>1）offset的默认维护位置</h3><p><img src="https://raw.githubusercontent.com/TheNormalPeople/BlogImage/main/img/20230405224405.png" alt="offset的默认维护位置"></p>
<p><strong>__consumer_offsets</strong>主题里面采用key和value的方式存储数据。</p>
<ul>
<li><p><strong>key是group.id+topic+分区号</strong>；</p>
</li>
<li><p><strong>value就是当前offset的值</strong>。</p>
</li>
</ul>
<p>每隔一段时间，kafka内部会对这个topic进行compact，也就是每个group.id+topic+分区号就保留最新数据。</p>
<h3 id="2）自动提交offset"><a href="#2）自动提交offset" class="headerlink" title="2）自动提交offset"></a>2）自动提交offset</h3><p><img src="https://raw.githubusercontent.com/TheNormalPeople/BlogImage/main/img/20230405224420.png" alt="自动提交offset"></p>
<h3 id="3）手动提交offset"><a href="#3）手动提交offset" class="headerlink" title="3）手动提交offset"></a>3）手动提交offset</h3><p><img src="https://raw.githubusercontent.com/TheNormalPeople/BlogImage/main/img/20230405224431.png" alt="手动提交offset"></p>
<h3 id="4）指定Offset消费"><a href="#4）指定Offset消费" class="headerlink" title="4）指定Offset消费"></a>4）指定Offset消费</h3><p>auto.offset.reset = earliest | latest | none   默认是latest。</p>
<p>当Kafka中没有初始偏移量（消费者组第一次消费）或服务器上不再存在当前偏移量时（例如该数据已被删除），该怎么办？</p>
<p>（1）earliest：自动将偏移量重置为最早的偏移量，—from-beginning。</p>
<p>（2）latest（默认值）：自动将偏移量重置为最新偏移量。</p>
<p>（3）none：如果未找到消费者组的先前偏移量，则向消费者抛出异常。            </p>
<p>（4）任意指定offset位移开始消费</p>
<h3 id="5）漏消费和重复消费"><a href="#5）漏消费和重复消费" class="headerlink" title="5）漏消费和重复消费"></a>5）漏消费和重复消费</h3><ul>
<li><p><strong>重复消费：</strong>已经消费了数据，但是offset没提交。</p>
</li>
<li><p><strong>漏消费：</strong>先提交offset后消费，有可能会造成数据的漏消费。</p>
<p><img src="https://raw.githubusercontent.com/TheNormalPeople/BlogImage/main/img/20230405224443.png" alt="重复消费与漏消费"></p>
</li>
</ul>
<h2 id="6-消费者事务"><a href="#6-消费者事务" class="headerlink" title="6.消费者事务"></a>6.消费者事务</h2><p><img src="https://raw.githubusercontent.com/TheNormalPeople/BlogImage/main/img/20230405224459.png" alt="消费者事务"></p>
<h2 id="7-数据积压（消费者如何提高吞吐量）"><a href="#7-数据积压（消费者如何提高吞吐量）" class="headerlink" title="7.数据积压（消费者如何提高吞吐量）"></a>7.数据积压（消费者如何提高吞吐量）</h2><p><img src="https://raw.githubusercontent.com/TheNormalPeople/BlogImage/main/img/20230405224517.png" alt="数据积压"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/04/BigData/Hive/Hive/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/04/BigData/Hive/Hive/" class="post-title-link" itemprop="url">Hive</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-04 22:03:42 / 修改时间：22:09:50" itemprop="dateCreated datePublished" datetime="2023-04-04T22:03:42+08:00">2023-04-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BigData/" itemprop="url" rel="index"><span itemprop="name">BigData</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BigData/Hive/" itemprop="url" rel="index"><span itemprop="name">Hive</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/04/04/BigData/Hive/Hive/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/04/04/BigData/Hive/Hive/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-Hive入门"><a href="#一-Hive入门" class="headerlink" title="一.Hive入门"></a>一.Hive入门</h1><h2 id="1-什么是Hive"><a href="#1-什么是Hive" class="headerlink" title="1.什么是Hive"></a>1.什么是Hive</h2><p>Hive是由Facebook开源，基于Hadoop的一个<strong>==数据仓库工具==</strong>，可以将==结构化的数据文件映射为一张表==，并提供==类SQL==查询功能。</p>
<h2 id="2-Hive本质"><a href="#2-Hive本质" class="headerlink" title="2.Hive本质"></a>2.<strong>Hive本质</strong></h2><p>Hive是一个Hadoop客户端，用于==将HQL（Hive SQL）转化成MapReduce程序==。</p>
<p>（1）Hive中每张表的==数据存储在HDFS==；</p>
<p>（2）Hive分析数据底层的实现是MapReduce（也可配置为Spark或者Tez）；</p>
<p>（3）执行==程序运行在Yarn==上 。</p>
<h2 id="3-Hive架构原理"><a href="#3-Hive架构原理" class="headerlink" title="3.Hive架构原理"></a>3.Hive架构原理</h2><p><img src="ipic/Hive架构原理.png" alt="Hive架构原理"></p>
<ul>
<li><strong>用户接口：Client</strong></li>
</ul>
<p>CLI（command-line interface）、JDBC/ODBC。</p>
<p>==说明：JDBC和ODBC的区别。==</p>
<ol>
<li>JDBC的移植性比ODBC好；（通常情况下，安装完ODBC驱动程序之后，还需要经过确定的配置才能够应用。而不相同的配置在不相同数据库服务器之间不能够通用。所以，安装一次就需要再配置一次。JDBC只需要选取适当的JDBC数据库驱动程序，就不需要额外的配置。在安装过程中，JDBC数据库驱动程序会自己完成有关的配置。）</li>
<li>两者使用的语言不同，JDBC在Java编程时使用，ODBC一般在C/C++编程时使用。  </li>
</ol>
<ul>
<li><strong>元数据：Metastore</strong>  </li>
</ul>
<p>元数据包括：数据库（默认是default）、表名、表的拥有者、列/分区字段、表的类型（是否是外部表）、表的数据所在目录等。默认存储在自带的derby数据库中，由于derby数据库只支持单客户端访问，生产环境中为了多人开发，推荐使用MySQL存储Metastore。</p>
<ul>
<li><strong>驱动器：Driver</strong>  </li>
</ul>
<ol>
<li>==解析器（SQLParser）==：将SQL字符串转换成抽象语法树（AST）</li>
<li>==语义分析（Semantic Analyzer）==：将AST进一步划分为QeuryBlock</li>
<li>==逻辑计划生成器（Logical Plan Gen）==：将语法树生成逻辑计划</li>
<li>==逻辑优化器（Logical Optimizer）==：对逻辑计划进行优化</li>
<li>==物理计划生成器（Physical Plan Gen）==：根据优化后的逻辑计划生成物理计划</li>
<li>==物理优化器（Physical Optimizer）==：对物理计划进行优化</li>
<li>==执行器（Execution）==：执行该计划，得到查询结果并返回给客户端</li>
</ol>
<ul>
<li><strong>Hadoop</strong>  </li>
</ul>
<p>使用HDFS进行存储，可以选择MapReduce/Tez/Spark进行计算。</p>
<h1 id="二-DDL（Data-Definition-Language）数据定义"><a href="#二-DDL（Data-Definition-Language）数据定义" class="headerlink" title="二.DDL（Data Definition Language）数据定义"></a>二.DDL（Data Definition Language）数据定义</h1><h2 id="1-数据库（database）"><a href="#1-数据库（database）" class="headerlink" title="1.数据库（database）"></a>1.数据库（database）</h2><h3 id="1）创建数据库"><a href="#1）创建数据库" class="headerlink" title="1）创建数据库"></a>1）创建数据库</h3><p>创建数据库可以指定HDFS路径的位置，不指定路径，默认路径==<strong>${hive.metastore.warehouse.dir}/database_name.db</strong>==  </p>
<h3 id="2）查询数据库"><a href="#2）查询数据库" class="headerlink" title="2）查询数据库"></a>2）查询数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW DATABASES [LIKE &#39;identifier_with_wildcards&#39;];</span><br></pre></td></tr></table></figure>
<p>==注：like通配表达式说明：*表示任意个任意字符，|表示或的关系。==</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESCRIBE DATABASE [EXTENDED] db_name;</span><br></pre></td></tr></table></figure>
<p>==注：查看数据库信息== </p>
<h3 id="3）修改数据库"><a href="#3）修改数据库" class="headerlink" title="3）修改数据库"></a>3）修改数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--修改dbproperties</span><br><span class="line">ALTER DATABASE database_name SET DBPROPERTIES (property_name&#x3D;property_value, ...);</span><br><span class="line"></span><br><span class="line">--修改location</span><br><span class="line">ALTER DATABASE database_name SET LOCATION hdfs_path;</span><br><span class="line"></span><br><span class="line">--修改owner user</span><br><span class="line">ALTER DATABASE database_name SET OWNER USER user_name;</span><br></pre></td></tr></table></figure>
<h3 id="4）删除数据库"><a href="#4）删除数据库" class="headerlink" title="4）删除数据库"></a>4）删除数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE [IF EXISTS] database_name [RESTRICT|CASCADE];</span><br></pre></td></tr></table></figure>
<h2 id="2-表（table"><a href="#2-表（table" class="headerlink" title="2.表（table)"></a>2.表（table)</h2><h3 id="1）创建表"><a href="#1）创建表" class="headerlink" title="1）创建表"></a>1）创建表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE [TEMPORARY] [EXTERNAL] TABLE [IF NOT EXISTS] [db_name.]table_name   </span><br><span class="line">[(col_name data_type [COMMENT col_comment], ...)]</span><br><span class="line">[COMMENT table_comment]</span><br><span class="line">[PARTITIONED BY (col_name data_type [COMMENT col_comment], ...)]</span><br><span class="line">[CLUSTERED BY (col_name, col_name, ...) </span><br><span class="line">[SORTED BY (col_name [ASC|DESC], ...)] INTO num_buckets BUCKETS]</span><br><span class="line">[ROW FORMAT row_format] </span><br><span class="line">[STORED AS file_format]</span><br><span class="line">[LOCATION hdfs_path]</span><br><span class="line">[TBLPROPERTIES (property_name&#x3D;property_value, ...)]</span><br></pre></td></tr></table></figure>
<ol>
<li><p><strong>TEMPORARY</strong>  临时表，该表只在当前会话可见，会话结束，表会被删除。</p>
</li>
<li><p><strong>EXTERNAL</strong>  外部表，与之相对应的是==内部表（管理表）。管理表意味着Hive会完全接管该表，包括元数据和HDFS中的数据==。而==外部表则意味着Hive只接管元数据，而不完全接管HDFS中的数据==。</p>
</li>
<li><p><strong>data_type</strong>  还包含==复杂数据类型array<string>，map<string, int>，struct<id:int, name:string>==  </p>
<p><strong>注：类型转换 </strong>Hive的基本数据类型可以做类型转换，转换的方式包括隐式转换以及显示转换。</p>
<p><strong>显示转换</strong>：==cast(expr as <type>)==  </p>
</li>
<li><p><strong>PARTITIONED BY</strong> 创建分区表。</p>
</li>
<li><p><strong>CLUSTERED BY … SORTED BY…INTO … BUCKETS</strong>  创建分桶表。</p>
</li>
<li><p><strong>ROW FORMAT</strong> 指定SERDE，SERDE是Serializer and Deserializer的简写。Hive使用SERDE序列化和反序列化每行数据。  </p>
</li>
<li><p><strong>STORED AS</strong> 指定文件格式，常用的文件格式有，==textfile（默认值）==，==sequence file==，==orc file==、==parquet file==等等。</p>
</li>
<li><p><strong>LOCATION</strong> 指定表所对应的HDFS路径，若不指定路径，其默认值为==${hive.metastore.warehouse.dir}/db_name.db/table_name==</p>
</li>
<li><p><strong>TBLPROPERTIES</strong> 用于配置表的一些KV键值对参数。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Create Table As Select（CTAS）建表</span><br><span class="line">Create Table Like 语法</span><br></pre></td></tr></table></figure>
<h3 id="2）查看表"><a href="#2）查看表" class="headerlink" title="2）查看表"></a>2）查看表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLES [IN database_name] LIKE [&#39;identifier_with_wildcards&#39;];</span><br><span class="line">DESCRIBE [EXTENDED | FORMATTED] [db_name.]table_name</span><br></pre></td></tr></table></figure>
<h3 id="3）修改表"><a href="#3）修改表" class="headerlink" title="3）修改表"></a>3）修改表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name RENAME TO new_table_name</span><br><span class="line"></span><br><span class="line">#增加列 该语句允许用户增加新的列，新增列的位置位于末尾。</span><br><span class="line">ALTER TABLE table_name ADD COLUMNS (col_name data_type [COMMENT col_comment], ...) </span><br><span class="line"></span><br><span class="line"># 更新列 该语句允许用户修改指定列的列名、数据类型、注释信息以及在表中的位置。</span><br><span class="line">ALTER TABLE table_name CHANGE [COLUMN] col_old_name col_new_name column_type [COMMENT col_comment] [FIRST|AFTER column_name] </span><br><span class="line"></span><br><span class="line">#替换列 该语句允许用户用新的列集替换表中原有的全部列。</span><br><span class="line">ALTER TABLE table_name REPLACE COLUMNS (col_name data_type [COMMENT col_comment], ...) </span><br></pre></td></tr></table></figure>
<h3 id="4）删除表"><a href="#4）删除表" class="headerlink" title="4）删除表"></a>4）删除表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE [IF EXISTS] table_name; </span><br></pre></td></tr></table></figure>
<h3 id="5）清空表"><a href="#5）清空表" class="headerlink" title="5）清空表"></a>5）清空表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE [TABLE] table_name</span><br></pre></td></tr></table></figure>
<h1 id="三-DML（Data-Manipulation-Language）数据操作"><a href="#三-DML（Data-Manipulation-Language）数据操作" class="headerlink" title="三.DML（Data Manipulation Language）数据操作"></a>三.DML（Data Manipulation Language）数据操作</h1><h2 id="1-Load"><a href="#1-Load" class="headerlink" title="1.Load"></a>1.Load</h2><p>Load语句可将文件导入到Hive表中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA [LOCAL] INPATH &#39;filepath&#39; [OVERWRITE] INTO TABLE tablename [PARTITION (partcol1&#x3D;val1, partcol2&#x3D;val2 ...)];</span><br></pre></td></tr></table></figure>
<h2 id="2-Insert"><a href="#2-Insert" class="headerlink" title="2.Insert"></a>2.Insert</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">INSERT (INTO | OVERWRITE) TABLE tablename [PARTITION (partcol1&#x3D;val1, partcol2&#x3D;val2 ...)] select_statement;</span><br><span class="line"></span><br><span class="line"># 将给定Values插入表中</span><br><span class="line">INSERT (INTO | OVERWRITE) TABLE tablename [PARTITION (partcol1[&#x3D;val1], partcol2[&#x3D;val2] ...)] VALUES values_row [, values_row ...]</span><br><span class="line"></span><br><span class="line"># 将查询结果写入目标路径</span><br><span class="line">INSERT OVERWRITE [LOCAL] DIRECTORY directory [ROW FORMAT row_format] [STORED AS file_format] select_statement;</span><br></pre></td></tr></table></figure>
<h2 id="3-Export-amp-Import"><a href="#3-Export-amp-Import" class="headerlink" title="3.Export&amp;Import"></a>3.Export&amp;Import</h2><p>Export导出语句可将==表的数据和元数据信息一并到处的HDFS路径==，Import可将Export导出的内容导入Hive，==表的数据和元数据信息都会恢复==。Export和Import可用于两个Hive实例之间的数据迁移。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--导出</span><br><span class="line">EXPORT TABLE tablename TO &#39;export_target_path&#39;</span><br><span class="line"></span><br><span class="line">--导入</span><br><span class="line">IMPORT [EXTERNAL] TABLE new_or_original_tablename FROM &#39;source_path&#39; [LOCATION &#39;import_target_path&#39;]</span><br></pre></td></tr></table></figure>
<h1 id="四-查询"><a href="#四-查询" class="headerlink" title="四.查询"></a>四.查询</h1><ol>
<li><strong>having</strong>与<strong>where</strong>不同点</li>
</ol>
<p>（1）where后面不能写分组聚合函数，而having后面可以使用分组聚合函数。</p>
<p>（2）having只用于group by分组统计语句。</p>
<ol>
<li><p>Hive支持通常的sql join语句，但是==只支持等值连接，不支持非等值连接==。</p>
</li>
<li><p><strong>union</strong>和<strong>union all</strong>在上下拼接sql结果时有两个要求：</p>
</li>
</ol>
<p>（1）两个sql的结果，列的个数必须相同</p>
<p>（2）两个sql的结果，上下所对应列的类型必须一致</p>
<h2 id="1-Sort-By（每个Reduce内部排序）"><a href="#1-Sort-By（每个Reduce内部排序）" class="headerlink" title="1.Sort By（每个Reduce内部排序）"></a>1.Sort By（每个Reduce内部排序）</h2><p>Sort By：对于==大规模的数据集==order by的效率非常低。在很多情况下，并==不需要全局排序==，此时可以使用<strong>Sort by</strong>。</p>
<p>Sort by为每个reduce产生一个排序文件。==每个Reduce内部进行排序，对全局结果集来说不是排序==。</p>
<h2 id="2-Distribute-By（分区）"><a href="#2-Distribute-By（分区）" class="headerlink" title="2.Distribute By（分区）"></a>2.Distribute By（分区）</h2><p>Distribute By：在有些情况下，我们需要控制某个特定行应该到哪个Reducer，通常是为了进行后续的聚集操作。<strong>distribute by</strong>子句可以做这件事。<strong>distribute by</strong>类似MapReduce中partition（自定义分区），进行分区，结合sort by使用。  </p>
<p><strong>注意：</strong></p>
<ul>
<li><p>distribute by的分区规则是==根据分区字段的hash码与reduce的个数进行相除==后，余数相同的分到一个区。</p>
</li>
<li><p>Hive要求<strong>distribute by</strong>语句要写在sort by语句之前。</p>
</li>
</ul>
<h2 id="3-Cluster-By（分区排序）"><a href="#3-Cluster-By（分区排序）" class="headerlink" title="3.Cluster By（分区排序）"></a>3.Cluster By（分区排序）</h2><p>==当distribute by和sort by字段相同时，可以使用cluster by方式。==</p>
<p>cluster by除了具有distribute by的功能外还兼具sort by的功能。但是==排序只能是升序排序，不能指定排序规则为asc或者desc==。</p>
<h1 id="五-函数"><a href="#五-函数" class="headerlink" title="五.函数"></a>五.函数</h1><p>Hive提供了大量的内置函数，按照其特点可大致分为如下几类：单行函数、聚合函数、炸裂函数、窗口函数。</p>
<h2 id="1-单行函数"><a href="#1-单行函数" class="headerlink" title="1.单行函数"></a>1.单行函数</h2><p><strong>单行函数的特点是一进一出，即输入一行，输出一行。</strong></p>
<p><strong>单行函数按照功能可分为如下几类:</strong>日期函数、字符串函数、集合函数、数学函数、流程控制函数等。</p>
<h3 id="1）算术运算函数"><a href="#1）算术运算函数" class="headerlink" title="1）算术运算函数"></a>1）算术运算函数</h3><p>+、-、*、/、&amp;、|、~、%、^</p>
<h3 id="2）数值函数"><a href="#2）数值函数" class="headerlink" title="2）数值函数"></a>2）数值函数</h3><ul>
<li><p>==round：四舍五入==  </p>
</li>
<li><p>==ceil：向上取整==  </p>
</li>
<li><p>==floor：向下取整==  </p>
</li>
</ul>
<h3 id="3）字符串函数"><a href="#3）字符串函数" class="headerlink" title="3）字符串函数"></a>3）字符串函数</h3><ul>
<li>==substring：截取字符串==  </li>
<li><p>substring(string A, int start)</p>
<ul>
<li>substring(string A, int start, int len)      </li>
</ul>
</li>
<li><p>==replace ：替换==  </p>
<ul>
<li>replace(string A, string B, string C) 将字符串A中的子字符串B替换为C。  </li>
</ul>
</li>
<li><p>==regexp_replace：正则替换==  </p>
<ul>
<li>regexp_replace(string A, string B, string C) 将字符串A中的符合java正则表达式B的部分替换为C。注意，在有些情况下要使用转义字符。  </li>
</ul>
</li>
<li><p>==regexp：正则匹配==  </p>
<ul>
<li>字符串 regexp 正则表达式 若字符串符合正则表达式，则返回true，否则返回false。  </li>
</ul>
</li>
<li><p>==repeat：重复字符串==  </p>
<ul>
<li>repeat(string A, int n) 将字符串A重复n遍。</li>
</ul>
</li>
<li><p>==split ：字符串切割== </p>
<ul>
<li>split(string str, string pat) 按照正则表达式pat匹配到的内容分割str，分割后的字符串，以数组的形式返回。  </li>
</ul>
</li>
<li><p>==nvl ：替换null值==  </p>
<ul>
<li>nvl(A,B) 若A的值不为null，则返回A，否则返回B。</li>
</ul>
</li>
<li><p>==concat ：拼接字符串==</p>
<ul>
<li>concat(string A, string B, string C, ……) 将A,B,C……等字符拼接为一个字符串。   </li>
</ul>
</li>
<li><p>==concat_ws：以指定分隔符拼接字符串或者字符串数组==  </p>
<ul>
<li>concat_ws(string A, string…| array(string)) 使用分隔符A拼接多个字符串，或者一个数组的所有元素。    </li>
</ul>
</li>
<li><p>==get_json_object：解析json字符串==  </p>
<ul>
<li>get_json_object(string json_string, string path) 解析json的字符串json_string，返回path指定的内容。如果输入的json字符串无效，那么返回NULL。 <h3 id="4）日期函数"><a href="#4）日期函数" class="headerlink" title="4）日期函数"></a>4）日期函数</h3></li>
</ul>
</li>
<li><p>==unix_timestamp：返回当前或指定时间的时间戳==  </p>
<ul>
<li><p>unix_timestamp()   </p>
</li>
<li><p>```mysql<br>select unix_timestamp(‘2022/08/08 08-08-08’,’yyyy/MM/dd HH-mm-ss’);</p>
<h1 id="1659946088"><a href="#1659946088" class="headerlink" title="1659946088"></a>1659946088</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    说明：前面是日期后面是指，日期传进来的具体格式 </span><br><span class="line"></span><br><span class="line">* &#x3D;&#x3D;from_unixtime：转化UNIX时间戳（从 1970-01-01 00:00:00 UTC 到指定时间的秒数）到当前时区的时间格式&#x3D;&#x3D;  </span><br><span class="line"></span><br><span class="line">  * from_unixtime(bigint unixtime[, string format])  </span><br><span class="line"></span><br><span class="line">  * &#96;&#96;&#96;mysql</span><br><span class="line">    select from_unixtime(1659946088);</span><br><span class="line">    #2022-08-08 08:08:08</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>==current_date：当前日期==  </p>
<ul>
<li>```mysql<br>select current_date;<h1 id="2022-07-11"><a href="#2022-07-11" class="headerlink" title="2022-07-11"></a>2022-07-11</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* &#x3D;&#x3D;current_timestamp：当前的日期加时间，并且精确的毫秒&#x3D;&#x3D;  </span><br><span class="line"></span><br><span class="line">  * &#96;&#96;&#96;mysql</span><br><span class="line">    select current_timestamp;</span><br><span class="line">    # 2022-07-11 15:32:22.402</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>==year/month/day/hour：获取日期中的年/月/日/时==  </p>
<ul>
<li>```mysql<br>year(string date)<br>month(string date)<br>day(string date)<br>hour(string date)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* &#x3D;&#x3D;datediff：两个日期相差的天数（结束日期减去开始日期的天数）&#x3D;&#x3D;  </span><br><span class="line"></span><br><span class="line">  * datediff(string enddate, string startdate) </span><br><span class="line"></span><br><span class="line">  * &#96;&#96;&#96;mysql</span><br><span class="line">    select datediff(&#39;2021-08-08&#39;,&#39;2022-10-09&#39;);</span><br><span class="line">    # -427</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>==date_add：日期加天数/date_sub：日期减天数==  </p>
<ul>
<li><p>date_add(string startdate, int days)  </p>
</li>
<li><p>date_sub (string startdate, int days)  </p>
</li>
<li><p>```mysql<br> select date_add(‘2022-08-08’,2);</p>
<h1 id="2022-08-10"><a href="#2022-08-10" class="headerlink" title="2022-08-10"></a>2022-08-10</h1><p> select date_sub(‘2022-08-08’,2);</p>
<h1 id="2022-08-06"><a href="#2022-08-06" class="headerlink" title="2022-08-06"></a>2022-08-06</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* &#x3D;&#x3D;date_format:将标准日期解析成指定格式字符串&#x3D;&#x3D;  </span><br><span class="line"></span><br><span class="line">  * &#96;&#96;&#96;mysql</span><br><span class="line">    select date_format(&#39;2022-08-08&#39;,&#39;yyyy年-MM月-dd日&#39;) # yyyy-MM-dd </span><br><span class="line">    # 2022年-08月-08日</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="5）流程控制函数"><a href="#5）流程控制函数" class="headerlink" title="5）流程控制函数"></a>5）流程控制函数</h3><ul>
<li><p>==case when：条件判断函数==  </p>
<ul>
<li>```mysql<br>case when a then b <pre><code>[when c then d]
[else e] 
</code></pre>end<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* &#96;&#96;&#96;mysql</span><br><span class="line">  case a </span><br><span class="line">      when b then c </span><br><span class="line">      [when d then e]</span><br><span class="line">      [else f] </span><br><span class="line">  end</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>==if: 条件判断，类似于Java中三元运算符==  </p>
<ul>
<li>```mysql<br>if（boolean testCondition, T valueTrue, T valueFalseOrNull）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 6）集合函数</span><br><span class="line"></span><br><span class="line">* &#x3D;&#x3D;size：集合中元素的个数&#x3D;&#x3D;  </span><br><span class="line"></span><br><span class="line">  * &#96;&#96;&#96;mysql</span><br><span class="line">    select size(friends) from test; </span><br><span class="line">    # 每一行数据中的friends集合里的个数</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>==map：创建map集合==  </p>
<ul>
<li><p>根据输入的key和value对构建map类型  </p>
</li>
<li><p>```mysql<br>map (key1, value1, key2, value2, …) </p>
<h1 id="select-map-‘xiaohai’-1-’dahai’-2"><a href="#select-map-‘xiaohai’-1-’dahai’-2" class="headerlink" title="select map(‘xiaohai’,1,’dahai’,2);"></a>select map(‘xiaohai’,1,’dahai’,2);</h1><h1 id="“xiaohai”-1-”dahai”-2"><a href="#“xiaohai”-1-”dahai”-2" class="headerlink" title="{“xiaohai”:1,”dahai”:2}"></a>{“xiaohai”:1,”dahai”:2}</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* &#x3D;&#x3D;map_keys： 返回map中的key&#x3D;&#x3D;  </span><br><span class="line"></span><br><span class="line">  * &#96;&#96;&#96;mysql</span><br><span class="line">    select map_keys(map(&#39;xiaohai&#39;,1,&#39;dahai&#39;,2));</span><br><span class="line">    # [&quot;xiaohai&quot;,&quot;dahai&quot;] 输出为集合类型</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>==map_values: 返回map中的value==  </p>
<ul>
<li>```mysql<br>select map_values(map(‘xiaohai’,1,’dahai’,2));<h1 id="1-2-输出为集合类型"><a href="#1-2-输出为集合类型" class="headerlink" title="[1,2] 输出为集合类型"></a>[1,2] 输出为集合类型</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* &#x3D;&#x3D;array 声明array集合&#x3D;&#x3D;  </span><br><span class="line"></span><br><span class="line">  * array(val1, val2, …) 根据输入的参数构建数组array类。</span><br><span class="line"></span><br><span class="line">  * &#96;&#96;&#96;mysql</span><br><span class="line">    select array(&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;);</span><br><span class="line">    # [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>==array_contains: 判断array中是否包含某个元素==  </p>
<ul>
<li>```mysql<br>select array_contains(array(‘a’,’b’,’c’,’d’),’a’);<h1 id="true"><a href="#true" class="headerlink" title="true"></a>true</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* &#x3D;&#x3D;sort_array：将array中的元素排序&#x3D;&#x3D;  </span><br><span class="line"></span><br><span class="line">  * &#96;&#96;&#96;mysql</span><br><span class="line">    select sort_array(array(&#39;a&#39;,&#39;d&#39;,&#39;c&#39;));</span><br><span class="line">    # [&quot;a&quot;,&quot;c&quot;,&quot;d&quot;]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>==struct声明struct中的各属性==  </p>
<ul>
<li><p>struct(val1, val2, val3, …) 根据输入的参数构建结构体struct类。</p>
</li>
<li><p>```mysql<br>select struct(‘name’,’age’,’weight’);</p>
<h1 id="“col1”-”name”-”col2”-”age”-”col3”-”weight”"><a href="#“col1”-”name”-”col2”-”age”-”col3”-”weight”" class="headerlink" title="{“col1”:”name”,”col2”:”age”,”col3”:”weight”}"></a>{“col1”:”name”,”col2”:”age”,”col3”:”weight”}</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* &#x3D;&#x3D;named_struct声明struct的属性和值&#x3D;&#x3D;  </span><br><span class="line"></span><br><span class="line">  * &#96;&#96;&#96;mysql</span><br><span class="line">    select named_struct(&#39;name&#39;,&#39;xiaosong&#39;,&#39;age&#39;,18,&#39;weight&#39;,80);</span><br><span class="line">    # &#123;&quot;name&quot;:&quot;xiaosong&quot;,&quot;age&quot;:18,&quot;weight&quot;:80&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="2-高级聚合函数"><a href="#2-高级聚合函数" class="headerlink" title="2.高级聚合函数"></a>2.高级聚合函数</h2><p><strong>多进一出 （多行传入，一个行输出）。</strong></p>
<h3 id="1）普通聚合-count-sum…"><a href="#1）普通聚合-count-sum…" class="headerlink" title="1）普通聚合 count/sum…."></a><strong>1）普通聚合 count/sum….</strong></h3><h3 id="2）collect-list收集并形成list集合，结果不去重"><a href="#2）collect-list收集并形成list集合，结果不去重" class="headerlink" title="2）collect_list收集并形成list集合，结果不去重"></a>2）collect_list收集并形成list集合，结果不去重</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select sex, collect_list(job)</span><br><span class="line">from employee</span><br><span class="line">group by sex</span><br><span class="line"></span><br><span class="line"># 女	[&quot;行政&quot;,&quot;研发&quot;,&quot;行政&quot;,&quot;前台&quot;]</span><br><span class="line"># 男	[&quot;销售&quot;,&quot;研发&quot;,&quot;销售&quot;,&quot;前台&quot;]</span><br></pre></td></tr></table></figure>
<h3 id="3）collect-set-收集并形成set集合，结果去重"><a href="#3）collect-set-收集并形成set集合，结果去重" class="headerlink" title="3）collect_set 收集并形成set集合，结果去重"></a>3）collect_set 收集并形成set集合，结果去重</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select sex, collect_set(job)</span><br><span class="line">from employee</span><br><span class="line">group by sex</span><br><span class="line"></span><br><span class="line"># 女	[&quot;行政&quot;,&quot;研发&quot;,&quot;前台&quot;]</span><br><span class="line"># 男	[&quot;销售&quot;,&quot;研发&quot;,&quot;前台&quot;]</span><br></pre></td></tr></table></figure>
<h2 id="3-炸裂函数"><a href="#3-炸裂函数" class="headerlink" title="3.炸裂函数"></a>3.炸裂函数</h2><p><strong>UDTF(Table-Generating Functions),接收一行数据，输出一行或多行数据。</strong></p>
<p><img src="ipic/炸裂函数示意图.png" alt="炸裂函数示意图"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>movie</strong></th>
<th><strong>category</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>《疑犯追踪》</td>
<td>悬疑，动作，科幻，剧情</td>
</tr>
<tr>
<td>《Lie to  me》</td>
<td>悬疑，警匪，动作，心理，剧情</td>
</tr>
<tr>
<td>《战狼2》</td>
<td>战争，动作，灾难</td>
</tr>
</tbody>
</table>
</div>
<p><strong>建表</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table movie_info(</span><br><span class="line">    movie string,     --电影名称</span><br><span class="line">    category string   --电影分类</span><br><span class="line">) </span><br><span class="line">row format delimited fields terminated by &quot;\t&quot;;</span><br></pre></td></tr></table></figure>
<p><strong>数据装载</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">insert overwrite table movie_info</span><br><span class="line">values (&quot;《疑犯追踪》&quot;, &quot;悬疑,动作,科幻,剧情&quot;),</span><br><span class="line">       (&quot;《Lie to me》&quot;, &quot;悬疑,警匪,动作,心理,剧情&quot;),</span><br><span class="line">       (&quot;《战狼2》&quot;, &quot;战争,动作,灾难&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>需求：根据上述电影信息表，统计各分类的电影数量，期望结果如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select cate, count(*)</span><br><span class="line">from (</span><br><span class="line">    select movie, cate</span><br><span class="line">    from (</span><br><span class="line">        select movie, split(category,&#39;,&#39;) cates</span><br><span class="line">        from movie_info</span><br><span class="line">    )t1 lateral view explode(cates) tmp as cate</span><br><span class="line">)t2</span><br><span class="line">group by cate;</span><br></pre></td></tr></table></figure>
<h2 id="4-窗口函数（开窗函数）"><a href="#4-窗口函数（开窗函数）" class="headerlink" title="4.窗口函数（开窗函数）"></a>4.窗口函数（开窗函数）</h2><p>窗口函数，能为每行数据划分一个窗口，然后对窗口范围内的数据进行计算，最后将计算结果返回给该行数据。</p>
<p><img src="ipic/窗口函数示意图.png" alt="窗口函数示意图"></p>
<h3 id="1）常用窗口函数"><a href="#1）常用窗口函数" class="headerlink" title="1）常用窗口函数"></a>1）常用窗口函数</h3><ul>
<li><p>==聚合函数==  </p>
<ul>
<li>max：最大值。</li>
<li>min：最小值。</li>
<li>sum：求和。</li>
<li>avg：平均值。</li>
<li>count：计数。</li>
</ul>
</li>
<li><p>==跨行取值函数：获取当前行的上/下边某行、某个字段的值。==</p>
<ul>
<li>```mysql<br>lead(column, offset, Defaults)<br>lag(column, offset, Defaults) <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  * **注：lag和lead函数不支持自定义窗口。**</span><br><span class="line"></span><br><span class="line">* &#x3D;&#x3D;first_value和last_value：获取窗口内某一列的第一个值&#x2F;最后一个值&#x3D;&#x3D; </span><br><span class="line"></span><br><span class="line">  * &#96;&#96;&#96;mysql</span><br><span class="line">    first_value(column, skipNULL)</span><br><span class="line">    last_value(column, skipNULL)</span><br><span class="line">    # skipNULL为是否跳过null值</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>==排名函数：rank、dense_rank、row_number计算排名==  </p>
<ul>
<li><p>```mysql<br>rank() over(partition by xxx order by yyy)<br>dense_rank() over(partition by xxx order by yyy)<br>row_number() over(partition by xxx order by yyy)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  * **注：rank 、dense_rank、row_number不支持自定义窗口。**  </span><br><span class="line"></span><br><span class="line">## 5.自定义函数</span><br><span class="line"></span><br><span class="line">* **Hive自带了一些函数，比如：max&#x2F;min等，但是数量有限，自己可以通过自定义UDF来方便的扩展。**  </span><br><span class="line"></span><br><span class="line">* **当Hive提供的内置函数无法满足你的业务处理需要时，此时就可以考虑使用用户自定义函数（UDF：user-defined function）。** </span><br><span class="line"></span><br><span class="line">* **根据用户自定义函数类别分为以下三种：**  </span><br><span class="line"></span><br><span class="line">  * &#x3D;&#x3D;UDF（User-Defined-Function）&#x3D;&#x3D;一进一出。</span><br><span class="line">  * &#x3D;&#x3D;UDAF（User-Defined Aggregation Function）&#x3D;&#x3D;用户自定义聚合函数，多进一出。类似于：count&#x2F;max&#x2F;min。</span><br><span class="line">  * &#x3D;&#x3D;UDTF（User-Defined Table-Generating Functions）&#x3D;&#x3D;用户自定义表生成函数，一进多出。如lateral view explode() </span><br><span class="line"></span><br><span class="line">* **编程步骤**  </span><br><span class="line"></span><br><span class="line">  * 继承Hive提供的类</span><br><span class="line"></span><br><span class="line">    org.apache.hadoop.hive.ql.udf.generic.GenericUDF</span><br><span class="line"></span><br><span class="line">    org.apache.hadoop.hive.ql.udf.generic.GenericUDTF;</span><br><span class="line"></span><br><span class="line">  * 实现类中的抽象方法  </span><br><span class="line"></span><br><span class="line">  * 在hive的命令行窗口创建函数  </span><br><span class="line"></span><br><span class="line">    * 添加jar  </span><br><span class="line"></span><br><span class="line">    * &#96;&#96;&#96;mysql</span><br><span class="line">      add jar linux_jar_path </span><br><span class="line">      # 将打包好的jar包上传到linux后，使用add将jar包添加到hive的classpath</span><br></pre></td></tr></table></figure>
<ul>
<li><p>创建function。</p>
</li>
<li><p>```mysql<br>create [temporary] function [dbname.]function_name AS class_name;</p>
<h1 id="创建临时函数与开发好的java-class关联"><a href="#创建临时函数与开发好的java-class关联" class="headerlink" title="创建临时函数与开发好的java class关联"></a>创建临时函数与开发好的java class关联</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**注意：临时函数只跟会话有关系，跟库没有关系。只要创建临时函数的会话不断，在当前会话下，任意一个库都可以使用，其他会话全都不能使用。**  </span><br><span class="line"></span><br><span class="line">**注意：因为add jar本身也是临时生效，所以在创建永久函数的时候，需要制定路径（并且因为元数据的原因，这个路径还得是HDFS上的路径）。**</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;mysql</span><br><span class="line">create function my_len2 </span><br><span class="line">as &quot;com.atguigu.hive.udf.MyUDF&quot; </span><br><span class="line">using jar &quot;hdfs:&#x2F;&#x2F;hadoop102:8020&#x2F;udf&#x2F;myudf.jar&quot;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><strong>注意：永久函数跟会话没有关系，创建函数的会话断了以后，其他会话也可以使用。</strong></p>
<p>永久函数创建的时候，在函数名之前需要自己加上库名，如果不指定库名的话，会默认把当前库的库名给加上。</p>
<p>永久函数使用的时候，需要在指定的库里面操作，或者在其他库里面使用的话加上，<strong>库名.函数名。</strong></p>
</li>
</ul>
<h1 id="六-分区表和分桶表"><a href="#六-分区表和分桶表" class="headerlink" title="六.分区表和分桶表"></a>六.分区表和分桶表</h1><h2 id="1-分区表"><a href="#1-分区表" class="headerlink" title="1.分区表"></a>1.分区表</h2><p>Hive中的分区就是把==一张大表==的数据==按照业务需要==分散的==存储到多个目录==，==每个目录就称为该表的一个分区==。在查询时==通过where子句中的表达式选择查询所需要的分区，这样的查询效率会提高很多==。</p>
<h3 id="1）分区表基本语法"><a href="#1）分区表基本语法" class="headerlink" title="1）分区表基本语法"></a>1）分区表基本语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table dept_partition</span><br><span class="line">(</span><br><span class="line">    deptno int,    --部门编号</span><br><span class="line">    dname  string, --部门名称</span><br><span class="line">    loc    string  --部门位置</span><br><span class="line">)</span><br><span class="line">partitioned by (day string)  # ——&gt;填写分区字段</span><br><span class="line">row format delimited fields terminated by &#39;\t&#39;;</span><br></pre></td></tr></table></figure>
<h3 id="2）分区表读写数据"><a href="#2）分区表读写数据" class="headerlink" title="2）分区表读写数据"></a>2）分区表读写数据</h3><ul>
<li><p><strong>写数据</strong>  </p>
<ul>
<li><p><strong>装载数据</strong></p>
</li>
<li><p>```mysql</p>
<h1 id="将数据加载到’20220401’分区"><a href="#将数据加载到’20220401’分区" class="headerlink" title="将数据加载到’20220401’分区"></a>将数据加载到’20220401’分区</h1><p>load data local inpath ‘/opt/module/hive/datas/dept_20220401.log’<br>into table dept_partition<br>partition(day=’20220401’);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* **insert-数据插入**</span><br><span class="line"></span><br><span class="line">* &#96;&#96;&#96;mysql</span><br><span class="line">  # 将day&#x3D;&#39;20220401&#39;分区的数据插入到day&#x3D;&#39;20220402&#39;分区</span><br><span class="line">  insert overwrite table dept_partition partition (day &#x3D; &#39;20220402&#39;)</span><br><span class="line">  select deptno, dname, loc</span><br><span class="line">  from dept_partition</span><br><span class="line">  where day &#x3D; &#39;2020-04-01&#39;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>读数据</strong>  </p>
<ul>
<li><p>```mysql</p>
<h1 id="查询分区表数据时，可以将分区字段看作表的伪列，可像使用其他字段一样使用分区字段。"><a href="#查询分区表数据时，可以将分区字段看作表的伪列，可像使用其他字段一样使用分区字段。" class="headerlink" title="查询分区表数据时，可以将分区字段看作表的伪列，可像使用其他字段一样使用分区字段。"></a>查询分区表数据时，可以将分区字段看作表的伪列，可像使用其他字段一样使用分区字段。</h1><p>select deptno, dname, loc ,day<br>from dept_partition<br>where day = ‘2020-04-01’;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* **分区表基本操作**</span><br><span class="line"></span><br><span class="line">  * **查看所有分区信息**  </span><br><span class="line"></span><br><span class="line">  * &#96;&#96;&#96;mysql</span><br><span class="line">    show partitions dept_partition;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>增加分区</strong>  </p>
</li>
<li><p>```mysql<br>alter table dept_partition<br>add partition(day=’20220403’);</p>
<p>alter table dept_partition<br>add partition(day=’20220404’) partition(day=’20220405’);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* **删除分区**  </span><br><span class="line"></span><br><span class="line">* &#96;&#96;&#96;mysql</span><br><span class="line">  alter table dept_partition </span><br><span class="line">  drop partition (day&#x3D;&#39;20220403&#39;);</span><br><span class="line">  </span><br><span class="line">  alter table dept_partition </span><br><span class="line">  drop partition (day&#x3D;&#39;20220404&#39;), partition(day&#x3D;&#39;20220405&#39;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>修复分区</strong>  </p>
<p>==Hive将分区表的所有分区信息都保存在了元数据中，只有元数据与HDFS上的分区路径一致时，分区表才能正常读写数据。==若用户手动创建/删除分区路径，Hive都是感知不到的，这样就会导致Hive的元数据和HDFS的分区路径不一致。再比如，若分区表为外部表，用户执行drop partition命令后，分区元数据会被删除，而HDFS的分区路径不会被删除，同样会导致Hive的元数据和HDFS的分区路径不一致。</p>
<p>若出现元数据和HDFS路径不一致的情况，可通过如下几种手段进行修复。</p>
<ul>
<li><p><strong>add partition</strong>  </p>
<p>若手动创建HDFS的分区路径，Hive无法识别，可通过add partition命令增加分区元数据信息，从而使元数据和分区路径保持一致。</p>
</li>
<li><p><strong>drop partition</strong>  </p>
<p>若手动删除HDFS的分区路径，Hive无法识别，可通过drop partition命令删除分区元数据信息，从而使元数据和分区路径保持一致。</p>
</li>
<li><p><strong>msck</strong>  </p>
<p>若分区元数据和HDFS的分区路径不一致，还可使用msck命令进行修复，以下是该命令的用法说明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msck repair table table_name [add&#x2F;drop&#x2F;sync partitions];</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li><p>msck repair table table_name ==add partitions==：该命令会增加HDFS路径存在但元数据缺失的分区信息。</p>
</li>
<li><p>msck repair table table_name ==drop partitions==：该命令会删除HDFS路径已经删除但元数据仍然存在的分区信息。</p>
</li>
<li><p>msck repair table table_name ==sync partitions==：该命令会同步HDFS路径和元数据分区信息，相当于同时执行上述的两个命令。</p>
</li>
<li><p>msck repair table table_name：等价于msck repair table table_name <strong>add</strong> partitions命令。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3）二级分区表"><a href="#3）二级分区表" class="headerlink" title="3）二级分区表"></a>3）二级分区表</h3><p>思考：如果一天内的日志数据量也很大，如何再将数据拆分?</p>
<p>答案是二级分区表，例如可以在按天分区的基础上，再对每天的数据按小时进行分区。</p>
<ul>
<li><strong>建表语句</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table dept_partition2(</span><br><span class="line">    deptno int,    -- 部门编号</span><br><span class="line">    dname string, -- 部门名称</span><br><span class="line">    loc string     -- 部门位置</span><br><span class="line">)</span><br><span class="line">partitioned by (day string, hour string)</span><br><span class="line">row format delimited fields terminated by &#39;\t&#39;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>数据装载语句</strong>  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">load data local inpath &#39;&#x2F;opt&#x2F;module&#x2F;hive&#x2F;datas&#x2F;dept_20220401.log&#39; </span><br><span class="line">into table dept_partition2 </span><br><span class="line">partition(day&#x3D;&#39;20220401&#39;, hour&#x3D;&#39;12&#39;);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>查询分区数据</strong>  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * </span><br><span class="line">from dept_partition2 </span><br><span class="line">where day&#x3D;&#39;20220401&#39; and hour&#x3D;&#39;12&#39;;</span><br></pre></td></tr></table></figure>
<h3 id="4）动态分区"><a href="#4）动态分区" class="headerlink" title="4）动态分区"></a>4）动态分区</h3><p>动态分区是指向分区表insert数据时，==被写往的分区不由用户指定，而是由每行数据的最后一个字段的值来动态的决定==。使用动态分区，可只用一个insert语句将数据写入多个分区。  </p>
<ul>
<li><strong>动态分区功能总开关（默认true，开启）</strong>set hive.exec.dynamic.partition=true。</li>
<li><strong>严格模式和非严格模式</strong>  动态分区的模式，默认strict（严格模式），要求必须指定至少一个分区为静态分区，nonstrict（非严格模式）允许所有的分区字段都使用动态分区。</li>
<li><strong>一条insert语句可同时创建的最大的分区个数，默认为1000</strong> set hive.exec.max.dynamic.partitions=1000。  </li>
<li><strong>单个Mapper或者Reducer可同时创建的最大的分区个数，默认为100</strong> set hive.exec.max.dynamic.partitions.pernode=100。</li>
<li><strong>一条insert语句可以创建的最大的文件个数，默认100000</strong> hive.exec.max.created.files=100000。</li>
<li><strong>当查询结果为空时且进行动态分区时，是否抛出异常，默认false </strong>hive.error.on.empty.partition=false。  </li>
</ul>
<p>案例需求：将dept表中的数据按照地区（loc字段），插入到目标表dept_partition_dynamic的相应分区中。</p>
<p><strong>1.创建目标分区表</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table dept_partition_dynamic(</span><br><span class="line">    id int, </span><br><span class="line">    name string</span><br><span class="line">) </span><br><span class="line">partitioned by (loc int) </span><br><span class="line">row format delimited fields terminated by &#39;\t&#39;;</span><br></pre></td></tr></table></figure>
<p><strong>2.设置动态分区</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set hive.exec.dynamic.partition.mode &#x3D; nonstrict;</span><br><span class="line"></span><br><span class="line">insert into table dept_partition_dynamic </span><br><span class="line">partition(loc) </span><br><span class="line">select deptno, dname, loc </span><br><span class="line">from dept;</span><br></pre></td></tr></table></figure>
<h2 id="2-分桶表"><a href="#2-分桶表" class="headerlink" title="2.分桶表"></a>2.分桶表</h2><h3 id="1）普通分桶表"><a href="#1）普通分桶表" class="headerlink" title="1）普通分桶表"></a>1）普通分桶表</h3><ul>
<li><p><strong>建表语句</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table stu_buck(</span><br><span class="line">    id int, </span><br><span class="line">    name string</span><br><span class="line">)</span><br><span class="line">clustered by(id) </span><br><span class="line">into 4 buckets</span><br><span class="line">row format delimited fields terminated by &#39;\t&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>数据装载</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">load data local inpath &#39;&#x2F;opt&#x2F;module&#x2F;hive&#x2F;datas&#x2F;student.txt&#39; </span><br><span class="line">into table stu_buck;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3）分桶排序表"><a href="#3）分桶排序表" class="headerlink" title="3）分桶排序表"></a>3）分桶排序表</h3><ul>
<li><p>建表语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table stu_buck_sort(</span><br><span class="line">    id int, </span><br><span class="line">    name string</span><br><span class="line">)</span><br><span class="line">clustered by(id) sorted by(id)</span><br><span class="line">into 4 buckets</span><br><span class="line">row format delimited fields terminated by &#39;\t&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据装载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">load data local inpath &#39;&#x2F;opt&#x2F;module&#x2F;hive&#x2F;datas&#x2F;student.txt&#39; </span><br><span class="line">into table stu_buck_sort;</span><br></pre></td></tr></table></figure>
<p>==注：create table的clustered by其实仅仅是分布，与Select语句中的cluster by其实并不一样。而是和Select语句中的distribute by相同。所以create table的clustered by sorted by其实等价于select的distribute by sort by。==</p>
</li>
</ul>
<h1 id="七-文件格式和压缩"><a href="#七-文件格式和压缩" class="headerlink" title="七.文件格式和压缩"></a>七.文件格式和压缩</h1><h2 id="1-Hadoop压缩概述"><a href="#1-Hadoop压缩概述" class="headerlink" title="1.Hadoop压缩概述"></a>1.Hadoop压缩概述</h2><div class="table-container">
<table>
<thead>
<tr>
<th><strong>压缩格式</strong></th>
<th><strong>算法</strong></th>
<th><strong>文件扩展名</strong></th>
<th><strong>是否可切分</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>DEFLATE</td>
<td>DEFLATE</td>
<td>.deflate</td>
<td>否</td>
</tr>
<tr>
<td>Gzip</td>
<td>DEFLATE</td>
<td>.gz</td>
<td>否</td>
</tr>
<tr>
<td>bzip2</td>
<td>bzip2</td>
<td>.bz2</td>
<td><strong>是</strong></td>
</tr>
<tr>
<td>LZO</td>
<td>LZO</td>
<td>.lzo</td>
<td><strong>是</strong></td>
</tr>
<tr>
<td>Snappy</td>
<td>Snappy</td>
<td>.snappy</td>
<td>否</td>
</tr>
</tbody>
</table>
</div>
<h2 id="2-Hive文件格式"><a href="#2-Hive文件格式" class="headerlink" title="2.Hive文件格式"></a>2.Hive文件格式</h2><p>为Hive表中的数据选择一个合适的文件格式，对提高查询性能的提高是十分有益的。Hive表数据的存储格式，可以选择text file、orc、parquet、sequence file等。</p>
<h3 id="1）Text-File"><a href="#1）Text-File" class="headerlink" title="1）Text File"></a>1）Text File</h3><p>文本文件是Hive默认使用的文件格式，文本文件中的一行内容，就对应Hive表中的一行记录。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table textfile_table</span><br><span class="line">(column_specs)</span><br><span class="line">stored as textfile; #设置表的存储文件格式</span><br></pre></td></tr></table></figure>
<h3 id="2）ORC"><a href="#2）ORC" class="headerlink" title="2）ORC"></a>2）ORC</h3><p>==ORC（Optimized Row Columnar）==file format是Hive 0.11版里引入的一种<strong>列式存储</strong>的文件格式。ORC文件能够提高Hive读写数据和处理数据的性能。</p>
<ul>
<li><p><strong>行存储的特点</strong>  </p>
<p>查询满足条件的一整行数据的时候，列存储则需要去每个聚集的字段找到对应的每个列的值，行存储只需要找到其中一个值，其余的值都在相邻地方，所以此时行存储查询的速度更快。</p>
</li>
<li><p><strong>列存储的特点</strong>  </p>
<p>因为每个字段的数据聚集存储，在查询只需要少数几个字段的时候，能大大减少读取的数据量；每个字段的数据类型一定是相同的，列式存储可以针对性的设计更好的设计压缩算法。</p>
</li>
</ul>
<p><img src="ipic/ORC文件基本格式.png" alt="ORC文件基本格式"></p>
<p>每个Orc文件由Header、Body和Tail三部分组成。</p>
<ul>
<li><p>其中Header内容为ORC，用于表示文件类型。</p>
</li>
<li><p>Body由1个或多个stripe组成，==每个stripe一般为HDFS的块大小==，每一个stripe包含多条记录，这些记录按照列进行独立存储，每个stripe里有三部分组成，分别是Index Data，Row Data，Stripe Footer。</p>
<ul>
<li><p><strong>Index Data</strong>：一个轻量级的index，==默认是为各列每隔1W行做一个索引==。每个索引会记录第n万行的位置，和最近一万行的最大值和最小值等信息。</p>
</li>
<li><p><strong>Row Data</strong>：存的是具体的数据，按列进行存储，并==对每个列进行编码==，分成多个Stream来存储。</p>
</li>
<li><p><strong>Stripe Footer</strong>：存放的是各个Stream的位置以及各column的编码信息。</p>
</li>
</ul>
</li>
<li><p>Tail由File Footer和PostScript组成。File Footer中保存了各Stripe的其实位置、索引长度、数据长度等信息，各Column的统计信息等；PostScript记录了整个文件的压缩类型以及File Footer的长度信息等。</p>
</li>
</ul>
<p>在读取ORC文件时，会先从最后一个字节读取PostScript长度，进而读取到PostScript，从里面解析到File Footer长度，进而读取FileFooter，从中解析到各个Stripe信息，再读各个Stripe，即从后往前读。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table orc_table</span><br><span class="line">(column_specs)</span><br><span class="line">stored as orc # 指定表的存储格式</span><br><span class="line">tblproperties (property_name&#x3D;property_value, ...); #选择其他参数如压缩格式等</span><br></pre></td></tr></table></figure>
<h3 id="3）Parquet"><a href="#3）Parquet" class="headerlink" title="3）Parquet"></a>3）Parquet</h3><p>Parquet文件是Hadoop生态中的一个通用的文件格式，它也是一个<strong>列式存储</strong>的文件格式。</p>
<p><img src="ipic/parquet文件基本格式.png" alt="parquet文件基本格式"></p>
<ul>
<li><p>文件的首尾都是该文件的Magic Code，用于校验它是否是一个Parquet文件。</p>
</li>
<li><p>首尾中间由若干个Row Group和一个Footer（File Meta Data）组成。每个Row Group包含多个Column Chunk，每个Column Chunk包含多个Page。以下是Row Group、Column Chunk和Page三个概念的说明：</p>
<ul>
<li><p><strong>行组（Row Group）：</strong>一个行组对应逻辑表中的若干行。 </p>
</li>
<li><p><strong>列块（Column Chunk）：</strong>一个行组中的一列保存在一个列块中。 </p>
</li>
<li><p><strong>页（Page）：</strong>一个列块的数据会划分为若干个页。 </p>
</li>
</ul>
</li>
<li><p>Footer（File Meta Data）中存储了每个行组（Row Group）中的每个列快（Column Chunk）的元数据信息，元数据信息包含了该列的数据类型、该列的编码方式、该类的Data Page位置等信息。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Create table parquet_table</span><br><span class="line">(column_specs)</span><br><span class="line">stored as parquet #指定表的存储格式</span><br><span class="line">tblproperties (property_name&#x3D;property_value, ...); #可选属性值，如压缩格式等</span><br></pre></td></tr></table></figure>
<h2 id="3-压缩"><a href="#3-压缩" class="headerlink" title="3.压缩"></a>3.压缩</h2><p>在Hive表中和计算过程中，保持数据的压缩，对磁盘空间的有效利用和提高查询性能都是十分有益的。  </p>
<h3 id="1）Hive表数据进行压缩"><a href="#1）Hive表数据进行压缩" class="headerlink" title="1）Hive表数据进行压缩"></a>1）Hive表数据进行压缩</h3><ul>
<li><p><strong>TextFile</strong>  </p>
<p>若一张表的文件类型为TextFile，若需要对该表中的数据进行压缩，多数情况下，无需在建表语句做出声明。直接将压缩后的文件导入到该表即可，Hive在查询表中数据时，可自动识别其压缩格式，进行解压。</p>
<p>需要注意的是，在执行往表中导入数据的SQL语句时，用户需设置以下参数，来保证写入表中的数据是被压缩的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># SQL语句的最终输出结果是否压缩</span><br><span class="line">set hive.exec.compress.output&#x3D;true;</span><br><span class="line"></span><br><span class="line"># 输出结果的压缩格式（以下示例为snappy）</span><br><span class="line">set mapreduce.output.fileoutputformat.compress.codec&#x3D;org.apache.hadoop.io.compress.SnappyCodec;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ORC</strong></p>
<p>若一张表的文件类型为ORC，若需要对该表数据进行压缩，需在建表语句中声明压缩格式。</p>
</li>
<li><p><strong>Parquet</strong>  </p>
<p>若一张表的文件类型为Parquet，若需要对该表数据进行压缩，需在建表语句中声明压缩格式。</p>
</li>
</ul>
<h3 id="2）计算过程中使用压缩"><a href="#2）计算过程中使用压缩" class="headerlink" title="2）计算过程中使用压缩"></a>2）计算过程中使用压缩</h3><ul>
<li><p><strong>单个MR的中间结果进行压缩</strong></p>
<p>单个MR的中间结果是指Mapper输出的数据，对其进行压缩可降低shuffle阶段的网络IO，可通过以下参数进行配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 开启MapReduce中间数据压缩功能</span><br><span class="line">set mapreduce.map.output.compress&#x3D;true;</span><br><span class="line"># 设置MapReduce中间数据数据的压缩方式（以下示例为snappy）</span><br><span class="line">set mapreduce.map.output.compress.codec&#x3D;org.apache.hadoop.io.compress.SnappyCodec;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong>单条SQL语句的中间结果进行压缩</strong> </p>
<p>单条SQL语句的中间结果是指，两个MR（一条SQL语句可能需要通过MR进行计算）之间的临时数据，可通过以下参数进行配置： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 是否对两个MR之间的临时数据进行压缩</span><br><span class="line">set hive.exec.compress.intermediate&#x3D;true;</span><br><span class="line"># 压缩格式（以下示例为snappy）</span><br><span class="line">set hive.intermediate.compression.codec&#x3D; org.apache.hadoop.io.compress.SnappyCodec;</span><br></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/04/BigData/HBase/HBase/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/04/BigData/HBase/HBase/" class="post-title-link" itemprop="url">HBase</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-04 22:03:27 / 修改时间：22:10:18" itemprop="dateCreated datePublished" datetime="2023-04-04T22:03:27+08:00">2023-04-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BigData/" itemprop="url" rel="index"><span itemprop="name">BigData</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BigData/HBase/" itemprop="url" rel="index"><span itemprop="name">HBase</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/04/04/BigData/HBase/HBase/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/04/04/BigData/HBase/HBase/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-Hbase简介"><a href="#一-Hbase简介" class="headerlink" title="一.Hbase简介"></a>一.Hbase简介</h1><h2 id="1-HBase定义"><a href="#1-HBase定义" class="headerlink" title="1.HBase定义"></a>1.HBase定义</h2><p>Apache HBase™ 是以==hdfs为数据存储==的，一种==分布式==、==可扩展==的==NoSQL数据库==。</p>
<h2 id="2-HBase-数据模型"><a href="#2-HBase-数据模型" class="headerlink" title="2.HBase 数据模型"></a>2.HBase 数据模型</h2><p>HBase数据模型的关键在于==稀疏、分布式、多维、排序的映射==。其中映射map指代非关系型数据库的key-Value结构。</p>
<h3 id="1）HBase逻辑结构"><a href="#1）HBase逻辑结构" class="headerlink" title="1）HBase逻辑结构"></a>1）HBase逻辑结构</h3><p><img src="D:/Typora/Typora/ipic/Hbase逻辑结构-1680607404000.png" alt="Hbase逻辑结构"></p>
<h3 id="2）物理存储结构"><a href="#2）物理存储结构" class="headerlink" title="2）物理存储结构"></a>2）物理存储结构</h3><p>物理存储结构即为数据映射关系，而在概念视图的空单元格，底层实际根本不存储。</p>
<p><img src="D:/Typora/Typora/ipic/Hbase物理存储结构-1680607414389.png" alt="Hbase物理存储结构"></p>
<h3 id="3）数据模型"><a href="#3）数据模型" class="headerlink" title="3）数据模型"></a>3）数据模型</h3><ul>
<li><p><strong>Name Space</strong> </p>
<p>命名空间，类似于关系型数据库的database概念，每个命名空间下有多个表。HBase两个自带的命名空间，分别是 hbase和default，==hbase中存放的是HBase内置的表==，==default表是用户默认使用的命名空间==。 </p>
</li>
<li><p><strong>Table</strong></p>
<p>类似于关系型数据库的表概念。不同的是，==HBase定义表时只需要声明列族即可，不需要声明具体的列==。因为数据存储时稀疏的，所有往 HBase 写入数据时，==字段可以动态、按需 指定==。因此，和关系型数据库相比，HBase 能够轻松应对字段变更的场景。 </p>
</li>
<li><p><strong>Row</strong> </p>
<p>HBase 表中的==每行数据都由一个<strong>RowKey</strong>和多个<strong>Column（列）</strong>==组成，==数据是按照RowKey的字典顺序存储的==，并且查询数据时==只能根据RowKey进行检索==，所以RowKey的设计十分重要。 </p>
</li>
<li><p><strong>Column</strong> </p>
<p>HBase中的每个列都由==Column Family(列族)==和==Column Qualifier（列限定符）==进行限定，例如 info：name，info：age。==建表时，只需指明列族，而列限定符无需预先定义==。 </p>
</li>
<li><p><strong>Time Stamp</strong> </p>
<p>用于==标识数据的不同版本（version），每条数据写入时，系统会自动为其加上该字段， 其值为写入HBase的时间==。 </p>
</li>
<li><p><strong>Cell</strong> </p>
<p>由=={rowkey, column Family：column Qualifier, timestamp}==唯一确定的单元。cell中的数据全部是==字节码形式存贮==。</p>
</li>
</ul>
<h2 id="3-HBase基本架构"><a href="#3-HBase基本架构" class="headerlink" title="3.HBase基本架构"></a>3.HBase基本架构</h2><p><img src="D:/Typora/Typora/ipic/Hbase基础架构.png" alt="Hbase基础架构"></p>
<h3 id="1）Master"><a href="#1）Master" class="headerlink" title="1）Master"></a>1）Master</h3><p>实现类为HMaster，负责监控集群中所有的RegionServer实例。主要作用如下：<br>（1）管理元数据表格hbase:meta，接收用户对表格创建修改删除的命令并执行<br>（2）监控region 是否需要进行负载均衡，故障转移和region 的拆分。<br>通过启动多个后台线程监控实现上述功能：</p>
<ul>
<li><p>LoadBalancer 负载均衡器</p>
<p>周期性监控region分布在regionServer上面是否均衡，由参数hbase.balancer.period 控<br>制周期时间，默认5分钟。</p>
</li>
<li><p>CatalogJanitor元数据管理器</p>
<p>定期检查和清理hbase:meta中的数据。meta表内容在进阶中介绍。</p>
</li>
<li><p>MasterProcWAL master预写日志处理器</p>
<p>把master需要执行的任务记录到预写日志WAL中，如果master宕机，让backupMaster读取日志继续干。</p>
</li>
</ul>
<h3 id="2）Region-Server"><a href="#2）Region-Server" class="headerlink" title="2）Region Server"></a>2）Region Server</h3><p>Region Server实现类为HRegionServer，主要作用如下:</p>
<ul>
<li>负责数据cell的处理，例如写入数据put，查询数据get等</li>
<li>拆分合并region的实际执行者，有master监控，有regionServer执行。</li>
</ul>
<h3 id="3）Zookeeper"><a href="#3）Zookeeper" class="headerlink" title="3）Zookeeper"></a>3）Zookeeper</h3><p>HBase通过Zookeeper来做master的高可用、记录RegionServer的部署信息、并且存储有meta表的位置信息。</p>
<p>HBase对于数据的读写操作时直接访问Zookeeper的，在2.3版本推出Master Registry模式，客户端可以直接访问 master。使用此功能，会加大对master的压力，减轻对Zookeeper的压力。</p>
<h3 id="4）HDFS"><a href="#4）HDFS" class="headerlink" title="4）HDFS"></a>4）HDFS</h3><p>HDFS为Hbase提供最终的底层数据存储服务，同时为HBase提供高容错的支持</p>
<h1 id="二-HBase快速入门"><a href="#二-HBase快速入门" class="headerlink" title="二 HBase快速入门"></a>二 HBase快速入门</h1><h2 id="1-HBase-Shell操作"><a href="#1-HBase-Shell操作" class="headerlink" title="1.HBase Shell操作"></a>1.HBase Shell操作</h2><h3 id="1-namespace"><a href="#1-namespace" class="headerlink" title="1) namespace"></a>1) namespace</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create_namespace &#39;bigdata&#39;</span><br><span class="line"></span><br><span class="line">list_namespace</span><br></pre></td></tr></table></figure>
<h3 id="2-DDL"><a href="#2-DDL" class="headerlink" title="2) DDL"></a>2) DDL</h3><ul>
<li><p><strong>创建表</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在bigdata 命名空间中创建表格 student，两个列族。info 列族数据维护的版本数为 5 个， 如果不写默认版本数为 1。</span><br><span class="line">create &#39;bigdata:student&#39;, &#123;NAME &#x3D;&gt; &#39;info&#39;, VERSIONS &#x3D;&gt; 5&#125;, &#123;NAME &#x3D;&gt; &#39;msg&#39;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 如果创建表格只有一个列族，没有列族属性，可以简写。</span><br><span class="line"></span><br><span class="line"># 如果不写命名空间，使用默认的命名空间</span><br><span class="line">create &#39;student1&#39;,&#39;info&#39;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看表</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list #查看所有表</span><br><span class="line"></span><br><span class="line">describe &#39;student1&#39; #查看一个表的详情</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>修改表</strong>  </p>
<p>表名创建时写的所有和列族相关的信息，都可以后续通过alter修改，包括增加删除列族。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 增加列族和修改信息都使用覆盖的方法</span><br><span class="line">alter &#39;student1&#39;, &#123;NAME &#x3D;&gt; &#39;f1&#39;, VERSIONS &#x3D;&gt; 3&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 删除信息使用特殊的语法</span><br><span class="line">alter &#39;student1&#39;, NAME &#x3D;&gt; &#39;f1&#39;, METHOD &#x3D;&gt; &#39;delete&#39; </span><br><span class="line">alter &#39;student1&#39;, &#39;delete&#39; &#x3D;&gt; &#39;f1&#39;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>删除表</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># shell 中删除表格,需要先将表格状态设置为不可用。</span><br><span class="line">disable &#39;student1&#39;</span><br><span class="line">drop &#39;student1&#39;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-DML"><a href="#3-DML" class="headerlink" title="3) DML"></a>3) DML</h3><ul>
<li><p><strong>写入数据</strong>  </p>
<p>在HBase中如果想要写入数据，只能添加结构中最底层的cell。可以手动写入时间戳指定cell的版本，推荐不写默认使用当前的系统时间。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">put &#39;bigdata:student&#39;,&#39;1001&#39;,&#39;info:name&#39;,&#39;zhangsan&#39;</span><br><span class="line">put &#39;bigdata:student&#39;,&#39;1001&#39;,&#39;info:name&#39;,&#39;lisi&#39;</span><br><span class="line">put &#39;bigdata:student&#39;,&#39;1001&#39;,&#39;info:age&#39;,&#39;18&#39;</span><br></pre></td></tr></table></figure>
<p>如果==重复写入相同rowKey，相同列的数据，会写入多个版本进行覆盖==。</p>
</li>
<li><p><strong>读取数据</strong></p>
<p>读取数据的方法有两个：get和scan。</p>
<ul>
<li><p>get最大范围是==一行数据==，也可以进行列的过滤，读取数据的结果为多行 cell。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">get &#39;bigdata:student&#39;,&#39;1001&#39;</span><br><span class="line">get &#39;bigdata:student&#39;,&#39;1001&#39; , &#123;COLUMN &#x3D;&gt; &#39;info:name&#39;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>也可以修改读取cell的版本数，默认读取一个。最多能够读取当前列族设置的维护版本数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get &#39;bigdata:student&#39;,&#39;1001&#39; , &#123;COLUMN &#x3D;&gt; &#39;info:name&#39;, VERSIONS &#x3D;&gt; 6&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>scan是扫描数据，能够==读取多行数据==，不建议扫描过多的数据，==推荐使用startRow和stopRow==来控制读取的数据，==默认范围左闭右开==。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scan &#39;bigdata:student&#39;, &#123;STARTROW &#x3D;&gt; &#39;1001&#39;,STOPROW &#x3D;&gt; &#39;1002&#39;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>删除数据</strong>   </p>
<p>删除数据的方法有两个：delete和deleteall。</p>
<ul>
<li><p>delete 表示删除一个版本的数据，即为1个cell，不填写版本默认删除最新的一个版本。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete &#39;bigdata:student&#39;,&#39;1001&#39;,&#39;info:name&#39;</span><br></pre></td></tr></table></figure>
</li>
<li><p>deleteall表示删除所有版本的数据，即为当前行当前列的多个cell。（执行命令会标记数据为要删除，不会直接将数据彻底删除，删除数据只在特定时期清理磁盘时进行）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deleteall &#39;bigdata:student&#39;,&#39;1001&#39;,&#39;info:name&#39;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="三-HBase进阶"><a href="#三-HBase进阶" class="headerlink" title="三.HBase进阶"></a>三.HBase进阶</h1><h2 id="1-Master架构"><a href="#1-Master架构" class="headerlink" title="1.Master架构"></a>1.Master架构</h2><p><img src="D:/Typora/Typora/ipic/Master详细架构.png" alt="Master详细架构"></p>
<h3 id="Meta表格介绍：（警告：不要去改这个表）"><a href="#Meta表格介绍：（警告：不要去改这个表）" class="headerlink" title="Meta表格介绍：（警告：不要去改这个表）"></a>Meta表格介绍：（警告：不要去改这个表）</h3><p>全称hbase：meta，只是在list命令中被过滤掉了，本质上和HBase的其他表格一样。</p>
<ul>
<li><p><strong>RowKey：</strong>([table],[region start key],[region id]) 即表名，region起始位置和regionID。</p>
</li>
<li><p><strong>列：</strong></p>
<ul>
<li>info：regioninfo ==为region信息，存储一个HRegionInfo对象==。 </li>
<li>info：server ==当前region所处的RegionServer信息，包含端口号==。</li>
<li>info：serverstartcode ==当前region被分到RegionServer的起始时间==。</li>
</ul>
</li>
</ul>
<p>如果一个表处于切分的过程中，即region切分，还会多出两列info：splitA和info：splitB，存储值也是HRegionInfo对象，拆分结束后，删除这两列。</p>
<p>==注意：在客户端对元数据进行操作的时候才会连接master，如果对数据进行读写，直接连接zookeeper读取录/hbase/meta-region-server节点信息，会记录meta表格的位置。直接读取即可，不需要访问master，这样可以减轻master的压力，相当于master专注meta表的写操作，客户端可直接读取meta表。在HBase的2.3版本更新了一种新模式：Master Registry。客户端可以访问master来读取meta表信息。加大了master的压力，减轻了zookeeper的压力。==</p>
<h2 id="2-RegionServer架构"><a href="#2-RegionServer架构" class="headerlink" title="2.RegionServer架构"></a>2.RegionServer架构</h2><p><img src="D:/Typora/Typora/ipic/RegionServer架构.png" alt="RegionServer架构"></p>
<h3 id="1）MemStore"><a href="#1）MemStore" class="headerlink" title="1）MemStore"></a>1）MemStore</h3><p>写缓存，由于HFile中的数据要求是有序的，所以数据是==先存储在MemStore中，排好序后，等到达刷写时机才会刷写到HFile==，==每次刷写都会形成一个新的HFile，写入到对应的文件夹store中==。</p>
<h3 id="2）WAL"><a href="#2）WAL" class="headerlink" title="2）WAL"></a>2）WAL</h3><p>由于数据要经MemStore排序后才能刷写到HFile，但把数据保存在内存中会有很高的概率导致数据丢失，为了解决这个问题，数据会先写在一个叫做==Write-Ahead logfile==的文件中，然后再写入MemStore中。所以在系统出现故障的时候，数据可以通过这个日志文件重建。</p>
<h3 id="3）BlockCache"><a href="#3）BlockCache" class="headerlink" title="3）BlockCache"></a>3）BlockCache</h3><p>读缓存，==每次查询出的数据会缓存在BlockCache中==，方便下次查询。</p>
<h2 id="3-写流程"><a href="#3-写流程" class="headerlink" title="3.写流程"></a>3.写流程</h2><p><img src="D:/Typora/Typora/ipic/HBase写流程.png" alt="HBase写流程"></p>
<ul>
<li><p>写流程顺序正如API编写顺序，首先创建==HBase的重量级连接==<br>（1）首先访问zookeeper，获取hbase:meta 表位于哪个Region Server；<br>（2）访问对应的Region Server，获取hbase:meta表，将其缓存到连接中，作为连接属性MetaCache，由于Meta表格具有一定的数据量，导致了创建连接比较慢；</p>
</li>
<li><p>之后使用创建的连接获取Table，这是一个轻量级的连接，只有在第一次创建的时候会检查表格是否存在访问RegionServer，之后在获取Table时不会访问RegionServer；<br>（3）调用Table的put方法写入数据，此时还需要解析RowKey，对照缓存的MetaCache，查看具体写入的位置有哪个RegionServer；<br>（4）将数据顺序写入（追加）到WAL，此处写入是直接落盘的，并设置专门的线程控制WAL预写日志的滚动（类似Flume）；</p>
<p>（5）根据写入命令的RowKey和Column Family查看具体写入到哪个MemStory，并且在MemStory中排序；<br>（6）向客户端发送ack；<br>（7）等达到MemStore的刷写时机后，将数据刷写到对应的story中。</p>
</li>
</ul>
<h2 id="4-MemStore-Flush"><a href="#4-MemStore-Flush" class="headerlink" title="4.MemStore Flush"></a>4.MemStore Flush</h2><p>MemStore刷写由多个线程控制，条件互相独立：主要的刷写规则是控制刷写文件的大小，在每一个刷写线程中都会进行监控</p>
<ul>
<li><p>当某个memstroe的大小达到了 <strong>hbase.hregion.memstore.flush.size（默认值 128M）</strong>，其所在region的所有 memstore都会刷写。当memstore的大小达到了<strong>hbase.hregion.memstore.flush.size（默认值 128M）</strong>、</p>
<p><strong>hbase.hregion.memstore.block.multiplier（默认值4）</strong>时，会刷写同时阻止继续往该memstore写数据（由于线程监控是周期性的，所有有可能面对数据洪峰，尽管可能性比较小）  </p>
</li>
<li><p>由HRegionServer中的属性MemStoreFlusher内部线程FlushHandler控制。标准为==LOWER_MARK（低水位线）==和==HIGH_MARK（高水位线）==，意义在于避免写缓存使用过多的内存造成OOM。 </p>
<ul>
<li><p>当 region server中memstore的总大小达到低水位线region 会按照其所有memstore的大小顺序（由大到小）依次进行刷写。直到region server中所有memstore的总大小减小到上述值以下。</p>
</li>
<li><p>```xml-dtd<br>java_heapsize<br>hbase.regionserver.global.memstore.size（默认值 0.4）<br>hbase.regionserver.global.memstore.size.lower.limit（默认值 0.95）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 当 region server中memstore的总大小达到高水位线时，会同时阻止继续往所有的memstore写数据。</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;xml-dtd</span><br><span class="line">  java_heapsize</span><br><span class="line">  hbase.regionserver.global.memstore.size（默认值 0.4）</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>为了避免数据过长时间处于内存之中，到达自动刷写的时间，也会触发memstore flush。由HRegionServer的属性 PeriodicMemStoreFlusher控制进行，由于重要性比较低，5min才会执行一次。自动刷新的时间间隔由该属性进行配置 <strong>hbase.regionserver.optionalcacheflushinterval（默认1小时）</strong>。</p>
</li>
<li><p>当WAL文件的数量超过<strong>hbase.regionserver.max.logs</strong>，region会按照时间顺序依次进行刷写，直到WAL文件数量减小到<strong>hbase.regionserver.max.log</strong>以下（该属性名已经废弃，现无需手动设置，最大值为32）。  </p>
</li>
</ul>
<h2 id="5-读流程"><a href="#5-读流程" class="headerlink" title="5.读流程"></a>5.读流程</h2><p>HFile是存储在HDFS上面每一个store文件夹下实际存储数据的文件。里面存储多种内容。包括==数据本身（keyValue键值对）==、==元数据记录==、==文件信息==、==数据索引==、==元数据索引==和==一个固定长度的尾部信息（记录文件的修改情况）==。</p>
<p>键值对按照块大小（默认 64K）保存在文件中，数据索引按照块创建，块越多，索引越大。==每一个HFile还会维护一个布隆过滤器==（就像是一个很大的地图，文件中每有一种key，就在对应的位置标记，读取时可以大致判断要get的key是否存在HFile 中）。</p>
<p><strong>由于 HFile 存储经过序列化，所以无法直接查看。</strong>  </p>
<p><img src="D:/Typora/Typora/ipic/HBase读流程.png" alt="HBase读流程"></p>
<p>（1）创建Table对象发送get请求。<br>（2）优先访问Block Cache，查找是否之前读取过，并且可以读取HFile的索引信息和布隆过滤器。<br>（3）不管读缓存中是否已经有数据了（可能已经过期了），都需要再次读取写缓存和store中的文件。<br>（4）最终将所有读取到的数据合并版本，按照get的要求返回即可。</p>
<h3 id="合并读取数据优化"><a href="#合并读取数据优化" class="headerlink" title="合并读取数据优化"></a>合并读取数据优化</h3><p>每次读取数据都需要读取三个位置，最后进行版本的合并。效率会非常低，所有系统需要对此优化。</p>
<p>（1）HFile带有索引文件，读取对应RowKey数据会比较快。</p>
<p>（2）Block Cache会缓存之前读取的内容和元数据信息，如果HFile没有发生变化（记录在HFile尾信息中），则不需要再次读取。</p>
<p>（3）使用布隆过滤器能够快速过滤当前HFile不存在需要读取的RowKey，从而避免读取文件。（布隆过滤器使用HASH算法，不是绝对准确的，出错会造成多扫描一个文件，对读取数据结果没有影响）</p>
<h2 id="6-StoreFile-Compaction"><a href="#6-StoreFile-Compaction" class="headerlink" title="6.StoreFile Compaction"></a>6.StoreFile Compaction</h2><p>由于 memstore 每次刷写都会生成一个新的HFile，文件过多读取不方便，所以会进行文 件的合并，清理掉过期和删除的数据，会进行 StoreFile Compaction。</p>
<p>Compaction分为两种，分别是==Minor Compaction==和==Major Compaction==。</p>
<ul>
<li><strong>Minor Compaction</strong>会将临近的若干个较小的HFile合并成一个较大的HFile，并清理掉部分过期和删除的数据，由系统使用一组参数自动控制。</li>
<li><strong>Major Compaction</strong>会将一个Store下的所有的HFile合并成一个大HFile，并且会清理掉所有过期和删除的数据，由参数 hbase.hregion.majorcompaction控制，默认7天。</li>
</ul>
<p><img src="D:/Typora/Typora/ipic/StoreFileCompaction.png" alt="StoreFileCompaction"></p>
<p>小合并机制为拉取整个store 中的所有文件，做成一个集合。之后按照从旧到新的顺序遍历。判断条件为：</p>
<ul>
<li><p>过小合并，过大不合并。</p>
</li>
<li><p>==文件大小/hbase.hstore.compaction.ratio&lt;(剩余文件大小和)==则参与压缩。所有把比值设置过大，如10会最终合并为1个特别大的文件，相反设置为0.4，会最终产生4个storeFile。不建议修改默认值。</p>
</li>
<li><p>满足压缩条件的文件个数达不到个数要求（3&lt;=count&lt;=10）则不压缩。</p>
</li>
</ul>
<h2 id="7-Region-Split"><a href="#7-Region-Split" class="headerlink" title="7.Region Split"></a>7.Region Split</h2><p>Region切分分为两种，创建表格时候的预分区即自定义分区，同时系统默认还会启动一个切分规则，避免单个Region中的数据量太大。</p>
<h3 id="1）预分区（自定义分区）"><a href="#1）预分区（自定义分区）" class="headerlink" title="1）预分区（自定义分区）"></a>1）预分区（自定义分区）</h3><p>每一个region维护着startRow与endRowKey，如果加入的数据符合某个region维护的rowKey范围，则该数据交给这个 region维护。那么依照这个原则，我们可以将数据所要投放的分区提前大致的规划好，以提高HBase性能。</p>
<h3 id="2）系统拆分"><a href="#2）系统拆分" class="headerlink" title="2）系统拆分"></a>2）系统拆分</h3><p>Region的拆分是由HRegionServer完成的，在操作之前需要通过ZK汇报master，修改对应的Meta表信息添加两列info：splitA和info：splitB信息。之后需要操作HDFS上面对应的文件，按照拆分后的Region范围进行标记区分，==实际操作为创建文件引用，不会挪动数据==。刚完成拆分的时候，两个Region都由原先的RegionServer管理。之后汇报给Master， 由Master 将修改后的信息写入到Meta表中。等待==下一次触发负载均衡机制，才会修改Region的管理服务者==，而==数据要等到下一次压缩时==，才会实际进行移动。</p>
<p>Hbase2.0引入了新的split策略：</p>
<ul>
<li><p>如果当前RegionServer上该表只有一个Region，按照2*hbase.hregion.memstore.flush.size分裂；</p>
</li>
<li><p>否则按照hbase.hregion.max.filesize分裂。 </p>
</li>
</ul>
<h1 id="四-HBase优化"><a href="#四-HBase优化" class="headerlink" title="四.HBase优化"></a>四.HBase优化</h1><h2 id="1-RowKey设计"><a href="#1-RowKey设计" class="headerlink" title="1.RowKey设计"></a>1.RowKey设计</h2><p>一条数据的唯一标识就是rowkey，那么这条数据存储于哪个分区，取决于rowkey处于哪个一个预分区的区间内，设计rowkey 的主要目的，就是让数据均匀的分布于所有的region中，在一定程度上==防止数据倾斜==。</p>
<p>rowkey常用的设计方案：</p>
<ul>
<li>生成随机数、hash、散列值；</li>
<li>时间戳反转；</li>
<li>字符串拼接。</li>
</ul>
<h1 id="五-整合Phoenix"><a href="#五-整合Phoenix" class="headerlink" title="五.整合Phoenix"></a>五.整合Phoenix</h1><h2 id="1-Phoenix简介"><a href="#1-Phoenix简介" class="headerlink" title="1.Phoenix简介"></a>1.Phoenix简介</h2><p>Phoenix是HBase的开源SQL皮肤。可以使用标准JDBC API代替HBase客户端API来创建表，插入数据和查询HBas 数据。</p>
<h2 id="2-Phoenix快速入门"><a href="#2-Phoenix快速入门" class="headerlink" title="2.Phoenix快速入门"></a>2.Phoenix快速入门</h2><h3 id="1）Phoenix-Shell操作"><a href="#1）Phoenix-Shell操作" class="headerlink" title="1）Phoenix Shell操作"></a>1）Phoenix Shell操作</h3><ul>
<li><p><strong>显示所有表</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!table</span><br><span class="line">!tables</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建表</strong>  在phoenix中，表名等会自动转换为大写，若要小写，使用双引号，如”us_population”。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 直接指定单个列作为RowKey</span><br><span class="line">CREATE TABLE IF NOT EXISTS student(</span><br><span class="line">    id VARCHAR primary key,</span><br><span class="line">    name VARCHAR,</span><br><span class="line">    age BIGINT,</span><br><span class="line">    addr VARCHAR);</span><br><span class="line">    </span><br><span class="line"># 指定多个列的联合作为RowKey</span><br><span class="line">CREATE TABLE IF NOT EXISTS student1(</span><br><span class="line">    id VARCHAR NOT NULL,</span><br><span class="line">    name VARCHAR NOT NULL, </span><br><span class="line">    age BIGINT,</span><br><span class="line">	addr VARCHAR</span><br><span class="line">CONSTRAINT my_pk PRIMARY KEY (id, name));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>插入数据</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upsert into student values(&#39;1001&#39;,&#39;zhangsan&#39;, 10, &#39;beijing&#39;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查询记录</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from student;</span><br><span class="line">select * from student where id&#x3D;&#39;1001&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>删除记录</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from student where id&#x3D;&#39;1001&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>删除表</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table student;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>退出命令行</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!quit</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>表的映射</strong>  </p>
<p>默认情况下，==HBase中已存在的表，通过Phoenix是不可见的==。如果要在Phoenix中操作HBase中已存在的表，可以在 Phoenix中进行表的映射。映射方式有两种：==视图映射==和==表映射==。</p>
<ul>
<li>Phoenix创建的视图是只读的，所以只能用来做查询，无法通过视图对数据进行修改等操作。 </li>
<li>在Pheonix创建表去映射HBase中已经存在的表，是可以修改删除HBase中已经存在的数据的。而且删除Phoenix中的表，那么HBase中被映射的表也会被删除。</li>
</ul>
</li>
</ul>
<h3 id="2）Phoenix二级索引"><a href="#2）Phoenix二级索引" class="headerlink" title="2）Phoenix二级索引"></a>2）Phoenix二级索引</h3><p>Global Index 是默认的索引格式，创建全局索引时，会在HBase中建立一张新表。也就是说索引数据和数据表是存放在不同的表中的，因此全局索引适用于多读少写的业务场景。</p>
<p>写数据的时候会消耗大量开销，因为索引表也要更新，而索引表是分布在不同的数据节 点上的，跨节点的数据传输带来了较大的性能消耗。在读数据的时候Phoenix会选择索引表来降低查询消耗的时间。  </p>
<p>如果想查询的字段不是索引字段的话索引表不会被使用，也就是说不会带来查询速度的提升。</p>
<p>若想解决上述问题，可采用如下方案：</p>
<p>（1）<strong>使用包含索引</strong>；创建携带其他字段的全局索引（本质还是全局索引）。  </p>
<p>（2）<strong>使用本地索引</strong>。Local Index适用于写操作频繁的场景。索引数据和数据表的数据是存放在同一张表中（且是同一个 Region），避免了在写操作的时候往不同服务器的索引表中写索引带来的额外开销。本地索引会将所有的信息存在一个影子列族中，虽然读取的时候也是范围扫描，但是没有全局索引快，优点在于不用写多个表了。</p>
<h1 id="六-与Hive集成"><a href="#六-与Hive集成" class="headerlink" title="六.与Hive集成"></a>六.与Hive集成</h1><p>如果大量的数据已经存放在HBase上面，需要对已经存在的数据进行数据分析处理，那么Phoenix并不适合做特别复杂的SQL处理，此时可以使用hive映射HBase的表格，之后写HQL进行分析处理。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/04/BigData/Hadoop/Hadoop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/04/BigData/Hadoop/Hadoop/" class="post-title-link" itemprop="url">Hadoop</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-04 22:03:05 / 修改时间：22:09:10" itemprop="dateCreated datePublished" datetime="2023-04-04T22:03:05+08:00">2023-04-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BigData/" itemprop="url" rel="index"><span itemprop="name">BigData</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BigData/Hadoop/" itemprop="url" rel="index"><span itemprop="name">Hadoop</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/04/04/BigData/Hadoop/Hadoop/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/04/04/BigData/Hadoop/Hadoop/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-HDFS的文件块大小"><a href="#1-HDFS的文件块大小" class="headerlink" title="1. HDFS的文件块大小"></a>1. HDFS的文件块大小</h1><ol>
<li>物理存储块（block）大小为128M，由寻址时间和传输时间决定（寻址时间为传输时间的1%为最佳）。</li>
<li>块大小设置太小会增加寻址时间，设置太大会增加传输时间。</li>
</ol>
<h1 id="2-HDFS的读写流程"><a href="#2-HDFS的读写流程" class="headerlink" title="2. HDFS的读写流程"></a>2. HDFS的读写流程</h1><ul>
<li>写数据流程<ul>
<li>客户端通过Distributed FileSystem模块向NameNode请求上传文件，NameNode检查目标文件是否已存在，父目录是否存在。  </li>
<li>NameNode返回是否可以上传。  </li>
<li>客户端请求第一个 Block上传到哪几个DataNode服务器上。  </li>
<li>NameNode返回3个DataNode节点，分别为dn1、dn2、dn3。  </li>
<li>客户端通过FSDataOutputStream模块请求dn1上传数据，dn1收到请求会继续调用dn2，然后dn2调用dn3，将这个通信管道建立完成。  </li>
<li>dn1、dn2、dn3逐级应答客户端。</li>
<li>客户端开始往dn1上传第一个Block（先从磁盘读取数据放到一个本地内存缓存），以Packet为单位，dn1收到一个Packet就会传给dn2，dn2传给dn3；dn1每传一个packet会放入一个应答队列等待应答。</li>
<li>当一个Block传输完成之后，客户端再次请求NameNode上传第二个Block的服务器。（重复执行3-7步）。</li>
</ul>
</li>
<li>读数据流程<ul>
<li>客户端通过DistributedFileSystem向NameNode请求下载文件，NameNode通过查询元数据，找到文件块所在的DataNode地址。</li>
<li>挑选一台DataNode（就近原则，然后随机）服务器，请求读取数据。</li>
<li>DataNode开始传输数据给客户端（从磁盘里面读取数据输入流，以Packet为单位来做校验）。</li>
<li>客户端以Packet为单位接收，先在本地缓存，然后写入目标文件。  </li>
</ul>
</li>
</ul>
<h1 id="3-NameNode和SecondaryNameNode"><a href="#3-NameNode和SecondaryNameNode" class="headerlink" title="3.NameNode和SecondaryNameNode"></a>3.NameNode和SecondaryNameNode</h1><h3 id="第一阶段：NameNode启动"><a href="#第一阶段：NameNode启动" class="headerlink" title="第一阶段：NameNode启动"></a>第一阶段：NameNode启动</h3><p>（1）第一次启动NameNode格式化后，创建Fsimage和Edits文件。如果不是第一次启动，直接加载编辑日志和镜像文件到内存。</p>
<p>（2）客户端对元数据进行增删改的请求。</p>
<p>（3）NameNode记录操作日志，更新滚动日志。</p>
<p>（4）NameNode在内存中对元数据进行增删改。</p>
<h3 id="第二阶段：Secondary-NameNode工作"><a href="#第二阶段：Secondary-NameNode工作" class="headerlink" title="第二阶段：Secondary NameNode工作"></a>第二阶段：Secondary NameNode工作</h3><p>（1）Secondary NameNode询问NameNode是否需要CheckPoint。直接带回NameNode是否检查结果。</p>
<p>（2）Secondary NameNode请求执行CheckPoint。</p>
<p>（3）NameNode滚动正在写的Edits日志。</p>
<p>（4）将滚动前的编辑日志和镜像文件拷贝到Secondary NameNode。</p>
<p>（5）Secondary NameNode加载编辑日志和镜像文件到内存，并合并。</p>
<p>（6）生成新的镜像文件fsimage.chkpoint。</p>
<p>（7）拷贝fsimage.chkpoint到NameNode。</p>
<p>（8）NameNode将fsimage.chkpoint重新命名成fsimage。</p>
<p><strong>fsimage为元数据镜像文件，edits为元数据变更操作日志，均存储在磁盘上，NameNode启动时加载到内存。</strong></p>
<h1 id="4-DataNode"><a href="#4-DataNode" class="headerlink" title="4.DataNode"></a>4.DataNode</h1><h3 id="DataNode工作机制"><a href="#DataNode工作机制" class="headerlink" title="DataNode工作机制"></a>DataNode工作机制</h3><p>（1）一个数据块在DataNode上以文件形式存储在磁盘上，包括两个文件，一个是数据本身，一个是元数据包括数据块的长度，块数据的校验和，以及时间戳。</p>
<p>（2）DataNode启动后向NameNode注册，通过后，周期性（6小时）的向NameNode上报所有的块信息。</p>
<p>（3）心跳是每3秒一次，心跳返回结果带有NameNode给该DataNode的命令如复制块数据到另一台机器，或删除某个数据块。如果超过10分钟没有收到某个DataNode的心跳，则认为该节点不可用。</p>
<p>（4）集群运行中可以安全加入和退出一些机器。</p>
<h3 id="DataNode节点数据完整性"><a href="#DataNode节点数据完整性" class="headerlink" title="DataNode节点数据完整性"></a>DataNode节点数据完整性</h3><p>（1）当DataNode读取Block的时候，它会计算CheckSum。</p>
<p>（2）如果计算后的CheckSum，与Block创建时值不一样，说明Block已经损坏。</p>
<p>（3）Client读取其他DataNode上的Block。</p>
<p>（4）常见的校验算法crc（32），md5（128），sha1（160）</p>
<p>（5）DataNode在其文件创建后周期验证CheckSum。</p>
<h1 id="5-MapReduce"><a href="#5-MapReduce" class="headerlink" title="5. MapReduce"></a>5. MapReduce</h1><h3 id="MapReduce进程"><a href="#MapReduce进程" class="headerlink" title="MapReduce进程"></a>MapReduce进程</h3><p>一个完整的MapReduce程序在分布式运行时有三类实例进程：</p>
<p>（1）<strong>MrAppMaster</strong>：负责整个程序的过程调度及状态协调。</p>
<p>（2）<strong>MapTask</strong>：负责Map阶段的整个数据处理流程。</p>
<p>（3）<strong>ReduceTask</strong>：负责Reduce阶段的整个数据处理流程。</p>
<h3 id="Hadoop序列化"><a href="#Hadoop序列化" class="headerlink" title="Hadoop序列化"></a>Hadoop序列化</h3><ul>
<li><p><strong>序列化</strong>就是把内存中的对象，转换成字节序列（或其他数据传输协议）以便于存储到磁盘（持久化）和网络传输。 </p>
</li>
<li><p><strong>反序列化</strong>就是将收到字节序列（或其他数据传输协议）或者是磁盘的持久化数据，转换成内存中的对象。</p>
</li>
</ul>
<p>Java的序列化是一个重量级序列化框架（Serializable），一个对象被序列化后，会附带很多额外的信息（各种校验信息，Header，继承体系等），不便于在网络中高效传输。所以，Hadoop自己开发了一套序列化机制（Writable）。</p>
<h3 id="MapReduce框架原理"><a href="#MapReduce框架原理" class="headerlink" title="MapReduce框架原理"></a>MapReduce框架原理</h3><ul>
<li><strong>MapTask并行度决定机制</strong> <ul>
<li><strong>数据块：</strong>Block是HDFS物理上把数据分成一块一块。数据块是HDFS存储数据单位。</li>
<li><strong>数据切片：</strong>数据切片只是在逻辑上对输入进行分片，并不会在磁盘上将其切分成片进行存储。数据切片是MapReduce程序计算输入数据的单位，一个切片会对应启动一个MapTask。  </li>
</ul>
</li>
</ul>
<p><img src="ipic/数据切片与MapTask并行度决定机制-1680224243814.png" alt="数据切片与MapTask并行度决定机制"></p>
<p>==注：每次切片时，都要判断切完剩下的部分是否大于块的1.1倍，不大于1.1倍就划分一块切片。==</p>
<p>提交切片规划文件到YARN上，YARN上的MrAppMaster就可以根据切片规划文件计算开启MapTask的个数。</p>
<h3 id="MapReduce工作流程"><a href="#MapReduce工作流程" class="headerlink" title="MapReduce工作流程"></a>MapReduce工作流程</h3><p><img src="ipic/MapReduce详细工作流程.png" alt="MapReduce详细工作流程"></p>
<p><img src="ipic/MapReduce详细工作流程2.png" alt="MapReduce详细工作流程2"></p>
<ul>
<li><p>Shuffle过程详解 </p>
<p>（1）MapTask收集我们的map()方法输出的kv对，放到内存缓冲区中；</p>
<p>（2）从内存缓冲区不断溢出本地磁盘文件，可能会溢出多个文件；</p>
<p>（3）多个溢出文件会被合并成大的溢出文件；</p>
<p>（4）在溢出过程及合并的过程中，都要调用Partitioner进行分区和针对key进行排序；</p>
<p>（5）ReduceTask根据自己的分区号，去各个MapTask机器上取相应的结果分区数据；</p>
<p>（6）ReduceTask会抓取到同一个分区的来自不同MapTask的结果文件，ReduceTask会将这些文件再进行合并（归并排序）</p>
<p>（7）合并成大文件后，Shuffle的过程也就结束了，后面进入ReduceTask的逻辑运算过程（从文件中取出一个一个的键值对Group，调用用户自定义的reduce()方法）</p>
<p>==<strong>注意：</strong>==</p>
<p>==（1）Shuffle中的缓冲区大小会影响到MapReduce程序的执行效率，原则上说，缓冲区越大，磁盘io的次数越少，执行速度就越快。==</p>
<p>==（2）缓冲区的大小可以通过参数调整，参数：mapreduce.task.io.sort.mb默认100M。==</p>
</li>
</ul>
<h3 id="Shuffle机制"><a href="#Shuffle机制" class="headerlink" title="Shuffle机制"></a>Shuffle机制</h3><p><strong>==Map方法之后，Reduce方法之前==的数据处理过程称之为Shuffle。</strong></p>
<p><img src="ipic/Shuffle机制.png" alt="Shuffle机制"></p>
<h3 id="Partition分区"><a href="#Partition分区" class="headerlink" title="Partition分区"></a>Partition分区</h3><p>==默认分区是根据key的hash code对Reduce Tasks个数取模得到的。用户没法控制哪个key存储到哪个分区。==</p>
<p><img src="ipic/Partition分区总结.png" alt="Partition分区总结"></p>
<h3 id="WritableComparable排序"><a href="#WritableComparable排序" class="headerlink" title="WritableComparable排序"></a>WritableComparable排序</h3><p>MapTask和ReduceTask均会对数据按照key进行排序。该操作属于Hadoop的默认行为。==任何应用程序中的数据均会被排序，而不管逻辑上是否需要。==</p>
<p>默认排序是按照字典顺序排序，且实现该排序的方法是快速排序。</p>
<p><img src="ipic/MapReduce排序概述.png" alt="MapReduce排序概述"></p>
<h3 id="Combiner合并"><a href="#Combiner合并" class="headerlink" title="Combiner合并"></a>Combiner合并</h3><p><img src="ipic/combiner合并.png" alt="combiner合并"></p>
<p>==注：如果分区数不是1，但是ReduceTask为1，不执行分区过程。==</p>
<h3 id="Reduce-Join-（适合处理两个大表，需要多次进行磁盘IO）"><a href="#Reduce-Join-（适合处理两个大表，需要多次进行磁盘IO）" class="headerlink" title="Reduce Join  （适合处理两个大表，需要多次进行磁盘IO）"></a>Reduce Join  （适合处理两个大表，需要多次进行磁盘IO）</h3><p>Reduce join也称为Reduce端连接，适用于两个数据集的大小相当的情况。在Reduce join中，Map阶段将两个数据集中的记录分别标记为“left”和“right”，然后将它们分别输出到不同的Reducer中。 </p>
<p>以下是一些可能导致Reduce join数据倾斜的原因：</p>
<ol>
<li>连接键不合适：连接键的选择非常重要。如果选择的连接键分布不均匀，则会导致数据倾斜。例如，如果连接键是用户ID，而用户ID分布不均匀，则可能会导致数据倾斜。</li>
<li>数据分区不均匀：如果分区是基于连接键进行的，那么连接键分布不均匀也会导致数据分区不均匀，最终导致Reduce端数据倾斜。</li>
<li>数据倾斜的处理方式不当：处理数据倾斜的方式有很多种，但不同的方式适用于不同的情况。如果选择的方法不合适，则会导致更严重的数据倾斜问题。</li>
</ol>
<h3 id="Map-Join-（适合处理一个大表一个小表）"><a href="#Map-Join-（适合处理一个大表一个小表）" class="headerlink" title="Map Join  （适合处理一个大表一个小表）"></a>Map Join  （适合处理一个大表一个小表）</h3><p>Map join也称为Map端连接，适用于其中一个数据集比较小的情况。在Map join中，首先读取小的数据集并放入内存中，然后在Map阶段读取另一个大数据集的记录，并与内存中的小数据集进行连接。 </p>
<h3 id="数据清洗（ETL）"><a href="#数据清洗（ETL）" class="headerlink" title="数据清洗（ETL）"></a>数据清洗（ETL）</h3><p>在运行核心业务MapReduce程序之前，往往要先对数据进行清洗，清理掉不符合用户要求的数据。清理的过程往往只需要运行Mapper程序，不需要运行Reduce程序。</p>
<h1 id="6-Yarn"><a href="#6-Yarn" class="headerlink" title="6. Yarn"></a>6. Yarn</h1><h3 id="Yarn基础架构"><a href="#Yarn基础架构" class="headerlink" title="Yarn基础架构"></a>Yarn基础架构</h3><p>YARN主要由<strong>ResourceManager</strong>、<strong>NodeManager</strong>、<strong>ApplicationMaster</strong>和<strong>Container</strong>等组件构成。</p>
<p><img src="ipic/Yarn基础架构.png" alt="Yarn基础架构"></p>
<h3 id="Yarn工作机制"><a href="#Yarn工作机制" class="headerlink" title="Yarn工作机制"></a>Yarn工作机制</h3><p><img src="ipic/Yarn工作机制.png" alt="Yarn工作机制"></p>
<p>（1）MR程序提交到客户端所在的节点。</p>
<p>（2）YarnRunner向ResourceManager申请一个Application。</p>
<p>（3）RM将该应用程序的资源路径返回给YarnRunner。</p>
<p>（4）该程序将运行所需资源提交到HDFS上。</p>
<p>（5）程序资源提交完毕后，申请运行mrAppMaster。</p>
<p>（6）RM将用户的请求初始化成一个Task。</p>
<p>（7）其中一个NodeManager领取到Task任务。</p>
<p>（8）该NodeManager创建容器Container，并产生MRAppmaster。</p>
<p>（9）Container从HDFS上拷贝资源到本地。</p>
<p>（10）MRAppmaster向RM 申请运行MapTask资源。</p>
<p>（11）RM将运行MapTask任务分配给另外两个NodeManager，另两个NodeManager分别领取任务并创建容器。</p>
<p>（12）MR向两个接收到任务的NodeManager发送程序启动脚本，这两个NodeManager分别启动MapTask，MapTask对数据分区排序。</p>
<p>（13）MrAppMaster等待所有MapTask运行完毕后，向RM申请容器，运行ReduceTask。</p>
<p>（14）ReduceTask向MapTask获取相应分区的数据。</p>
<p>（15）程序运行完毕后，MR会向RM申请注销自己。</p>
<h3 id="Yarn调度器和调度算法"><a href="#Yarn调度器和调度算法" class="headerlink" title="Yarn调度器和调度算法"></a>Yarn调度器和调度算法</h3><p>Hadoop作业调度器主要有三种：<strong>FIFO</strong>、<strong>容量（Capacity Scheduler）</strong>和<strong>公平（Fair Scheduler）</strong>。  </p>
<p>==Hadoop3.1.3默认的资源调度器是Capacity Scheduler。==  </p>
<ul>
<li><strong>FIFO调度器（First In First Out）</strong>：单队列，根据提交作业的先后顺序，先来先服务。</li>
</ul>
<p><img src="ipic/FIFO调度器.png" alt="FIFO调度器"></p>
<ul>
<li><strong>容量调度器 (Capacity Scheduler)</strong>是Yahoo开发的多用户调度器。</li>
</ul>
<p><img src="ipic/容量调度器特点-1680336513973.png" alt="容量调度器特点"></p>
<p><img src="ipic/容量调度器资源分配算法.png" alt="容量调度器资源分配算法"></p>
<ul>
<li><strong>公平调度器（Fair Scheduler）</strong>是Facebook开发的多用户调度器。  </li>
</ul>
<p><img src="ipic/公平调度器特点.png" alt="公平调度器特点"></p>
<p><img src="ipic/公平调度器概念-缺额.png" alt="公平调度器概念-缺额"></p>
<p><img src="ipic/公平调度器资源分配方式.png" alt="公平调度器资源分配方式"></p>
<p><img src="ipic/公平调度器队列资源分配方式2.png" alt="公平调度器队列资源分配方式2"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/10/LeetCode_Solution/1894.%E6%89%BE%E5%88%B0%E9%9C%80%E8%A6%81%E8%A1%A5%E5%85%85%E7%B2%89%E7%AC%94%E7%9A%84%E5%AD%A6%E7%94%9F%E7%BC%96%E5%8F%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/10/LeetCode_Solution/1894.%E6%89%BE%E5%88%B0%E9%9C%80%E8%A6%81%E8%A1%A5%E5%85%85%E7%B2%89%E7%AC%94%E7%9A%84%E5%AD%A6%E7%94%9F%E7%BC%96%E5%8F%B7/" class="post-title-link" itemprop="url">1894.找到需要补充粉笔的学生编号</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-09-10 15:52:55 / 修改时间：16:02:05" itemprop="dateCreated datePublished" datetime="2021-09-10T15:52:55+08:00">2021-09-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/LeetCode%E9%A2%98%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">LeetCode题解</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/09/10/LeetCode_Solution/1894.%E6%89%BE%E5%88%B0%E9%9C%80%E8%A6%81%E8%A1%A5%E5%85%85%E7%B2%89%E7%AC%94%E7%9A%84%E5%AD%A6%E7%94%9F%E7%BC%96%E5%8F%B7/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/09/10/LeetCode_Solution/1894.%E6%89%BE%E5%88%B0%E9%9C%80%E8%A6%81%E8%A1%A5%E5%85%85%E7%B2%89%E7%AC%94%E7%9A%84%E5%AD%A6%E7%94%9F%E7%BC%96%E5%8F%B7/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="方法一：优化的模拟"><a href="#方法一：优化的模拟" class="headerlink" title="方法一：优化的模拟"></a>方法一：优化的模拟</h2><p><strong>思路与算法</strong>：先求出一轮消耗的粉笔总数total，将粉笔数量k对total进行取模，求得余数一定小于total，因此只需遍历一次数组chalk即可求出学生编号。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">chalkReplacer</span><span class="params">(<span class="keyword">int</span>[] chalk, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = chalk.length;</span><br><span class="line">        <span class="keyword">long</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : chalk) &#123;</span><br><span class="line">            total += num;</span><br><span class="line">        &#125;</span><br><span class="line">        k %= total;</span><br><span class="line">        <span class="keyword">int</span> res = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chalk[i] &gt; k) &#123;</span><br><span class="line">                res = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            k -= chalk[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二：前缀和-二分查找"><a href="#方法二：前缀和-二分查找" class="headerlink" title="方法二：前缀和 + 二分查找"></a>方法二：前缀和 + 二分查找</h2><p><strong>思路与算法</strong>：对于方法一中的第二次遍历，我们也可以使用二分查找进行加速。</p>
<p>在对数组chalk 的遍历过程中，我们可以求出其前缀和，记为数组pre。那么需要补充粉笔的学生编号$i’$是最小的满足 $\textit{pre}[i] &gt; k’$的下标$i’$可以通过二分查找在$ O(\log n)$ 的时间内找出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">chalkReplacer</span><span class="params">(<span class="keyword">int</span>[] chalk, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = chalk.length;</span><br><span class="line">        <span class="keyword">if</span> (chalk[<span class="number">0</span>] &gt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            chalk[i] += chalk[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (chalk[i] &gt; k) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        k %= chalk[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> binarySearch(chalk, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (high - low) / <span class="number">2</span> + low;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &lt;= target) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>细节：</strong>在求total时可能产生溢出，需使用long来定义total；</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/12/Data%20_Competition/Numpy_Practice/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0%E5%8F%8A%E9%80%BB%E8%BE%91%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/12/Data%20_Competition/Numpy_Practice/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0%E5%8F%8A%E9%80%BB%E8%BE%91%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">第四章 数学函数及逻辑函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-07-12 15:56:02 / 修改时间：15:55:16" itemprop="dateCreated datePublished" datetime="2021-07-12T15:56:02+08:00">2021-07-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">数据竞赛</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B/Numpy%E5%AE%9E%E8%B7%B5/" itemprop="url" rel="index"><span itemprop="name">Numpy实践</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/07/12/Data%20_Competition/Numpy_Practice/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0%E5%8F%8A%E9%80%BB%E8%BE%91%E5%87%BD%E6%95%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/07/12/Data%20_Competition/Numpy_Practice/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0%E5%8F%8A%E9%80%BB%E8%BE%91%E5%87%BD%E6%95%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="逻辑函数"><a href="#逻辑函数" class="headerlink" title="逻辑函数"></a>逻辑函数</h1><h2 id="真值测试"><a href="#真值测试" class="headerlink" title="真值测试"></a>真值测试</h2><h3 id="numpy-all"><a href="#numpy-all" class="headerlink" title="numpy.all"></a>numpy.all</h3><ul>
<li><code>numpy.all(a, axis=None, out=None, keepdims=np._NoValue)</code> Test whether all array elements along a given axis evaluate to True.</li>
</ul>
<h3 id="numpy-any"><a href="#numpy-any" class="headerlink" title="numpy.any"></a>numpy.any</h3><ul>
<li><code>numpy.any(a, axis=None, out=None, keepdims=np._NoValue)</code> Test whether any array element along a given axis evaluates to True.</li>
</ul>
<h2 id="数组内容"><a href="#数组内容" class="headerlink" title="数组内容"></a>数组内容</h2><h3 id="numpy-isnan"><a href="#numpy-isnan" class="headerlink" title="numpy.isnan"></a>numpy.isnan</h3><ul>
<li><code>numpy.isnan(x, *args, **kwargs)</code> Test element-wise for NaN and return result as a boolean array.</li>
</ul>
<h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><h3 id="numpy-logical-not"><a href="#numpy-logical-not" class="headerlink" title="numpy.logical_not"></a>numpy.logical_not</h3><ul>
<li><code>numpy.logical_not(x, *args, **kwargs)</code>Compute the truth value of NOT x element-wise.</li>
</ul>
<h3 id="numpy-logical-and"><a href="#numpy-logical-and" class="headerlink" title="numpy.logical_and"></a>numpy.logical_and</h3><ul>
<li><code>numpy.logical_and(x1, x2, *args, **kwargs)</code> Compute the truth value of x1 AND x2 element-wise.</li>
</ul>
<h3 id="numpy-logical-or"><a href="#numpy-logical-or" class="headerlink" title="numpy.logical_or"></a>numpy.logical_or</h3><ul>
<li><code>numpy.logical_or(x1, x2, *args, **kwargs)</code>Compute the truth value of x1 OR x2 element-wise.</li>
</ul>
<h3 id="numpy-logical-xor"><a href="#numpy-logical-xor" class="headerlink" title="numpy.logical_xor"></a>numpy.logical_xor</h3><ul>
<li><code>numpy.logical_xor(x1, x2, *args, **kwargs)</code>Compute the truth value of x1 XOR x2, element-wise.</li>
</ul>
<h2 id="对照"><a href="#对照" class="headerlink" title="对照"></a>对照</h2><h3 id="numpy-greater"><a href="#numpy-greater" class="headerlink" title="numpy.greater"></a>numpy.greater</h3><ul>
<li><code>numpy.greater(x1, x2, *args, **kwargs)</code> Return the truth value of (x1 &gt; x2) element-wise.</li>
</ul>
<h3 id="numpy-greater-equal"><a href="#numpy-greater-equal" class="headerlink" title="numpy.greater_equal"></a>numpy.greater_equal</h3><ul>
<li><code>numpy.greater_equal(x1, x2, *args, **kwargs)</code> Return the truth value of (x1 &gt;= x2) element-wise.</li>
</ul>
<h3 id="numpy-equal"><a href="#numpy-equal" class="headerlink" title="numpy.equal"></a>numpy.equal</h3><ul>
<li><code>numpy.equal(x1, x2, *args, **kwargs)</code> Return (x1 == x2) element-wise.</li>
</ul>
<h3 id="numpy-not-equal"><a href="#numpy-not-equal" class="headerlink" title="numpy.not_equal"></a>numpy.not_equal</h3><ul>
<li><code>numpy.not_equal(x1, x2, *args, **kwargs)</code> Return (x1 != x2) element-wise.</li>
</ul>
<h3 id="numpy-less"><a href="#numpy-less" class="headerlink" title="numpy.less"></a>numpy.less</h3><ul>
<li><code>numpy.less(x1, x2, *args, **kwargs)</code> Return the truth value of (x1 &lt; x2) element-wise.</li>
</ul>
<h3 id="numpy-less-equal"><a href="#numpy-less-equal" class="headerlink" title="numpy.less_equal"></a>numpy.less_equal</h3><ul>
<li><code>numpy.less_equal(x1, x2, *args, **kwargs)</code> Return the truth value of (x1 =&lt; x2) element-wise.</li>
</ul>
<h3 id="numpy-isclose"><a href="#numpy-isclose" class="headerlink" title="numpy.isclose"></a>numpy.isclose</h3><ul>
<li><code>numpy.isclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False)</code> Returns a boolean array where two arrays are element-wise equal within a tolerance.</li>
</ul>
<h3 id="numpy-allclose"><a href="#numpy-allclose" class="headerlink" title="numpy.allclose"></a>numpy.allclose</h3><ul>
<li><code>numpy.allclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False)</code> Returns True if two arrays are element-wise equal within a tolerance.</li>
</ul>
<p><code>numpy.allclose()</code> 等价于 <code>numpy.all(isclose(a, b, rtol=rtol, atol=atol, equal_nan=equal_nan))</code>。</p>
<p>判断是否为True的计算依据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.absolute(a - b) &lt;= (atol + rtol * absolute(b))</span><br><span class="line"></span><br><span class="line">- atol：<span class="built_in">float</span>，绝对公差。</span><br><span class="line">- rtol：<span class="built_in">float</span>，相对公差。</span><br></pre></td></tr></table></figure>
<p>NaNs are treated as equal if they are in the same place and if <code>equal_nan=True</code>. Infs are treated as equal if they are in the same place and of the same sign in both arrays.</p>
<h1 id="向量化和广播"><a href="#向量化和广播" class="headerlink" title="向量化和广播"></a>向量化和广播</h1><p>向量化和广播这两个概念是 numpy 内部实现的基础。有了向量化，编写代码时无需使用显式循环。这些循环实际上不能省略，只不过是在内部实现，被代码中的其他结构代替。向量化的应用使得代码更简洁，可读性更强，也可以说使用了向量化方法的代码看上去更“Pythonic”。</p>
<p>广播（Broadcasting）机制描述了 numpy 如何在算术运算期间处理具有不同形状的数组，让较小的数组在较大的数组上“广播”，以便它们具有兼容的形状。并不是所有的维度都要彼此兼容才符合广播机制的要求，但它们必须满足一定的条件。</p>
<p>若两个数组的各维度兼容，也就是两个数组的每一维等长，或其中一个数组为 一维，那么广播机制就适用。如果这两个条件不满足，numpy就会抛出异常，说两个数组不兼容。</p>
<p>总结来说，广播的规则有三个：</p>
<ul>
<li>如果两个数组的维度数dim不相同，那么小维度数组的形状将会在左边补1。</li>
<li>如果shape维度不匹配，但是有维度是1，那么可以扩展维度是1的维度匹配另一个数组；</li>
<li>如果shape维度不匹配，但是没有任何一个维度是1，则匹配引发错误；</li>
</ul>
<h1 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h1><h2 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h2><h3 id="numpy-add"><a href="#numpy-add" class="headerlink" title="numpy.add"></a>numpy.add</h3><ul>
<li><code>numpy.add(x1, x2, *args, **kwargs)</code> Add arguments element-wise.</li>
</ul>
<h3 id="numpy-subtract"><a href="#numpy-subtract" class="headerlink" title="numpy.subtract"></a>numpy.subtract</h3><ul>
<li><code>numpy.subtract(x1, x2, *args, **kwargs)</code> Subtract arguments element-wise.</li>
</ul>
<h3 id="numpy-multiply"><a href="#numpy-multiply" class="headerlink" title="numpy.multiply"></a>numpy.multiply</h3><ul>
<li><code>numpy.multiply(x1, x2, *args, **kwargs)</code> Multiply arguments element-wise.</li>
</ul>
<h3 id="numpy-divide"><a href="#numpy-divide" class="headerlink" title="numpy.divide"></a>numpy.divide</h3><ul>
<li><code>numpy.divide(x1, x2, *args, **kwargs)</code> Returns a true division of the inputs, element-wise.</li>
</ul>
<h3 id="numpy-floor-divide"><a href="#numpy-floor-divide" class="headerlink" title="numpy.floor_divide"></a>numpy.floor_divide</h3><ul>
<li><code>numpy.floor_divide(x1, x2, *args, **kwargs)</code> Return the largest integer smaller or equal to the division of the inputs.</li>
</ul>
<h3 id="numpy-power"><a href="#numpy-power" class="headerlink" title="numpy.power"></a>numpy.power</h3><ul>
<li><code>numpy.power(x1, x2, *args, **kwargs)</code> First array elements raised to powers from second array, element-wise</li>
</ul>
<p>在 numpy 中对以上函数进行了运算符的重载，且运算符为 <strong>元素级</strong>。也就是说，它们只用于位置相同的元素之间，所得到的运算结果组成一个新的数组</p>
<h3 id="numpy-sqrt"><a href="#numpy-sqrt" class="headerlink" title="numpy.sqrt"></a>numpy.sqrt</h3><ul>
<li><code>numpy.sqrt(x, *args, **kwargs)</code> Return the non-negative square-root of an array, element-wise.</li>
</ul>
<h3 id="numpy-square"><a href="#numpy-square" class="headerlink" title="numpy.square"></a>numpy.square</h3><ul>
<li><code>numpy.square(x, *args, **kwargs)</code> Return the element-wise square of the input.</li>
</ul>
<h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><h3 id="numpy-sin"><a href="#numpy-sin" class="headerlink" title="numpy.sin"></a>numpy.sin</h3><ul>
<li><code>numpy.sin(x, *args, **kwargs)</code> Trigonometric sine, element-wise.</li>
</ul>
<h3 id="numpy-cos"><a href="#numpy-cos" class="headerlink" title="numpy.cos"></a>numpy.cos</h3><ul>
<li><code>numpy.cos(x, *args, **kwargs)</code> Cosine element-wise.</li>
</ul>
<h3 id="numpy-tan"><a href="#numpy-tan" class="headerlink" title="numpy.tan"></a>numpy.tan</h3><ul>
<li><code>numpy.tan(x, *args, **kwargs)</code> Compute tangent element-wise.</li>
</ul>
<h3 id="numpy-arcsin"><a href="#numpy-arcsin" class="headerlink" title="numpy.arcsin"></a>numpy.arcsin</h3><ul>
<li><code>numpy.arcsin(x, *args, **kwargs)</code> Inverse sine, element-wise.</li>
</ul>
<h3 id="numpy-arccos"><a href="#numpy-arccos" class="headerlink" title="numpy.arccos"></a>numpy.arccos</h3><ul>
<li><code>numpy.arccos(x, *args, **kwargs)</code> Trigonometric inverse cosine, element-wise.</li>
</ul>
<h3 id="numpy-arctan"><a href="#numpy-arctan" class="headerlink" title="numpy.arctan"></a>numpy.arctan</h3><ul>
<li><code>numpy.arctan(x, *args, **kwargs)</code> Trigonometric inverse tangent, element-wise.</li>
</ul>
<p><strong>通用函数</strong>（universal function）通常叫作ufunc，它对数组中的各个元素逐一进行操作。这表明，通用函数分别处理输入数组的每个元素，生成的结果组成一个新的输出数组。输出数组的大小跟输入数组相同。</p>
<p>三角函数等很多数学运算符合通用函数的定义，例如，计算平方根的<code>sqrt()</code>函数、用来取对数的<code>log()</code>函数和求正弦值的<code>sin()</code>函数。</p>
<h2 id="指数和对数"><a href="#指数和对数" class="headerlink" title="指数和对数"></a>指数和对数</h2><h3 id="numpy-exp"><a href="#numpy-exp" class="headerlink" title="numpy.exp"></a>numpy.exp</h3><ul>
<li><code>numpy.exp(x, *args, **kwargs)</code> Calculate the exponential of all elements in the input array.</li>
</ul>
<h3 id="numpy-log"><a href="#numpy-log" class="headerlink" title="numpy.log"></a>numpy.log</h3><ul>
<li><code>numpy.log(x, *args, **kwargs)</code> Natural logarithm, element-wise.</li>
</ul>
<h3 id="numpy-exp2"><a href="#numpy-exp2" class="headerlink" title="numpy.exp2"></a>numpy.exp2</h3><ul>
<li><code>numpy.exp2(x, *args, **kwargs)</code> Calculate <code>2**p</code> for all <code>p</code> in the input array.</li>
</ul>
<h3 id="numpy-log2"><a href="#numpy-log2" class="headerlink" title="numpy.log2"></a>numpy.log2</h3><ul>
<li><code>numpy.log2(x, *args, **kwargs)</code> Base-2 logarithm of <code>x</code>.</li>
</ul>
<h3 id="numpy-log10"><a href="#numpy-log10" class="headerlink" title="numpy.log10"></a>numpy.log10</h3><ul>
<li><code>numpy.log10(x, *args, **kwargs)</code> Return the base 10 logarithm of the input array, element-wise.</li>
</ul>
<h2 id="加法函数、乘法函数"><a href="#加法函数、乘法函数" class="headerlink" title="加法函数、乘法函数"></a>加法函数、乘法函数</h2><h3 id="numpy-sum"><a href="#numpy-sum" class="headerlink" title="numpy.sum"></a>numpy.sum</h3><ul>
<li><code>numpy.sum(a[, axis=None, dtype=None, out=None, …])</code> Sum of array elements over a given axis.</li>
</ul>
<p>通过不同的 <code>axis</code>，numpy 会沿着不同的方向进行操作：如果不设置，那么对所有的元素操作；如果<code>axis=0</code>，则沿着纵轴进行操作；<code>axis=1</code>，则沿着横轴进行操作。但这只是简单的二位数组，如果是多维的呢？可以总结为一句话：设<code>axis=i</code>，则 numpy 沿着第<code>i</code>个下标变化的方向进行操作。</p>
<h3 id="numpy-cumsum"><a href="#numpy-cumsum" class="headerlink" title="numpy.cumsum"></a>numpy.cumsum</h3><ul>
<li><code>numpy.cumsum(a, axis=None, dtype=None, out=None)</code> Return the cumulative sum of the elements along a given axis.</li>
</ul>
<p><strong>聚合函数</strong> 是指对一组值（比如一个数组）进行操作，返回一个单一值作为结果的函数。因而，求数组所有元素之和的函数就是聚合函数。<code>ndarray</code>类实现了多个这样的函数。</p>
<h3 id="numpy-prod-乘积"><a href="#numpy-prod-乘积" class="headerlink" title="numpy.prod 乘积"></a>numpy.prod 乘积</h3><ul>
<li><code>numpy.prod(a[, axis=None, dtype=None, out=None, …])</code> Return the product of array elements over a given axis.</li>
</ul>
<h3 id="numpy-cumprod-累乘"><a href="#numpy-cumprod-累乘" class="headerlink" title="numpy.cumprod 累乘"></a>numpy.cumprod 累乘</h3><ul>
<li><code>numpy.cumprod(a, axis=None, dtype=None, out=None)</code> Return the cumulative product of elements along a given axis.</li>
</ul>
<h3 id="numpy-diff-差值"><a href="#numpy-diff-差值" class="headerlink" title="numpy.diff 差值"></a>numpy.diff 差值</h3><ul>
<li><code>numpy.diff(a, n=1, axis=-1, prepend=np._NoValue, append=np._NoValue)</code> Calculate the n-th discrete difference along the given axis.<ul>
<li>a：输入矩阵</li>
<li>n：可选，代表要执行几次差值</li>
<li>axis：默认是最后一个</li>
</ul>
</li>
</ul>
<p>The first difference is given by <code>out[i] = a[i+1] - a[i]</code> along the given axis, higher differences are calculated by using <code>diff</code> recursively.</p>
<h2 id="四舍五入"><a href="#四舍五入" class="headerlink" title="四舍五入"></a>四舍五入</h2><h3 id="numpy-around-舍入"><a href="#numpy-around-舍入" class="headerlink" title="numpy.around 舍入"></a>numpy.around 舍入</h3><ul>
<li><code>numpy.around(a, decimals=0, out=None)</code> Evenly round to the given number of decimals.</li>
</ul>
<h3 id="numpy-ceil-上限"><a href="#numpy-ceil-上限" class="headerlink" title="numpy.ceil 上限"></a>numpy.ceil 上限</h3><ul>
<li><code>numpy.ceil(x, *args, **kwargs)</code> Return the ceiling of the input, element-wise.</li>
</ul>
<h3 id="numpy-floor-下限"><a href="#numpy-floor-下限" class="headerlink" title="numpy.floor 下限"></a>numpy.floor 下限</h3><ul>
<li><code>numpy.floor(x, *args, **kwargs)</code> Return the floor of the input, element-wise.</li>
</ul>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="numpy-clip-裁剪"><a href="#numpy-clip-裁剪" class="headerlink" title="numpy.clip 裁剪"></a>numpy.clip 裁剪</h3><ul>
<li><code>numpy.clip(a, a_min, a_max, out=None, **kwargs):</code> Clip (limit) the values in an array.</li>
</ul>
<p>Given an interval, values outside the interval are clipped to the interval edges. For example, if an interval of <code>[0, 1]</code> is specified, values smaller than 0 become 0, and values larger than 1 become 1.</p>
<h3 id="numpy-absolute-绝对值"><a href="#numpy-absolute-绝对值" class="headerlink" title="numpy.absolute 绝对值"></a>numpy.absolute 绝对值</h3><ul>
<li><code>numpy.absolute(x, *args, **kwargs)</code> Calculate the absolute value element-wise.</li>
</ul>
<h3 id="numpy-abs"><a href="#numpy-abs" class="headerlink" title="numpy.abs"></a>numpy.abs</h3><ul>
<li><code>numpy.abs(x, *args, **kwargs)</code> is a shorthand for this function.</li>
</ul>
<h3 id="numpy-sign-返回数字符号的逐元素指示"><a href="#numpy-sign-返回数字符号的逐元素指示" class="headerlink" title="numpy.sign 返回数字符号的逐元素指示"></a>numpy.sign 返回数字符号的逐元素指示</h3><ul>
<li><code>numpy.sign(x, *args, **kwargs)</code> Returns an element-wise indication of the sign of a number.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/06/Data%20_Competition/Numpy_Practice/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E7%BB%84%E7%9A%84%E6%93%8D%E4%BD%9C-%E5%8F%98%E5%BD%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/06/Data%20_Competition/Numpy_Practice/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E7%BB%84%E7%9A%84%E6%93%8D%E4%BD%9C-%E5%8F%98%E5%BD%A2/" class="post-title-link" itemprop="url">第三章 数组的操作-变形</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-07-06 18:01:30 / 修改时间：18:00:56" itemprop="dateCreated datePublished" datetime="2021-07-06T18:01:30+08:00">2021-07-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">数据竞赛</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B/Numpy%E5%AE%9E%E8%B7%B5/" itemprop="url" rel="index"><span itemprop="name">Numpy实践</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/07/06/Data%20_Competition/Numpy_Practice/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E7%BB%84%E7%9A%84%E6%93%8D%E4%BD%9C-%E5%8F%98%E5%BD%A2/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/07/06/Data%20_Competition/Numpy_Practice/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E7%BB%84%E7%9A%84%E6%93%8D%E4%BD%9C-%E5%8F%98%E5%BD%A2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h1><h2 id="更改形状"><a href="#更改形状" class="headerlink" title="更改形状"></a>更改形状</h2><p>在对数组进行操作时，为了满足格式和计算的要求通常会改变其形状。</p>
<ul>
<li>numpy.ndarray.shape表示数组的维度，返回一个元组，这个元组的长度就是维度的数目，即ndim属性（秩）。</li>
</ul>
<p>例：通过修改shape属性来改变数组的形状。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line">print(x.shape) <span class="comment">#(8,)</span></span><br><span class="line">x.shape = [<span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">print(x)</span><br><span class="line"><span class="comment">#[[1 2 9 4]</span></span><br><span class="line"><span class="comment"># [5 6 7 8]]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>numpy.ndarray.flat 将数组转换为一维的迭代器，可以用for访问数组每一个元组。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.array([[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">           	  [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>],</span><br><span class="line">              [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>],</span><br><span class="line">              [<span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>],</span><br><span class="line">              [<span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>]])</span><br><span class="line">y = x.flat</span><br><span class="line">print(y)<span class="comment"># &lt;numpy.flatiter object at 0x0000020F9BA10C60&gt;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> y:</span><br><span class="line">    print(i, end = <span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="comment"># 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35</span></span><br><span class="line">y[<span class="number">3</span>] = <span class="number">0</span></span><br><span class="line">print(x)</span><br><span class="line"><span class="comment"># [[11 12 13  0 15]</span></span><br><span class="line"><span class="comment">#  [16 17 18 19 20]</span></span><br><span class="line"><span class="comment">#  [21 22 23 24 25]</span></span><br><span class="line"><span class="comment">#  [26 27 28 29 30]</span></span><br><span class="line"><span class="comment">#  [31 32 33 34 35]]</span></span><br></pre></td></tr></table></figure>
<p>修改迭代器中的元素，原数组中对应元素也相应改变。</p>
<ul>
<li>numpy.ndarray.flatten([order = ‘C’])将数组的副本转换为一维数组，并返回。<ul>
<li>order：‘C’ — 按行，’F’—按列，’A’—原顺序，’K’—元素在内存中的出现顺序。</li>
</ul>
</li>
</ul>
<p>例：<code>flatten()</code>函数返回的是拷贝。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">              [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>],</span><br><span class="line">              [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>],</span><br><span class="line">              [<span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>],</span><br><span class="line">              [<span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>]])</span><br><span class="line">y = x.flatten(order=<span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [11 16 21 26 31 12 17 22 27 32 13 18 23 28 33 14 19 24 29 34 15 20 25 30</span></span><br><span class="line"><span class="comment">#  35]</span></span><br><span class="line"></span><br><span class="line">y[<span class="number">3</span>] = <span class="number">0</span></span><br><span class="line">print(x)</span><br><span class="line"><span class="comment"># [[11 12 13 14 15]</span></span><br><span class="line"><span class="comment">#  [16 17 18 19 20]</span></span><br><span class="line"><span class="comment">#  [21 22 23 24 25]</span></span><br><span class="line"><span class="comment">#  [26 27 28 29 30]</span></span><br><span class="line"><span class="comment">#  [31 32 33 34 35]]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>numpy.ravel(a, order = ‘C’) Return a contiguous flattened array.</li>
</ul>
<p>例：<code>ravel()</code>返回的是视图。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">              [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>],</span><br><span class="line">              [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>],</span><br><span class="line">              [<span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>],</span><br><span class="line">              [<span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>]])</span><br><span class="line">y = np.ravel(x)</span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34</span></span><br><span class="line"><span class="comment">#  35]</span></span><br><span class="line"></span><br><span class="line">y[<span class="number">3</span>] = <span class="number">0</span></span><br><span class="line">print(x)</span><br><span class="line"><span class="comment"># [[11 12 13  0 15]</span></span><br><span class="line"><span class="comment">#  [16 17 18 19 20]</span></span><br><span class="line"><span class="comment">#  [21 22 23 24 25]</span></span><br><span class="line"><span class="comment">#  [26 27 28 29 30]</span></span><br><span class="line"><span class="comment">#  [31 32 33 34 35]</span></span><br></pre></td></tr></table></figure>
<p>例：order=F 就是拷贝</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">              [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>],</span><br><span class="line">              [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>],</span><br><span class="line">              [<span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>],</span><br><span class="line">              [<span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>]])</span><br><span class="line"></span><br><span class="line">y = np.ravel(x, order=<span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [11 16 21 26 31 12 17 22 27 32 13 18 23 28 33 14 19 24 29 34 15 20 25 30</span></span><br><span class="line"><span class="comment">#  35]</span></span><br><span class="line"></span><br><span class="line">y[<span class="number">3</span>] = <span class="number">0</span></span><br><span class="line">print(x)</span><br><span class="line"><span class="comment"># [[11 12 13 14 15]</span></span><br><span class="line"><span class="comment">#  [16 17 18 19 20]</span></span><br><span class="line"><span class="comment">#  [21 22 23 24 25]</span></span><br><span class="line"><span class="comment">#  [26 27 28 29 30]</span></span><br><span class="line"><span class="comment">#  [31 32 33 34 35]]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>numpy.reshape(a, newshape[, order = ‘C’])在不更改数据的情况下为数组赋予新的形状。</li>
</ul>
<p>例：<code>reshape()</code>函数当参数<code>newshape = [rows,-1]</code>时，将根据行数自动确定列数；<code>newshape = [-1,column]</code>时，将根据行数自动确定行数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.arange(<span class="number">12</span>)</span><br><span class="line">y = np.reshape(x, [<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">print(y.dtype)  <span class="comment"># int32</span></span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [[ 0  1  2  3]</span></span><br><span class="line"><span class="comment">#  [ 4  5  6  7]</span></span><br><span class="line"><span class="comment">#  [ 8  9 10 11]]</span></span><br><span class="line"></span><br><span class="line">y = np.reshape(x, [<span class="number">3</span>, -<span class="number">1</span>])</span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [[ 0  1  2  3]</span></span><br><span class="line"><span class="comment">#  [ 4  5  6  7]</span></span><br><span class="line"><span class="comment">#  [ 8  9 10 11]]</span></span><br><span class="line"></span><br><span class="line">y = np.reshape(x,[-<span class="number">1</span>,<span class="number">3</span>])</span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [[ 0  1  2]</span></span><br><span class="line"><span class="comment">#  [ 3  4  5]</span></span><br><span class="line"><span class="comment">#  [ 6  7  8]</span></span><br><span class="line"><span class="comment">#  [ 9 10 11]]</span></span><br><span class="line"></span><br><span class="line">y[<span class="number">0</span>, <span class="number">1</span>] = <span class="number">10</span></span><br><span class="line">print(x)</span><br><span class="line"><span class="comment"># [ 0 10  2  3  4  5  6  7  8  9 10 11]（改变x去reshape后y中的值，x对应元素也改变）</span></span><br></pre></td></tr></table></figure>
<p>例：<code>reshape()</code>函数当参数<code>newshape = -1</code>时，表示将数组降为一维。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.random.randint(<span class="number">12</span>, size=[<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">print(x)</span><br><span class="line"><span class="comment"># [[[11  9  1]</span></span><br><span class="line"><span class="comment">#   [ 1 10  3]]</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#  [[ 0  6  1]</span></span><br><span class="line"><span class="comment">#   [ 4 11  3]]]</span></span><br><span class="line">y = np.reshape(x, -<span class="number">1</span>)</span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [11  9  1  1 10  3  0  6  1  4 11  3]</span></span><br></pre></td></tr></table></figure>
<h2 id="数组转置"><a href="#数组转置" class="headerlink" title="数组转置"></a>数组转置</h2><ul>
<li>numpy.transpose(a, axes = None) Permute the dimensions of an array.</li>
<li>numpy.ndarray.T Same as self.transpose(),except that self is returned if self.ndim &lt; 2.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.random.rand(<span class="number">5</span>, <span class="number">5</span>) * <span class="number">10</span></span><br><span class="line">x = np.around(x, <span class="number">2</span>)</span><br><span class="line">print(x)</span><br><span class="line"><span class="comment"># [[6.74 8.46 6.74 5.45 1.25]</span></span><br><span class="line"><span class="comment">#  [3.54 3.49 8.62 1.94 9.92]</span></span><br><span class="line"><span class="comment">#  [5.03 7.22 1.6  8.7  0.43]</span></span><br><span class="line"><span class="comment">#  [7.5  7.31 5.69 9.67 7.65]</span></span><br><span class="line"><span class="comment">#  [1.8  9.52 2.78 5.87 4.14]]</span></span><br><span class="line">y = x.T</span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [[6.74 3.54 5.03 7.5  1.8 ]</span></span><br><span class="line"><span class="comment">#  [8.46 3.49 7.22 7.31 9.52]</span></span><br><span class="line"><span class="comment">#  [6.74 8.62 1.6  5.69 2.78]</span></span><br><span class="line"><span class="comment">#  [5.45 1.94 8.7  9.67 5.87]</span></span><br><span class="line"><span class="comment">#  [1.25 9.92 0.43 7.65 4.14]]</span></span><br><span class="line">y = np.transpose(x)</span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [[6.74 3.54 5.03 7.5  1.8 ]</span></span><br><span class="line"><span class="comment">#  [8.46 3.49 7.22 7.31 9.52]</span></span><br><span class="line"><span class="comment">#  [6.74 8.62 1.6  5.69 2.78]</span></span><br><span class="line"><span class="comment">#  [5.45 1.94 8.7  9.67 5.87]</span></span><br><span class="line"><span class="comment">#  [1.25 9.92 0.43 7.65 4.14]]</span></span><br></pre></td></tr></table></figure>
<h2 id="更改维度"><a href="#更改维度" class="headerlink" title="更改维度"></a>更改维度</h2><p>当创建一个数组之后，还可以给它增加一个维度，这在矩阵计算中经常会用到。</p>
<ul>
<li>numpy.newaxis = None None的别名，对索引数组很有用。</li>
</ul>
<p>例：很多工具包在进行计算时都会先判断输入数据的维度是否满足要求，如果输入数据达不到指定的维度时，可以使用<code>newaxis</code>参数来增加一个维度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line">print(x.shape)  <span class="comment"># (8,)</span></span><br><span class="line">print(x)  <span class="comment"># [1 2 9 4 5 6 7 8]</span></span><br><span class="line"></span><br><span class="line">y = x[np.newaxis, :]</span><br><span class="line">print(y.shape)  <span class="comment"># (1, 8)</span></span><br><span class="line">print(y)  <span class="comment"># [[1 2 9 4 5 6 7 8]]</span></span><br><span class="line"></span><br><span class="line">y = x[:, np.newaxis]</span><br><span class="line">print(y.shape)  <span class="comment"># (8, 1)</span></span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [[1]</span></span><br><span class="line"><span class="comment">#  [2]</span></span><br><span class="line"><span class="comment">#  [9]</span></span><br><span class="line"><span class="comment">#  [4]</span></span><br><span class="line"><span class="comment">#  [5]</span></span><br><span class="line"><span class="comment">#  [6]</span></span><br><span class="line"><span class="comment">#  [7]</span></span><br><span class="line"><span class="comment">#  [8]]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>numpy.squeeze(a, axis = None) 从数组的形状中删除单维度条目，即把shape中为1的维度去掉。<ul>
<li><code>a</code>表示输入的数组；</li>
<li><code>axis</code>用于指定需要删除的维度，但是指定的维度必须为单维度，否则将会报错；</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.arange(<span class="number">10</span>)</span><br><span class="line">print(x.shape)  <span class="comment"># (10,)</span></span><br><span class="line">x = x[np.newaxis, :]</span><br><span class="line">print(x.shape)  <span class="comment"># (1, 10)</span></span><br><span class="line">y = np.squeeze(x)</span><br><span class="line">print(y.shape)  <span class="comment"># (10,)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[[<span class="number">0</span>], [<span class="number">1</span>], [<span class="number">2</span>]]])</span><br><span class="line">print(x.shape)  <span class="comment"># (1, 3, 1)</span></span><br><span class="line">print(x)</span><br><span class="line"><span class="comment"># [[[0]</span></span><br><span class="line"><span class="comment">#   [1]</span></span><br><span class="line"><span class="comment">#   [2]]]</span></span><br><span class="line"></span><br><span class="line">y = np.squeeze(x)</span><br><span class="line">print(y.shape)  <span class="comment"># (3,)</span></span><br><span class="line">print(y)  <span class="comment"># [0 1 2]</span></span><br><span class="line"></span><br><span class="line">y = np.squeeze(x, axis=<span class="number">0</span>)</span><br><span class="line">print(y.shape)  <span class="comment"># (3, 1)</span></span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [[0]</span></span><br><span class="line"><span class="comment">#  [1]</span></span><br><span class="line"><span class="comment">#  [2]]</span></span><br><span class="line"></span><br><span class="line">y = np.squeeze(x, axis=<span class="number">2</span>)</span><br><span class="line">print(y.shape)  <span class="comment"># (1, 3)</span></span><br><span class="line">print(y)  <span class="comment"># [[0 1 2]]</span></span><br><span class="line"></span><br><span class="line">y = np.squeeze(x, axis=<span class="number">1</span>)<span class="comment">#欲删除的维度不为1，报错。</span></span><br><span class="line"><span class="comment"># ValueError: cannot select an axis to squeeze out which has size not equal to one</span></span><br></pre></td></tr></table></figure>
<h2 id="数组组合"><a href="#数组组合" class="headerlink" title="数组组合"></a>数组组合</h2><p>如果要将两份数据组合到一起，就需要拼接操作。</p>
<ul>
<li>numpy.concatenate((a1, a2, …), axis = 0, out = None) Join a sequence of arrays along an existing axis.</li>
</ul>
<p>例：连接沿现有轴的数组序列（原来x，y都是一维的，拼接后的结果也是一维的）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">y = np.array([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line">z = np.concatenate([x, y])</span><br><span class="line">print(z)</span><br><span class="line"><span class="comment"># [1 2 3 7 8 9]</span></span><br><span class="line"></span><br><span class="line">z = np.concatenate([x, y], axis=<span class="number">0</span>)</span><br><span class="line">print(z)</span><br><span class="line"><span class="comment"># [1 2 3 7 8 9]</span></span><br></pre></td></tr></table></figure>
<p>例：原来x，y都是二维的，拼接后的结果也是二维的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).reshape(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">y = np.array([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]).reshape(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">z = np.concatenate([x, y])</span><br><span class="line">print(z)</span><br><span class="line"><span class="comment"># [[ 1  2  3]</span></span><br><span class="line"><span class="comment">#  [ 7  8  9]]</span></span><br><span class="line">z = np.concatenate([x, y], axis=<span class="number">0</span>)</span><br><span class="line">print(z)</span><br><span class="line"><span class="comment"># [[ 1  2  3]</span></span><br><span class="line"><span class="comment">#  [ 7  8  9]]</span></span><br><span class="line">z = np.concatenate([x, y], axis=<span class="number">1</span>)</span><br><span class="line">print(z)</span><br><span class="line"><span class="comment"># [[ 1  2  3  7  8  9]]</span></span><br></pre></td></tr></table></figure>
<p>例：x，y在原来的维度上进行拼接。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line">y = np.array([[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line">z = np.concatenate([x, y])</span><br><span class="line">print(z)</span><br><span class="line"><span class="comment"># [[ 1  2  3]</span></span><br><span class="line"><span class="comment">#  [ 4  5  6]</span></span><br><span class="line"><span class="comment">#  [ 7  8  9]</span></span><br><span class="line"><span class="comment">#  [10 11 12]]</span></span><br><span class="line">z = np.concatenate([x, y], axis=<span class="number">0</span>)</span><br><span class="line">print(z)</span><br><span class="line"><span class="comment"># [[ 1  2  3]</span></span><br><span class="line"><span class="comment">#  [ 4  5  6]</span></span><br><span class="line"><span class="comment">#  [ 7  8  9]</span></span><br><span class="line"><span class="comment">#  [10 11 12]]</span></span><br><span class="line">z = np.concatenate([x, y], axis=<span class="number">1</span>)</span><br><span class="line">print(z)</span><br><span class="line"><span class="comment"># [[ 1  2  3  7  8  9]</span></span><br><span class="line"><span class="comment">#  [ 4  5  6 10 11 12]]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>numpy.stack(array, axis = 0, out = None) Join a sequence of arrays along a new axis.</li>
</ul>
<p>例：沿着新的轴加入一系列数组（stack为增加维度的拼接）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">y = np.array([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line">z = np.stack([x, y])</span><br><span class="line">print(z.shape)  <span class="comment"># (2, 3)</span></span><br><span class="line">print(z)</span><br><span class="line"><span class="comment"># [[1 2 3]</span></span><br><span class="line"><span class="comment">#  [7 8 9]]</span></span><br><span class="line"></span><br><span class="line">z = np.stack([x, y], axis=<span class="number">1</span>)</span><br><span class="line">print(z.shape)  <span class="comment"># (3, 2)</span></span><br><span class="line">print(z)</span><br><span class="line"><span class="comment"># [[1 7]</span></span><br><span class="line"><span class="comment">#  [2 8]</span></span><br><span class="line"><span class="comment">#  [3 9]]</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>numpy.vstack(tup)</code>Stack arrays in sequence vertically (row wise).</li>
<li><code>numpy.hstack(tup)</code>Stack arrays in sequence horizontally (column wise).</li>
</ul>
<p><code>hstack(),vstack()</code>分别表示水平和竖直的拼接方式。在数据维度等于1时，比较特殊。而当维度大于或等于2时，它们的作用相当于<code>concatenate</code>，用于在已有轴上进行操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.hstack([np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]), <span class="number">5</span>])</span><br><span class="line">print(a)  <span class="comment"># [1 2 3 4 5]</span></span><br><span class="line"></span><br><span class="line">a = np.concatenate([np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]), <span class="number">5</span>])</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># all the input arrays must have same number of dimensions, but the array at index 0 has 1 dimension(s) and the array at index 1 has 0 dimension(s)</span></span><br></pre></td></tr></table></figure>
<h2 id="数组拆分"><a href="#数组拆分" class="headerlink" title="数组拆分"></a>数组拆分</h2><ul>
<li>numpy.split(ary, indices_or_sections, axis = 0) Split an array into multiple sub-arrays as views into ary.</li>
</ul>
<p>例：拆分数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>],</span><br><span class="line">              [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>],</span><br><span class="line">              [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>]])</span><br><span class="line">y = np.split(x, [<span class="number">1</span>, <span class="number">3</span>]) <span class="comment">#[1, 3]表示在第1行和第3行进行拆分</span></span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [array([[11, 12, 13, 14]]), array([[16, 17, 18, 19],</span></span><br><span class="line"><span class="comment">#        [21, 22, 23, 24]]), array([], shape=(0, 4), dtype=int32)]</span></span><br><span class="line"></span><br><span class="line">y = np.split(x, [<span class="number">1</span>, <span class="number">3</span>], axis=<span class="number">1</span>)</span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [array([[11],</span></span><br><span class="line"><span class="comment">#        [16],</span></span><br><span class="line"><span class="comment">#        [21]]), array([[12, 13],</span></span><br><span class="line"><span class="comment">#        [17, 18],</span></span><br><span class="line"><span class="comment">#        [22, 23]]), array([[14],</span></span><br><span class="line"><span class="comment">#        [19],</span></span><br><span class="line"><span class="comment">#        [24]])]</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>numpy.vsplit(ary, indices_or_sections)</code> Split an array into multiple sub-arrays vertically (row-wise).</li>
</ul>
<p>例：水平切分是把数组按照宽度切分。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>],</span><br><span class="line">              [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>],</span><br><span class="line">              [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>]])</span><br><span class="line">y = np.vsplit(x, <span class="number">3</span>)<span class="comment"># 切成三分</span></span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [array([[11, 12, 13, 14]]), array([[16, 17, 18, 19]]), array([[21, 22, 23, 24]])]</span></span><br><span class="line"></span><br><span class="line">y = np.vsplit(x, [<span class="number">1</span>])<span class="comment"># 在下标1处切分</span></span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [array([[11, 12, 13, 14]]), array([[16, 17, 18, 19],</span></span><br><span class="line"><span class="comment">#        [21, 22, 23, 24]])]</span></span><br><span class="line"></span><br><span class="line">y = np.vsplit(x, [<span class="number">1</span>, <span class="number">3</span>])<span class="comment"># 在下标1 3处切分</span></span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [array([[11, 12, 13, 14]]), array([[16, 17, 18, 19],</span></span><br><span class="line"><span class="comment">#        [21, 22, 23, 24]]), array([], shape=(0, 4), dtype=int32)]</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>numpy.hsplit(ary, indices_or_sections)</code> Split an array into multiple sub-arrays horizontally (column-wise).</li>
</ul>
<p>例：垂直切分是把数组按照高度切分</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>],</span><br><span class="line">              [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>],</span><br><span class="line">              [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>]])</span><br><span class="line">y = np.hsplit(x, <span class="number">2</span>)<span class="comment">#切成两份</span></span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [array([[11, 12],</span></span><br><span class="line"><span class="comment">#        [16, 17],</span></span><br><span class="line"><span class="comment">#        [21, 22]]), array([[13, 14],</span></span><br><span class="line"><span class="comment">#        [18, 19],</span></span><br><span class="line"><span class="comment">#        [23, 24]])]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">y = np.hsplit(x, [<span class="number">3</span>])<span class="comment">#在下标3处切分</span></span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [array([[11, 12, 13],</span></span><br><span class="line"><span class="comment">#        [16, 17, 18],</span></span><br><span class="line"><span class="comment">#        [21, 22, 23]]), array([[14],</span></span><br><span class="line"><span class="comment">#        [19],</span></span><br><span class="line"><span class="comment">#        [24]])]</span></span><br><span class="line"></span><br><span class="line">y = np.hsplit(x, [<span class="number">1</span>, <span class="number">3</span>])<span class="comment">#在下标1 3处切分</span></span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [array([[11],</span></span><br><span class="line"><span class="comment">#        [16],</span></span><br><span class="line"><span class="comment">#        [21]]), array([[12, 13],</span></span><br><span class="line"><span class="comment">#        [17, 18],</span></span><br><span class="line"><span class="comment">#        [22, 23]]), array([[14],</span></span><br><span class="line"><span class="comment">#        [19],</span></span><br><span class="line"><span class="comment">#        [24]])]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="数组平铺"><a href="#数组平铺" class="headerlink" title="数组平铺"></a>数组平铺</h2><ul>
<li><code>numpy.tile(A, reps)</code> Construct an array by repeating A the number of times given by reps.</li>
</ul>
<p><code>tile</code>是瓷砖的意思，顾名思义，这个函数就是把数组像瓷砖一样铺展开来。</p>
<p>例：将原矩阵横向、纵向地复制。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line">print(x)</span><br><span class="line"><span class="comment"># [[1 2]</span></span><br><span class="line"><span class="comment">#  [3 4]]</span></span><br><span class="line"></span><br><span class="line">y = np.tile(x, (<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [[1 2 1 2 1 2]</span></span><br><span class="line"><span class="comment">#  [3 4 3 4 3 4]]</span></span><br><span class="line"></span><br><span class="line">y = np.tile(x, (<span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [[1 2]</span></span><br><span class="line"><span class="comment">#  [3 4]</span></span><br><span class="line"><span class="comment">#  [1 2]</span></span><br><span class="line"><span class="comment">#  [3 4]</span></span><br><span class="line"><span class="comment">#  [1 2]</span></span><br><span class="line"><span class="comment">#  [3 4]]</span></span><br><span class="line"></span><br><span class="line">y = np.tile(x, (<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [[1 2 1 2 1 2]</span></span><br><span class="line"><span class="comment">#  [3 4 3 4 3 4]</span></span><br><span class="line"><span class="comment">#  [1 2 1 2 1 2]</span></span><br><span class="line"><span class="comment">#  [3 4 3 4 3 4]</span></span><br><span class="line"><span class="comment">#  [1 2 1 2 1 2]</span></span><br><span class="line"><span class="comment">#  [3 4 3 4 3 4]]</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>numpy.repeat(a, repeats, axis=None)</code> Repeat elements of an array.<ul>
<li><code>axis=0</code>，沿着y轴复制，实际上增加了行数。</li>
<li><code>axis=1</code>，沿着x轴复制，实际上增加了列数。</li>
<li><code>repeats</code>，可以为一个数，也可以为一个矩阵。</li>
<li><code>axis=None</code>时就会flatten当前矩阵，实际上就是变成了一个行向量。</li>
</ul>
</li>
</ul>
<p>例：重复数组的元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.repeat(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">print(x)  <span class="comment"># [3 3 3 3]</span></span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line">y = np.repeat(x, <span class="number">2</span>)</span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [1 1 2 2 3 3 4 4]</span></span><br><span class="line"></span><br><span class="line">y = np.repeat(x, <span class="number">2</span>, axis=<span class="number">0</span>)</span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [[1 2]</span></span><br><span class="line"><span class="comment">#  [1 2]</span></span><br><span class="line"><span class="comment">#  [3 4]</span></span><br><span class="line"><span class="comment">#  [3 4]]</span></span><br><span class="line"></span><br><span class="line">y = np.repeat(x, <span class="number">2</span>, axis=<span class="number">1</span>)</span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [[1 1 2 2]</span></span><br><span class="line"><span class="comment">#  [3 3 4 4]]</span></span><br><span class="line"></span><br><span class="line">y = np.repeat(x, [<span class="number">2</span>, <span class="number">3</span>], axis=<span class="number">0</span>)</span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [[1 2]</span></span><br><span class="line"><span class="comment">#  [1 2]</span></span><br><span class="line"><span class="comment">#  [3 4]</span></span><br><span class="line"><span class="comment">#  [3 4]</span></span><br><span class="line"><span class="comment">#  [3 4]]</span></span><br><span class="line"></span><br><span class="line">y = np.repeat(x, [<span class="number">2</span>, <span class="number">3</span>], axis=<span class="number">1</span>)</span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [[1 1 2 2 2]</span></span><br><span class="line"><span class="comment">#  [3 3 4 4 4]]</span></span><br></pre></td></tr></table></figure>
<h2 id="添加和删除元素"><a href="#添加和删除元素" class="headerlink" title="添加和删除元素"></a>添加和删除元素</h2><ul>
<li><code>numpy.unique(ar, return_index=False, return_inverse=False,return_counts=False, axis=None)</code> Find the unique elements of an array<ul>
<li>return_index：the indices of the input array that give the unique values</li>
<li>return_inverse：the indices of the unique array that reconstruct the input array</li>
<li>return_counts：the number of times each unique value comes up in the input array</li>
</ul>
</li>
</ul>
<p>例：查找数组的唯一元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=np.array([<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>])</span><br><span class="line">b=np.unique(a,return_counts=<span class="literal">True</span>)</span><br><span class="line">print(b[<span class="number">0</span>][<span class="built_in">list</span>(b[<span class="number">1</span>]).index(<span class="number">1</span>)])</span><br><span class="line"><span class="comment">#2</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/05/Data%20_Competition/Numpy_Practice/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/05/Data%20_Competition/Numpy_Practice/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%B4%A2%E5%BC%95/" class="post-title-link" itemprop="url">第二章 索引</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-07-05 21:33:50 / 修改时间：21:35:03" itemprop="dateCreated datePublished" datetime="2021-07-05T21:33:50+08:00">2021-07-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">数据竞赛</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B/Numpy%E5%AE%9E%E8%B7%B5/" itemprop="url" rel="index"><span itemprop="name">Numpy实践</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/07/05/Data%20_Competition/Numpy_Practice/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%B4%A2%E5%BC%95/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/07/05/Data%20_Competition/Numpy_Practice/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%B4%A2%E5%BC%95/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="副本与视图"><a href="#副本与视图" class="headerlink" title="副本与视图"></a>副本与视图</h1><p>在Numpy中，尤其是在做数组运算或数组操作时，返回结果不是数组的<strong>副本</strong>就是<strong>视图</strong>。</p>
<p>在Numpy中，所有赋值运算不会为数组和数组中的任何元素创建副本。</p>
<ul>
<li><p><code>numpy.ndarray.copy()</code> 函数创建一个副本。 对副本数据进行修改，不会影响到原始数据，它们物理内存不在同一位置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line">y = x</span><br><span class="line">y[<span class="number">0</span>] = -<span class="number">1</span></span><br><span class="line">print(x)</span><br><span class="line"><span class="comment"># [-1  2  3  4  5  6  7  8]</span></span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [-1  2  3  4  5  6  7  8]</span></span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line">y = x.copy()</span><br><span class="line">y[<span class="number">0</span>] = -<span class="number">1</span></span><br><span class="line">print(x)</span><br><span class="line"><span class="comment"># [1 2 3 4 5 6 7 8]</span></span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [-1  2  3  4  5  6  7  8]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="索引与切片"><a href="#索引与切片" class="headerlink" title="索引与切片"></a>索引与切片</h1><p>数组索引机制指的是用方括号（[]）加序号的形式引用单个数组元素，它的用处很多，比如抽取元素，选取数组的几个元素，甚至为其赋一个新值。</p>
<h2 id="整数索引"><a href="#整数索引" class="headerlink" title="整数索引"></a>整数索引</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line">print(x[<span class="number">2</span>])  <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">              [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>],</span><br><span class="line">              [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>],</span><br><span class="line">              [<span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>],</span><br><span class="line">              [<span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>]])</span><br><span class="line">print(x[<span class="number">2</span>])  <span class="comment"># [21 22 23 24 25]</span></span><br><span class="line">print(x[<span class="number">2</span>][<span class="number">1</span>])  <span class="comment"># 22</span></span><br><span class="line">print(x[<span class="number">2</span>, <span class="number">1</span>])  <span class="comment"># 22</span></span><br></pre></td></tr></table></figure>
<h2 id="切片索引"><a href="#切片索引" class="headerlink" title="切片索引"></a>切片索引</h2><p>切片操作是指抽取数组的一部分元素生成新数组。对 python <strong>列表</strong>进行切片操作得到的数组是原数组的<strong>副本</strong>，而对 <strong>Numpy</strong> 数据进行切片操作得到的数组则是指向相同缓冲区的<strong>视图</strong>。</p>
<p>如果想抽取（或查看）数组的一部分，必须使用切片语法，也就是，把几个用冒号（ <code>start:stop:step</code> ）隔开的数字置于方括号内。</p>
<p>为了更好地理解切片语法，还应该了解不明确指明起始和结束位置的情况。如省去第一个数字，numpy 会认为第一个数字是0；如省去第二个数字，numpy 则会认为第二个数字是数组的最大索引值；如省去最后一个数字，它将会被理解为1，也就是抽取所有元素而不再考虑间隔。</p>
<p>通过对每个以逗号分隔的维度执行单独的切片，你可以对多维数组进行切片。因此，对于二维数组，我们的第一片定义了行的切片，第二片定义了列的切片。</p>
<h2 id="dots索引"><a href="#dots索引" class="headerlink" title="dots索引"></a>dots索引</h2><h1 id="副本与视图-1"><a href="#副本与视图-1" class="headerlink" title="副本与视图"></a>副本与视图</h1><p>在 Numpy 中，尤其是在做数组运算或数组操作时，返回结果不是数组的 <strong>副本</strong> 就是 <strong>视图</strong>。</p>
<p>在 Numpy 中，所有赋值运算不会为数组和数组中的任何元素创建副本。</p>
<ul>
<li><code>numpy.ndarray.copy()</code> 函数创建一个副本。 对副本数据进行修改，不会影响到原始数据，它们物理内存不在同一位置。</li>
</ul>
<p>【例】</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line">y = x</span><br><span class="line">y[<span class="number">0</span>] = -<span class="number">1</span></span><br><span class="line">print(x)</span><br><span class="line"><span class="comment"># [-1  2  3  4  5  6  7  8]</span></span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [-1  2  3  4  5  6  7  8]</span></span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line">y = x.copy()</span><br><span class="line">y[<span class="number">0</span>] = -<span class="number">1</span></span><br><span class="line">print(x)</span><br><span class="line"><span class="comment"># [1 2 3 4 5 6 7 8]</span></span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [-1  2  3  4  5  6  7  8]</span></span><br></pre></td></tr></table></figure>
<p>【例】数组切片操作返回的对象只是原数组的视图。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">              [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>],</span><br><span class="line">              [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>],</span><br><span class="line">              [<span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>],</span><br><span class="line">              [<span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>]])</span><br><span class="line">y = x</span><br><span class="line">y[::<span class="number">2</span>, :<span class="number">3</span>:<span class="number">2</span>] = -<span class="number">1</span></span><br><span class="line">print(x)</span><br><span class="line"><span class="comment"># [[-1 12 -1 14 15]</span></span><br><span class="line"><span class="comment">#  [16 17 18 19 20]</span></span><br><span class="line"><span class="comment">#  [-1 22 -1 24 25]</span></span><br><span class="line"><span class="comment">#  [26 27 28 29 30]</span></span><br><span class="line"><span class="comment">#  [-1 32 -1 34 35]]</span></span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [[-1 12 -1 14 15]</span></span><br><span class="line"><span class="comment">#  [16 17 18 19 20]</span></span><br><span class="line"><span class="comment">#  [-1 22 -1 24 25]</span></span><br><span class="line"><span class="comment">#  [26 27 28 29 30]</span></span><br><span class="line"><span class="comment">#  [-1 32 -1 34 35]]</span></span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">              [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>],</span><br><span class="line">              [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>],</span><br><span class="line">              [<span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>],</span><br><span class="line">              [<span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>]])</span><br><span class="line">y = x.copy()</span><br><span class="line">y[::<span class="number">2</span>, :<span class="number">3</span>:<span class="number">2</span>] = -<span class="number">1</span></span><br><span class="line">print(x)</span><br><span class="line"><span class="comment"># [[11 12 13 14 15]</span></span><br><span class="line"><span class="comment">#  [16 17 18 19 20]</span></span><br><span class="line"><span class="comment">#  [21 22 23 24 25]</span></span><br><span class="line"><span class="comment">#  [26 27 28 29 30]</span></span><br><span class="line"><span class="comment">#  [31 32 33 34 35]]</span></span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [[-1 12 -1 14 15]</span></span><br><span class="line"><span class="comment">#  [16 17 18 19 20]</span></span><br><span class="line"><span class="comment">#  [-1 22 -1 24 25]</span></span><br><span class="line"><span class="comment">#  [26 27 28 29 30]</span></span><br><span class="line"><span class="comment">#  [-1 32 -1 34 35]]</span></span><br></pre></td></tr></table></figure>
<h1 id="索引与切片-1"><a href="#索引与切片-1" class="headerlink" title="索引与切片"></a>索引与切片</h1><p>数组索引机制指的是用方括号（[]）加序号的形式引用单个数组元素，它的用处很多，比如抽取元素，选取数组的几个元素，甚至为其赋一个新值。</p>
<h2 id="整数索引-1"><a href="#整数索引-1" class="headerlink" title="整数索引"></a>整数索引</h2><p>【例】要获取数组的单个元素，指定元素的索引即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line">print(x[<span class="number">2</span>])  <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">              [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>],</span><br><span class="line">              [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>],</span><br><span class="line">              [<span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>],</span><br><span class="line">              [<span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>]])</span><br><span class="line">print(x[<span class="number">2</span>])  <span class="comment"># [21 22 23 24 25]</span></span><br><span class="line">print(x[<span class="number">2</span>][<span class="number">1</span>])  <span class="comment"># 22</span></span><br><span class="line">print(x[<span class="number">2</span>, <span class="number">1</span>])  <span class="comment"># 22</span></span><br></pre></td></tr></table></figure>
<h2 id="切片索引-1"><a href="#切片索引-1" class="headerlink" title="切片索引"></a>切片索引</h2><p>切片操作是指抽取数组的一部分元素生成新数组。对 python <strong>列表</strong>进行切片操作得到的数组是原数组的<strong>副本</strong>，而对 <strong>Numpy</strong> 数据进行切片操作得到的数组则是指向相同缓冲区的<strong>视图</strong>。</p>
<p>如果想抽取（或查看）数组的一部分，必须使用切片语法，也就是，把几个用冒号（ <code>start:stop:step</code> ）隔开的数字置于方括号内。</p>
<p>为了更好地理解切片语法，还应该了解不明确指明起始和结束位置的情况。如省去第一个数字，numpy 会认为第一个数字是0；如省去第二个数字，numpy 则会认为第二个数字是数组的最大索引值；如省去最后一个数字，它将会被理解为1，也就是抽取所有元素而不再考虑间隔。</p>
<p>通过对每个以逗号分隔的维度执行单独的切片，你可以对多维数组进行切片。因此，对于二维数组，我们的第一片定义了行的切片，第二片定义了列的切片。</p>
<h2 id="dots-索引"><a href="#dots-索引" class="headerlink" title="dots 索引"></a>dots 索引</h2><p>NumPy 允许使用<code>...</code>表示足够多的冒号来构建完整的索引列表。</p>
<p>比如，如果 <code>x</code> 是 5 维数组：</p>
<ul>
<li><code>x[1,2,...]</code> 等于 <code>x[1,2,:,:,:]</code></li>
<li><code>x[...,3]</code> 等于 <code>x[:,:,:,:,3]</code></li>
<li><code>x[4,...,5,:]</code> 等于 <code>x[4,:,:,5,:]</code></li>
</ul>
<h2 id="整数数组索引"><a href="#整数数组索引" class="headerlink" title="整数数组索引"></a>整数数组索引</h2><p>方括号内传入多个索引值，可以同时选择多个元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line">r = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">print(x[r])</span><br><span class="line"><span class="comment"># [1 2 3]</span></span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">              [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>],</span><br><span class="line">              [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>],</span><br><span class="line">              [<span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>],</span><br><span class="line">              [<span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>]])</span><br><span class="line">r = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">c = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">y = x[r, c]</span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [13 19 25]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line">r = np.array([[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line">print(x[r])</span><br><span class="line"><span class="comment"># [[1 2]</span></span><br><span class="line"><span class="comment">#  [4 5]]</span></span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">              [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>],</span><br><span class="line">              [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>],</span><br><span class="line">              [<span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>],</span><br><span class="line">              [<span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>]])</span><br><span class="line"></span><br><span class="line">r = np.array([[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line">print(x[r])</span><br><span class="line"><span class="comment"># [[[11 12 13 14 15]</span></span><br><span class="line"><span class="comment">#   [16 17 18 19 20]]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  [[26 27 28 29 30]</span></span><br><span class="line"><span class="comment">#   [31 32 33 34 35]]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取了 5X5 数组中的四个角的元素。</span></span><br><span class="line"><span class="comment"># 行索引是 [0,0] 和 [4,4]，而列索引是 [0,4] 和 [0,4]。</span></span><br><span class="line">r = np.array([[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">4</span>, <span class="number">4</span>]])</span><br><span class="line">c = np.array([[<span class="number">0</span>, <span class="number">4</span>], [<span class="number">0</span>, <span class="number">4</span>]])</span><br><span class="line">y = x[r, c]</span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [[11 15]</span></span><br><span class="line"><span class="comment">#  [31 35]]</span></span><br></pre></td></tr></table></figure>
<p>【例】可以借助切片<code>:</code>与整数数组组合。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">              [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>],</span><br><span class="line">              [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>],</span><br><span class="line">              [<span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>],</span><br><span class="line">              [<span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>]])</span><br><span class="line"></span><br><span class="line">y = x[<span class="number">0</span>:<span class="number">3</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>]]</span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [[12 13 13]</span></span><br><span class="line"><span class="comment">#  [17 18 18]</span></span><br><span class="line"><span class="comment">#  [22 23 23]]</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>numpy. take(a, indices, axis=None, out=None, mode=&#39;raise&#39;)</code> Take elements from an array along an axis.</li>
</ul>
<p>应注意：使用切片索引到numpy数组时，生成的数组视图将始终是原始数组的子数组, 但是整数数组索引，不是其子数组，是形成新的数组。 切片索引</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a=np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">b=a[<span class="number">0</span>:<span class="number">1</span>,<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line">b[<span class="number">0</span>,<span class="number">0</span>]=<span class="number">2</span></span><br><span class="line">print(a[<span class="number">0</span>,<span class="number">0</span>]==b)</span><br><span class="line"><span class="comment">#[[True]]</span></span><br></pre></td></tr></table></figure>
<p>整数数组索引</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a=np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">b=a[<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">b=<span class="number">2</span></span><br><span class="line">print(a[<span class="number">0</span>,<span class="number">0</span>]==b)</span><br><span class="line"><span class="comment">#False</span></span><br></pre></td></tr></table></figure>
<h2 id="布尔索引"><a href="#布尔索引" class="headerlink" title="布尔索引"></a>布尔索引</h2><p>我们可以通过一个布尔数组来索引目标数组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line">y = x &gt; <span class="number">5</span></span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [False False False False False  True  True  True]</span></span><br><span class="line">print(x[x &gt; <span class="number">5</span>])</span><br><span class="line"><span class="comment"># [6 7 8]</span></span><br><span class="line"></span><br><span class="line">x = np.array([np.nan, <span class="number">1</span>, <span class="number">2</span>, np.nan, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">y = np.logical_not(np.isnan(x))</span><br><span class="line">print(x[y])</span><br><span class="line"><span class="comment"># [1. 2. 3. 4. 5.]</span></span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">              [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>],</span><br><span class="line">              [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>],</span><br><span class="line">              [<span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>],</span><br><span class="line">              [<span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>]])</span><br><span class="line">y = x &gt; <span class="number">25</span></span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [[False False False False False]</span></span><br><span class="line"><span class="comment">#  [False False False False False]</span></span><br><span class="line"><span class="comment">#  [False False False False False]</span></span><br><span class="line"><span class="comment">#  [ True  True  True  True  True]</span></span><br><span class="line"><span class="comment">#  [ True  True  True  True  True]]</span></span><br><span class="line">print(x[x &gt; <span class="number">25</span>])</span><br><span class="line"><span class="comment"># [26 27 28 29 30 31 32 33 34 35]</span></span><br></pre></td></tr></table></figure>
<h1 id="数组迭代"><a href="#数组迭代" class="headerlink" title="数组迭代"></a>数组迭代</h1><p>除了for循环，Numpy 还提供另外一种更为优雅的遍历方法。</p>
<ul>
<li><p><code>apply_along_axis(func1d, axis, arr)</code> Apply a function to 1-D slices along the given axis。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">              [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>],</span><br><span class="line">              [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>],</span><br><span class="line">              [<span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>],</span><br><span class="line">              [<span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>]])</span><br><span class="line"></span><br><span class="line">y = np.apply_along_axis(np.<span class="built_in">sum</span>, <span class="number">0</span>, x)</span><br><span class="line">print(y)  <span class="comment"># [105 110 115 120 125]</span></span><br><span class="line">y = np.apply_along_axis(np.<span class="built_in">sum</span>, <span class="number">1</span>, x)</span><br><span class="line">print(y)  <span class="comment"># [ 65  90 115 140 165]</span></span><br><span class="line"></span><br><span class="line">y = np.apply_along_axis(np.mean, <span class="number">0</span>, x)</span><br><span class="line">print(y)  <span class="comment"># [21. 22. 23. 24. 25.]</span></span><br><span class="line">y = np.apply_along_axis(np.mean, <span class="number">1</span>, x)</span><br><span class="line">print(y)  <span class="comment"># [13. 18. 23. 28. 33.]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (x[<span class="number">0</span>] + x[-<span class="number">1</span>]) * <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">y = np.apply_along_axis(my_func, <span class="number">0</span>, x)</span><br><span class="line">print(y)  <span class="comment"># [21. 22. 23. 24. 25.]</span></span><br><span class="line">y = np.apply_along_axis(my_func, <span class="number">1</span>, x)</span><br><span class="line">print(y)  <span class="comment"># [13. 18. 23. 28. 33.]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/02/Film_And_TV_Series/Films/%E7%94%B5%E5%BD%B1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/02/Film_And_TV_Series/Films/%E7%94%B5%E5%BD%B1/" class="post-title-link" itemprop="url">电影推荐</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-07-02 21:53:48 / 修改时间：22:03:04" itemprop="dateCreated datePublished" datetime="2021-07-02T21:53:48+08:00">2021-07-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%94%B5%E5%BD%B1%E7%94%B5%E8%A7%86%E5%89%A7/" itemprop="url" rel="index"><span itemprop="name">电影电视剧</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%94%B5%E5%BD%B1%E7%94%B5%E8%A7%86%E5%89%A7/%E7%94%B5%E5%BD%B1/" itemprop="url" rel="index"><span itemprop="name">电影</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/07/02/Film_And_TV_Series/Films/%E7%94%B5%E5%BD%B1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/07/02/Film_And_TV_Series/Films/%E7%94%B5%E5%BD%B1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>此博客中推荐的电影电视剧本人均已看过多次并且觉得不错。所有电影电视剧均为个人喜好方向。如有不同见解欢迎留言讨论。</strong></p>
<h1 id="电影推荐："><a href="#电影推荐：" class="headerlink" title="电影推荐："></a>电影推荐：</h1><h2 id="Comedies-喜剧"><a href="#Comedies-喜剧" class="headerlink" title="Comedies 喜剧"></a>Comedies 喜剧</h2><h2 id="Drama-剧情"><a href="#Drama-剧情" class="headerlink" title="Drama 剧情"></a>Drama 剧情</h2><ul>
<li><strong>《肖申克的救赎》</strong></li>
<li><strong>《绿皮书》</strong></li>
<li><strong>《阿甘正传》</strong></li>
<li><strong>《小丑2019》</strong></li>
<li><strong>《魔鬼代言人》</strong></li>
<li><strong>《被解救的姜戈》</strong></li>
<li><strong>《摔跤吧！爸爸》</strong></li>
<li><strong>《荒蛮故事》</strong></li>
<li><strong>《完美陌生人》</strong></li>
<li><strong>《荒野猎人》</strong></li>
<li><strong>《无耻混蛋》</strong></li>
</ul>
<h2 id="Family-家庭"><a href="#Family-家庭" class="headerlink" title="Family 家庭"></a>Family 家庭</h2><h2 id="Animation-动画"><a href="#Animation-动画" class="headerlink" title="Animation 动画"></a>Animation 动画</h2><ul>
<li><strong>《玩具总动员》</strong></li>
</ul>
<h2 id="Romance-浪漫"><a href="#Romance-浪漫" class="headerlink" title="Romance 浪漫"></a>Romance 浪漫</h2><ul>
<li><strong>《泰坦尼克号》</strong></li>
<li><strong>《怦然心动》</strong></li>
<li><strong>《时空恋旅人》</strong></li>
<li><strong>《爱在三部曲》-《爱在黎明破晓前》《爱在日落黄昏时》《爱在午夜降临前》</strong></li>
<li><strong>《真爱至上》</strong></li>
<li><strong>《间谍同盟》</strong></li>
<li><strong>《史密斯夫妇》</strong></li>
<li><strong>《革命之路》</strong></li>
</ul>
<h2 id="Action-动作"><a href="#Action-动作" class="headerlink" title="Action 动作"></a>Action 动作</h2><h2 id="Fantasy-幻想"><a href="#Fantasy-幻想" class="headerlink" title="Fantasy 幻想"></a>Fantasy 幻想</h2><ul>
<li><strong>《盗梦空间》</strong></li>
<li><strong>《信条》</strong></li>
<li><strong>《水形物语》</strong></li>
<li><strong>《蝴蝶效应》</strong></li>
<li><strong>《这个男人来自地球》</strong></li>
<li><strong>《记忆碎片》</strong></li>
<li><strong>《绿里奇迹》</strong></li>
<li><strong>《返老还童》又名《本杰明·巴顿奇事》</strong></li>
<li><strong>《搏击俱乐部》</strong></li>
<li><strong>《时间旅行者的妻子》</strong></li>
<li><strong>《禁闭岛》</strong></li>
<li><strong>《致命魔术》</strong></li>
</ul>
<h2 id="Adventure-冒险"><a href="#Adventure-冒险" class="headerlink" title="Adventure 冒险"></a>Adventure 冒险</h2><ul>
<li><strong>《饥饿游戏1-3》</strong></li>
</ul>
<h2 id="Sci-Fi-科幻"><a href="#Sci-Fi-科幻" class="headerlink" title="Sci-Fi 科幻"></a>Sci-Fi 科幻</h2><ul>
<li><p><strong>《星际穿越》</strong></p>
</li>
<li><p><strong>《火星救援》</strong></p>
</li>
<li><p><strong>《彗星来的那一夜》</strong></p>
</li>
<li><p><strong>《黑客帝国1-3》</strong></p>
</li>
<li><p><strong>《猩球崛起1-3》</strong></p>
</li>
<li><p><strong>《太空旅客》</strong></p>
</li>
<li><p><strong>《侏罗纪公园1-3》</strong></p>
</li>
<li><p><strong>《侏罗纪世界1-2》</strong></p>
</li>
<li><p><strong>《攻壳机动队》</strong></p>
</li>
<li><p><strong>《超体》</strong></p>
</li>
<li><p><strong>《AI人工智能》</strong></p>
</li>
</ul>
<h2 id="Crime-犯罪"><a href="#Crime-犯罪" class="headerlink" title="Crime 犯罪"></a>Crime 犯罪</h2><ul>
<li><strong>《教父1-3》</strong></li>
<li><strong>《蝙蝠侠》-诺兰版三部曲</strong></li>
<li><strong>《七宗罪》</strong></li>
<li><strong>《速度与激情1-8》</strong> </li>
<li><p><strong>《金蝉脱壳》</strong></p>
</li>
<li><p><strong>《利刃出鞘》</strong></p>
</li>
<li><strong>《惊天魔盗团1-3》</strong></li>
<li><strong>《法官老爹》</strong></li>
<li><strong>《撞车》</strong></li>
<li><strong>《火柴人》</strong></li>
<li><strong>《老无所依》</strong></li>
<li><strong>《会计刺客》</strong></li>
<li><strong>《分裂》</strong></li>
<li><strong>《生死狙击》</strong></li>
<li><strong>《玩命快递》</strong></li>
<li><strong>《极限特工1-2》</strong></li>
<li><strong>《十二宫》</strong></li>
<li><strong>《谍影重重1-5》</strong></li>
<li><strong>《寄生虫》</strong></li>
</ul>
<h2 id="Musicals-音乐"><a href="#Musicals-音乐" class="headerlink" title="Musicals 音乐"></a>Musicals 音乐</h2><ul>
<li><strong>《再次出发》</strong></li>
<li><strong>《爱乐之城》</strong></li>
</ul>
<h2 id="Horror-恐怖"><a href="#Horror-恐怖" class="headerlink" title="Horror 恐怖"></a>Horror 恐怖</h2><h2 id="Thrillers-惊悚"><a href="#Thrillers-惊悚" class="headerlink" title="Thrillers 惊悚"></a>Thrillers 惊悚</h2><h2 id="Documentaries-纪录片"><a href="#Documentaries-纪录片" class="headerlink" title="Documentaries 纪录片"></a>Documentaries 纪录片</h2><h2 id="War-战争"><a href="#War-战争" class="headerlink" title="War 战争"></a>War 战争</h2><ul>
<li><strong>《1917》</strong></li>
<li><strong>《黑鹰坠落》</strong></li>
<li><strong>《拯救大兵瑞恩》</strong></li>
<li><strong>《决战中途岛》</strong></li>
</ul>
<h2 id="History-历史"><a href="#History-历史" class="headerlink" title="History 历史"></a>History 历史</h2><h2 id="Biographies-传记"><a href="#Biographies-传记" class="headerlink" title="Biographies 传记"></a>Biographies 传记</h2><ul>
<li><strong>《模仿游戏》</strong></li>
<li><strong>《猫鼠游戏》</strong></li>
<li><strong>《飞行家》</strong></li>
<li><strong>《美丽心灵》</strong></li>
<li><strong>《社交网络》</strong></li>
<li><strong>《达拉斯买家俱乐部》</strong></li>
<li><strong>《天才捕手》</strong></li>
<li><p><strong>《波西米亚狂想曲》</strong></p>
</li>
<li><p><strong>《为奴十二年》</strong></p>
</li>
<li><p><strong>《八英里》</strong></p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/02/Data%20_Competition/Numpy_Practice/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/02/Data%20_Competition/Numpy_Practice/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BA/" class="post-title-link" itemprop="url">第一章 数据类型及数组创建</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-07-02 21:43:59 / 修改时间：22:02:03" itemprop="dateCreated datePublished" datetime="2021-07-02T21:43:59+08:00">2021-07-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">数据竞赛</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B/Numpy%E5%AE%9E%E8%B7%B5/" itemprop="url" rel="index"><span itemprop="name">Numpy实践</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/07/02/Data%20_Competition/Numpy_Practice/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BA/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/07/02/Data%20_Competition/Numpy_Practice/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BA/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><h2 id="numpy-nan"><a href="#numpy-nan" class="headerlink" title="numpy.nan"></a>numpy.nan</h2><ul>
<li>表示空值。</li>
</ul>
<p>nan = NaN = NAN</p>
<p>两个numpy.nan是不相等的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">print(np.nan == np.nan) <span class="comment">#False</span></span><br></pre></td></tr></table></figure>
<ul>
<li>numpy.isnan(x, <em>args, *</em>kwargs)</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, nan, <span class="number">4</span>])</span><br><span class="line">print(x) <span class="comment">#[1, 2, nan, 4]</span></span><br><span class="line"></span><br><span class="line">y = np.isnan(x)</span><br><span class="line">print(y) <span class="comment">#[False False False  True False]</span></span><br><span class="line"></span><br><span class="line">z = np.cout_nonzero(y) </span><br><span class="line">print(z) <span class="comment"># 1 True == 1, False == 0 </span></span><br></pre></td></tr></table></figure>
<h2 id="numpy-inf"><a href="#numpy-inf" class="headerlink" title="numpy.inf"></a>numpy.inf</h2><ul>
<li>表示正无穷大。</li>
</ul>
<p>Inf = inf = infty = Infinity = PINF</p>
<h2 id="numpy-pi"><a href="#numpy-pi" class="headerlink" title="numpy.pi"></a>numpy.pi</h2><ul>
<li>表示圆周率</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pi = <span class="number">3.1415926535897932384626433</span>...</span><br></pre></td></tr></table></figure>
<h2 id="numpy-e"><a href="#numpy-e" class="headerlink" title="numpy.e"></a>numpy.e</h2><ul>
<li>表示自然常数</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e = <span class="number">2.71828182845904523536028747135266249775724709369995</span>...</span><br></pre></td></tr></table></figure>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="常见数据类型"><a href="#常见数据类型" class="headerlink" title="常见数据类型"></a>常见数据类型</h2><div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>备注</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>bool_ = bool8</td>
<td>8位</td>
<td>布尔类型</td>
</tr>
<tr>
<td>int8 = byte</td>
<td>8位</td>
<td>整型</td>
</tr>
<tr>
<td>int16 = short</td>
<td>16位</td>
<td>整型</td>
</tr>
<tr>
<td>int32 = intc</td>
<td>32位</td>
<td>整型</td>
</tr>
<tr>
<td>int_ = int64 = long = int0 = intp</td>
<td>64位</td>
<td>整型</td>
</tr>
<tr>
<td>uint8 = ubyte</td>
<td>8位</td>
<td>无符号整型</td>
</tr>
<tr>
<td>uint16 = ushort</td>
<td>16位</td>
<td>无符号整型</td>
</tr>
<tr>
<td>uint32 = uintc</td>
<td>32位</td>
<td>无符号整型</td>
</tr>
<tr>
<td>uint64 = uintp = uint0 = uint</td>
<td>64位</td>
<td>无符号整型</td>
</tr>
<tr>
<td>float16 = half</td>
<td>16位</td>
<td>浮点型</td>
</tr>
<tr>
<td>float32 = single</td>
<td>32位</td>
<td>浮点型</td>
</tr>
<tr>
<td>float_ = float64 = double</td>
<td>64位</td>
<td>浮点型</td>
</tr>
<tr>
<td>str_ = unicode_ = str0 = unicode</td>
<td>\</td>
<td>Unicode 字符串</td>
<td></td>
</tr>
<tr>
<td>datetime64</td>
<td>\</td>
<td>日期时间类型</td>
<td></td>
</tr>
<tr>
<td>timedelta64</td>
<td>\</td>
<td>表示两个时间之间的间隔</td>
</tr>
</tbody>
</table>
</div>
<h2 id="创建数据类型"><a href="#创建数据类型" class="headerlink" title="创建数据类型"></a>创建数据类型</h2><p>numpy的数值类型实际上是dtype对象的实例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dtype</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, obj, align=<span class="literal">False</span>, copy=<span class="literal">False</span></span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>每个内建类型都有一个唯一定义它的字符代码，如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字符</th>
<th>对应类型</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>b</td>
<td>boolean</td>
<td>‘b1’</td>
</tr>
<tr>
<td>i</td>
<td>signed integer</td>
<td>‘i1’, ‘i2’, ‘i4’, ‘i8’</td>
</tr>
<tr>
<td>u</td>
<td>unsigned integer</td>
<td>‘u1’, ‘u2’ ,’u4’ ,’u8’</td>
</tr>
<tr>
<td>f</td>
<td>floating-point</td>
<td>‘f2’, ‘f4’, ‘f8’</td>
</tr>
<tr>
<td>c</td>
<td>complex floating-point</td>
<td></td>
</tr>
<tr>
<td>m</td>
<td>timedelta64</td>
<td>表示两个时间之间的间隔</td>
</tr>
<tr>
<td>M</td>
<td>datetime64</td>
<td>日期时间类型</td>
</tr>
<tr>
<td>O</td>
<td>object</td>
<td></td>
</tr>
<tr>
<td>S</td>
<td>(byte-)string</td>
<td>S3表示长度为3的字符串</td>
</tr>
<tr>
<td>U</td>
<td>Unicode</td>
<td>Unicode 字符串</td>
</tr>
<tr>
<td>V</td>
<td>void</td>
</tr>
</tbody>
</table>
</div>
<p>例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.dtype(<span class="string">&#x27;b1&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="数据类型信息"><a href="#数据类型信息" class="headerlink" title="数据类型信息"></a>数据类型信息</h2><p>Python 的浮点数通常是64位浮点数，几乎等同于 <code>np.float64</code>。</p>
<p>NumPy和Python整数类型的行为在整数溢出方面存在显着差异，与 NumPy 不同，Python 的<code>int</code> 是灵活的。这意味着Python整数可以扩展以容纳任何整数并且不会溢出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">iinfo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, int_type</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">max</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">finfo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_init</span>(<span class="params">self, dtype</span>):</span></span><br></pre></td></tr></table></figure>
<h1 id="时间日期和时间增量"><a href="#时间日期和时间增量" class="headerlink" title="时间日期和时间增量"></a>时间日期和时间增量</h1><h2 id="datetime64基础"><a href="#datetime64基础" class="headerlink" title="datetime64基础"></a>datetime64基础</h2><p>在 numpy 中，我们很方便的将字符串转换成时间日期类型 <code>datetime64</code>（<code>datetime</code> 已被 python 包含的日期时间库所占用）。</p>
<p><code>datatime64</code>是带单位的日期时间类型，其单位如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>日期单位</th>
<th>代码含义</th>
<th>时间单位</th>
<th>代码含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Y</td>
<td>年</td>
<td>h</td>
<td>小时</td>
</tr>
<tr>
<td>M</td>
<td>月</td>
<td>m</td>
<td>分钟</td>
</tr>
<tr>
<td>W</td>
<td>周</td>
<td>s</td>
<td>秒</td>
</tr>
<tr>
<td>D</td>
<td>天</td>
<td>ms</td>
<td>毫秒</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>us</td>
<td>微秒</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>ns</td>
<td>纳秒</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>ps</td>
<td>皮秒</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>fs</td>
<td>飞秒</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>as</td>
<td>阿托秒</td>
</tr>
</tbody>
</table>
</div>
<p>例：从字符串创建 datetime64 类型时，默认情况下，numpy 会根据字符串自动选择对应的单位。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.datetime64(<span class="string">&#x27;2020-03-08 20:00:05&#x27;</span>)</span><br><span class="line">print(a, a.dtype)  <span class="comment"># 2020-03-08T20:00:05 datetime64[s]</span></span><br></pre></td></tr></table></figure>
<p>例：从字符串创建 datetime64 类型时，可以强制指定使用的单位。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.datetime64(<span class="string">&#x27;2020-03&#x27;</span>, <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">print(a, a.dtype)  <span class="comment"># 2020-03-01 datetime64[D]</span></span><br><span class="line"></span><br><span class="line">a = np.datetime64(<span class="string">&#x27;2020-03&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">print(a, a.dtype)  <span class="comment"># 2020 datetime64[Y]</span></span><br><span class="line"></span><br><span class="line">print(np.datetime64(<span class="string">&#x27;2020-03&#x27;</span>) == np.datetime64(<span class="string">&#x27;2020-03-01&#x27;</span>))  <span class="comment"># True</span></span><br><span class="line">print(np.datetime64(<span class="string">&#x27;2020-03&#x27;</span>) == np.datetime64(<span class="string">&#x27;2020-03-02&#x27;</span>))  <span class="comment">#False</span></span><br></pre></td></tr></table></figure>
<p>由上例可以看出，2019-03 和 2019-03-01 所表示的其实是同一个时间。 事实上，如果两个 datetime64 对象具有不同的单位，它们可能仍然代表相同的时刻。并且从较大的单位（如月份）转换为较小的单位（如天数）是安全的。</p>
<p>例：从字符串创建 datetime64 数组时，如果单位不统一，则一律转化成其中最小的单位。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="string">&#x27;2020-03&#x27;</span>, <span class="string">&#x27;2020-03-08&#x27;</span>, <span class="string">&#x27;2020-03-08 20:00&#x27;</span>], dtype=<span class="string">&#x27;datetime64&#x27;</span>)</span><br><span class="line">print(a, a.dtype)</span><br><span class="line"><span class="comment"># [&#x27;2020-03-01T00:00&#x27; &#x27;2020-03-08T00:00&#x27; &#x27;2020-03-08T20:00&#x27;] datetime64[m]</span></span><br></pre></td></tr></table></figure>
<p>例：使用<code>arange()</code>创建 datetime64 数组，用于生成日期范围。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="string">&#x27;2020-08-01&#x27;</span>, <span class="string">&#x27;2020-08-10&#x27;</span>, dtype=np.datetime64)</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># [&#x27;2020-08-01&#x27; &#x27;2020-08-02&#x27; &#x27;2020-08-03&#x27; &#x27;2020-08-04&#x27; &#x27;2020-08-05&#x27;</span></span><br><span class="line"><span class="comment">#  &#x27;2020-08-06&#x27; &#x27;2020-08-07&#x27; &#x27;2020-08-08&#x27; &#x27;2020-08-09&#x27;]</span></span><br><span class="line">print(a.dtype)  <span class="comment"># datetime64[D]</span></span><br></pre></td></tr></table></figure>
<h2 id="datetime64和timedelta64运算"><a href="#datetime64和timedelta64运算" class="headerlink" title="datetime64和timedelta64运算"></a>datetime64和timedelta64运算</h2><p>例：timedelta64 表示两个 datetime64 之间的差。timedelta64 也是带单位的，并且和相减运算中的两个 datetime64 中的较小的单位保持一致。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.datetime64(<span class="string">&#x27;2020-03&#x27;</span>) + np.timedelta64(<span class="number">20</span>, <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">b = np.datetime64(<span class="string">&#x27;2020-06-15 00:00&#x27;</span>) + np.timedelta64(<span class="number">12</span>, <span class="string">&#x27;h&#x27;</span>)</span><br><span class="line">print(a, a.dtype)  <span class="comment"># 2020-03-21 datetime64[D]</span></span><br><span class="line">print(b, b.dtype)  <span class="comment"># 2020-06-15T12:00 datetime64[m]</span></span><br></pre></td></tr></table></figure>
<p>生成 timedelta64时，要注意年（’Y’）和月（’M’）这两个单位无法和其它单位进行运算（一年有几天？一个月有几个小时？这些都是不确定的）。</p>
<p>例：numpy.datetime64 与 datetime.datetime 相互转换</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">dt = datetime.datetime(year=<span class="number">2020</span>, month=<span class="number">6</span>, day=<span class="number">1</span>, hour=<span class="number">20</span>, minute=<span class="number">5</span>, second=<span class="number">30</span>)</span><br><span class="line">dt64 = np.datetime64(dt, <span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">print(dt64, dt64.dtype)</span><br><span class="line"><span class="comment"># 2020-06-01T20:05:30 datetime64[s]</span></span><br><span class="line"></span><br><span class="line">dt2 = dt64.astype(datetime.datetime)</span><br><span class="line">print(dt2, <span class="built_in">type</span>(dt2))</span><br><span class="line"><span class="comment"># 2020-06-01 20:05:30 &lt;class &#x27;datetime.datetime&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="datetime64的应用"><a href="#datetime64的应用" class="headerlink" title="datetime64的应用"></a>datetime64的应用</h2><ul>
<li><p>numpy.busday_offset(dates, offsets, roll=’raise’, weekmask=’1111100’, holidays=None, busdaycal=None, out=None)</p>
<p>将指定的偏移量应用于工作日，单位天（’D’）。计算下一个工作日，如果当前日期为非工作日，默认报错。可以指定 <code>forward</code> 或 <code>backward</code> 规则来避免报错。（一个是向前取第一个有效的工作日，一个是向后取第一个有效的工作日）</p>
<p>可以指定偏移量为 0 来获取当前日期向前或向后最近的工作日，当然，如果当前日期本身就是工作日，则直接返回当前日期。</p>
</li>
<li><p>numpy.is_busday(dates, weekmask=’1111100’, holidays=None, busdaycal=None, out=None)</p>
</li>
</ul>
<p>例：自定义周掩码值，即指定一周中哪些星期是工作日。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2020-07-10 星期五</span></span><br><span class="line">a = np.is_busday(<span class="string">&#x27;2020-07-10&#x27;</span>, weekmask=[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">b = np.is_busday(<span class="string">&#x27;2020-07-10&#x27;</span>, weekmask=[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">print(a)  <span class="comment"># True</span></span><br><span class="line">print(b)  <span class="comment"># False</span></span><br></pre></td></tr></table></figure>
<p>例：返回两个日期之间的工作日数量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2020-07-10 星期五</span></span><br><span class="line">begindates = np.datetime64(<span class="string">&#x27;2020-07-10&#x27;</span>)</span><br><span class="line">enddates = np.datetime64(<span class="string">&#x27;2020-07-20&#x27;</span>)</span><br><span class="line">a = np.busday_count(begindates, enddates)</span><br><span class="line">b = np.busday_count(enddates, begindates)</span><br><span class="line">print(a)  <span class="comment"># 6</span></span><br><span class="line">print(b)  <span class="comment"># -6</span></span><br></pre></td></tr></table></figure>
<h1 id="数组的创建"><a href="#数组的创建" class="headerlink" title="数组的创建"></a>数组的创建</h1><p>numpy 提供的最重要的数据结构是<code>ndarray</code>，它是 python 中<code>list</code>的扩展。</p>
<h2 id="1-依据现有数据来创建ndarray"><a href="#1-依据现有数据来创建ndarray" class="headerlink" title="1. 依据现有数据来创建ndarray"></a>1. 依据现有数据来创建ndarray</h2><h3 id="（a）通过array-函数进行创建"><a href="#（a）通过array-函数进行创建" class="headerlink" title="（a）通过array()函数进行创建"></a>（a）通过array()函数进行创建</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">array</span>(<span class="params">p_object, dtype=<span class="literal">None</span>, copy=<span class="literal">True</span>, order=<span class="string">&#x27;K&#x27;</span>, subok=<span class="literal">False</span>, ndmin=<span class="number">0</span></span>):</span> </span><br></pre></td></tr></table></figure>
<p>例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">d = np.array([[(<span class="number">1.5</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)],</span><br><span class="line">              [(<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)]])</span><br><span class="line">print(d, <span class="built_in">type</span>(d))</span><br></pre></td></tr></table></figure>
<h3 id="（b）通过asarray-函数进行创建"><a href="#（b）通过asarray-函数进行创建" class="headerlink" title="（b）通过asarray()函数进行创建"></a>（b）通过asarray()函数进行创建</h3><p><code>array()</code>和<code>asarray()</code>都可以将结构数据转化为 ndarray，但是<code>array()</code>和<code>asarray()</code>主要区别就是当数据源是<strong>ndarray</strong> 时，<code>array()</code>仍然会 copy 出一个副本，占用新的内存，但不改变 dtype 时 <code>asarray()</code>不会。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">asarray</span>(<span class="params">a, dtype=<span class="literal">None</span>, order=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> array(a, dtype, copy=<span class="literal">False</span>, order=order)</span><br></pre></td></tr></table></figure>
<h3 id="（c）通过fromfunction-函数进行创建"><a href="#（c）通过fromfunction-函数进行创建" class="headerlink" title="（c）通过fromfunction()函数进行创建"></a>（c）通过fromfunction()函数进行创建</h3><p>给函数绘图的时候可能会用到<code>fromfunction()</code>，该函数可从函数中创建数组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fromfunction</span>(<span class="params">function, shape, **kwargs</span>):</span></span><br></pre></td></tr></table></figure>
<p>例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span> * x + y</span><br><span class="line"></span><br><span class="line">x = np.fromfunction(f, (<span class="number">5</span>, <span class="number">4</span>), dtype=<span class="built_in">int</span>)</span><br><span class="line">print(x)</span><br><span class="line"><span class="comment"># [[ 0  1  2  3]</span></span><br><span class="line"><span class="comment">#  [10 11 12 13]</span></span><br><span class="line"><span class="comment">#  [20 21 22 23]</span></span><br><span class="line"><span class="comment">#  [30 31 32 33]</span></span><br><span class="line"><span class="comment">#  [40 41 42 43]]</span></span><br><span class="line"></span><br><span class="line">x = np.fromfunction(<span class="keyword">lambda</span> i, j: i == j, (<span class="number">3</span>, <span class="number">3</span>), dtype=<span class="built_in">int</span>)</span><br><span class="line">print(x)</span><br><span class="line"><span class="comment"># [[ True False False]</span></span><br><span class="line"><span class="comment">#  [False  True False]</span></span><br><span class="line"><span class="comment">#  [False False  True]]</span></span><br><span class="line"></span><br><span class="line">x = np.fromfunction(<span class="keyword">lambda</span> i, j: i + j, (<span class="number">3</span>, <span class="number">3</span>), dtype=<span class="built_in">int</span>)</span><br><span class="line">print(x)</span><br><span class="line"><span class="comment"># [[0 1 2]</span></span><br><span class="line"><span class="comment">#  [1 2 3]</span></span><br><span class="line"><span class="comment">#  [2 3 4]]</span></span><br></pre></td></tr></table></figure>
<h2 id="2-依据ones和zeros填充方式"><a href="#2-依据ones和zeros填充方式" class="headerlink" title="2. 依据ones和zeros填充方式"></a>2. 依据ones和zeros填充方式</h2><p>在机器学习任务中经常做的一件事就是初始化参数，需要用常数值或者随机值来创建一个固定大小的矩阵。</p>
<h3 id="（a）零数组"><a href="#（a）零数组" class="headerlink" title="（a）零数组"></a>（a）零数组</h3><ul>
<li><code>zeros()</code>函数：返回给定形状和类型的零数组。</li>
<li><code>zeros_like()</code>函数：返回与给定数组形状和类型相同的零数组。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zeros</span>(<span class="params">shape, dtype=<span class="literal">None</span>, order=<span class="string">&#x27;C&#x27;</span></span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zeros_like</span>(<span class="params">a, dtype=<span class="literal">None</span>, order=<span class="string">&#x27;K&#x27;</span>, subok=<span class="literal">True</span>, shape=<span class="literal">None</span></span>):</span></span><br></pre></td></tr></table></figure>
<h3 id="（b）1数组"><a href="#（b）1数组" class="headerlink" title="（b）1数组"></a>（b）1数组</h3><ul>
<li><code>ones()</code>函数：返回给定形状和类型的1数组。</li>
<li><code>ones_like()</code>函数：返回与给定数组形状和类型相同的1数组。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ones</span>(<span class="params">shape, dtype=<span class="literal">None</span>, order=<span class="string">&#x27;C&#x27;</span></span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ones_like</span>(<span class="params">a, dtype=<span class="literal">None</span>, order=<span class="string">&#x27;K&#x27;</span>, subok=<span class="literal">True</span>, shape=<span class="literal">None</span></span>):</span></span><br></pre></td></tr></table></figure>
<h3 id="（c）空数组"><a href="#（c）空数组" class="headerlink" title="（c）空数组"></a>（c）空数组</h3><ul>
<li><code>empty()</code>函数：返回一个空数组，数组元素为随机数。</li>
<li><code>empty_like</code>函数：返回与给定数组具有相同形状和类型的新数组。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">empty</span>(<span class="params">shape, dtype=<span class="literal">None</span>, order=<span class="string">&#x27;C&#x27;</span></span>):</span> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">empty_like</span>(<span class="params">prototype, dtype=<span class="literal">None</span>, order=<span class="string">&#x27;K&#x27;</span>, subok=<span class="literal">True</span>, shape=<span class="literal">None</span></span>):</span></span><br></pre></td></tr></table></figure>
<h3 id="（d）单位数组"><a href="#（d）单位数组" class="headerlink" title="（d）单位数组"></a>（d）单位数组</h3><ul>
<li><code>eye()</code>函数：返回一个对角线上为1，其它地方为零的单位数组。</li>
<li><code>identity()</code>函数：返回一个方的单位数组。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eye</span>(<span class="params">N, M=<span class="literal">None</span>, k=<span class="number">0</span>, dtype=<span class="built_in">float</span>, order=<span class="string">&#x27;C&#x27;</span></span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">identity</span>(<span class="params">n, dtype=<span class="literal">None</span></span>):</span></span><br></pre></td></tr></table></figure>
<h3 id="（e）对角数组"><a href="#（e）对角数组" class="headerlink" title="（e）对角数组"></a>（e）对角数组</h3><ul>
<li><code>diag()</code>函数：提取对角线或构造对角数组。</li>
</ul>
<p>例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.arange(<span class="number">9</span>).reshape((<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">print(x)</span><br><span class="line"><span class="comment"># [[0 1 2]</span></span><br><span class="line"><span class="comment">#  [3 4 5]</span></span><br><span class="line"><span class="comment">#  [6 7 8]]</span></span><br><span class="line">print(np.diag(x))  <span class="comment"># [0 4 8]</span></span><br><span class="line">print(np.diag(x, k=<span class="number">1</span>))  <span class="comment"># [1 5]</span></span><br><span class="line">print(np.diag(x, k=-<span class="number">1</span>))  <span class="comment"># [3 7]</span></span><br><span class="line"></span><br><span class="line">v = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line">x = np.diag(v)</span><br><span class="line">print(x)</span><br><span class="line"><span class="comment"># [[1 0 0 0]</span></span><br><span class="line"><span class="comment">#  [0 3 0 0]</span></span><br><span class="line"><span class="comment">#  [0 0 5 0]</span></span><br><span class="line"><span class="comment">#  [0 0 0 7]]</span></span><br></pre></td></tr></table></figure>
<h3 id="（f）常数数组"><a href="#（f）常数数组" class="headerlink" title="（f）常数数组"></a>（f）常数数组</h3><ul>
<li><code>full()</code>函数：返回一个常数数组。</li>
<li><code>full_like()</code>函数：返回与给定数组具有相同形状和类型的常数数组。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">full</span>(<span class="params">shape, fill_value, dtype=<span class="literal">None</span>, order=<span class="string">&#x27;C&#x27;</span></span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">full_like</span>(<span class="params">a, fill_value, dtype=<span class="literal">None</span>, order=<span class="string">&#x27;K&#x27;</span>, subok=<span class="literal">True</span>, shape=<span class="literal">None</span></span>):</span></span><br></pre></td></tr></table></figure>
<h2 id="3-利用数值范围来创建ndarray"><a href="#3-利用数值范围来创建ndarray" class="headerlink" title="3. 利用数值范围来创建ndarray"></a>3. 利用数值范围来创建ndarray</h2><ul>
<li><code>arange()</code>函数：返回给定间隔内的均匀间隔的值。</li>
<li><code>linspace()</code>函数：返回指定间隔内的等间隔数字。</li>
<li><code>logspace()</code>函数：返回数以对数刻度均匀分布。</li>
<li><code>numpy.random.rand()</code> 返回一个由[0,1)内的随机数组成的数组。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">arange</span>(<span class="params">[start,] stop[, step,], dtype=<span class="literal">None</span></span>):</span> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">linspace</span>(<span class="params">start, stop, num=<span class="number">50</span>, endpoint=<span class="literal">True</span>, retstep=<span class="literal">False</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">             dtype=<span class="literal">None</span>, axis=<span class="number">0</span></span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logspace</span>(<span class="params">start, stop, num=<span class="number">50</span>, endpoint=<span class="literal">True</span>, base=<span class="number">10.0</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">             dtype=<span class="literal">None</span>, axis=<span class="number">0</span></span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rand</span>(<span class="params">d0, d1, ..., dn</span>):</span></span><br></pre></td></tr></table></figure>
<h2 id="4-结构数组的创建"><a href="#4-结构数组的创建" class="headerlink" title="4. 结构数组的创建"></a>4. 结构数组的创建</h2><p>结构数组，首先需要定义结构，然后利用<code>np.array()</code>来创建数组，其参数<code>dtype</code>为定义的结构。</p>
<h3 id="（a）利用字典来定义结构"><a href="#（a）利用字典来定义结构" class="headerlink" title="（a）利用字典来定义结构"></a>（a）利用字典来定义结构</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">personType = np.dtype(&#123;</span><br><span class="line">    <span class="string">&#x27;names&#x27;</span>: [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;weight&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;formats&#x27;</span>: [<span class="string">&#x27;U30&#x27;</span>, <span class="string">&#x27;i8&#x27;</span>, <span class="string">&#x27;f8&#x27;</span>]&#125;)</span><br><span class="line"></span><br><span class="line">a = np.array([(<span class="string">&#x27;Liming&#x27;</span>, <span class="number">24</span>, <span class="number">63.9</span>), (<span class="string">&#x27;Mike&#x27;</span>, <span class="number">15</span>, <span class="number">67.</span>), (<span class="string">&#x27;Jan&#x27;</span>, <span class="number">34</span>, <span class="number">45.8</span>)],</span><br><span class="line">             dtype=personType)</span><br><span class="line">print(a, <span class="built_in">type</span>(a))</span><br><span class="line"><span class="comment"># [(&#x27;Liming&#x27;, 24, 63.9) (&#x27;Mike&#x27;, 15, 67. ) (&#x27;Jan&#x27;, 34, 45.8)]</span></span><br><span class="line"><span class="comment"># &lt;class &#x27;numpy.ndarray&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="（b）利用包含多个元组的列表来定义结构"><a href="#（b）利用包含多个元组的列表来定义结构" class="headerlink" title="（b）利用包含多个元组的列表来定义结构"></a>（b）利用包含多个元组的列表来定义结构</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">personType = np.dtype([(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;U30&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;i8&#x27;</span>), (<span class="string">&#x27;weight&#x27;</span>, <span class="string">&#x27;f8&#x27;</span>)])</span><br><span class="line">a = np.array([(<span class="string">&#x27;Liming&#x27;</span>, <span class="number">24</span>, <span class="number">63.9</span>), (<span class="string">&#x27;Mike&#x27;</span>, <span class="number">15</span>, <span class="number">67.</span>), (<span class="string">&#x27;Jan&#x27;</span>, <span class="number">34</span>, <span class="number">45.8</span>)],</span><br><span class="line">             dtype=personType)</span><br><span class="line">print(a, <span class="built_in">type</span>(a))</span><br><span class="line"><span class="comment"># [(&#x27;Liming&#x27;, 24, 63.9) (&#x27;Mike&#x27;, 15, 67. ) (&#x27;Jan&#x27;, 34, 45.8)]</span></span><br><span class="line"><span class="comment"># &lt;class &#x27;numpy.ndarray&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结构数组的取值方式和一般数组差不多，可以通过下标取得元素：</span></span><br><span class="line">print(a[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># (&#x27;Liming&#x27;, 24, 63.9)</span></span><br><span class="line"></span><br><span class="line">print(a[-<span class="number">2</span>:])</span><br><span class="line"><span class="comment"># [(&#x27;Mike&#x27;, 15, 67. ) (&#x27;Jan&#x27;, 34, 45.8)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们可以使用字段名作为下标获取对应的值</span></span><br><span class="line">print(a[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line"><span class="comment"># [&#x27;Liming&#x27; &#x27;Mike&#x27; &#x27;Jan&#x27;]</span></span><br><span class="line">print(a[<span class="string">&#x27;age&#x27;</span>])</span><br><span class="line"><span class="comment"># [24 15 34]</span></span><br><span class="line">print(a[<span class="string">&#x27;weight&#x27;</span>])</span><br><span class="line"><span class="comment"># [63.9 67.  45.8]</span></span><br></pre></td></tr></table></figure>
<h1 id="数组的属性"><a href="#数组的属性" class="headerlink" title="数组的属性"></a>数组的属性</h1><p>在使用 numpy 时，你会想知道数组的某些信息。很幸运，在这个包里边包含了很多便捷的方法，可以给你想要的信息。</p>
<ul>
<li><code>numpy.ndarray.ndim</code>用于返回数组的维数（轴的个数）也称为秩，一维数组的秩为 1，二维数组的秩为 2，以此类推。</li>
<li><code>numpy.ndarray.shape</code>表示数组的维度，返回一个元组，这个元组的长度就是维度的数目，即 <code>ndim</code> 属性(秩)。</li>
<li><code>numpy.ndarray.size</code>数组中所有元素的总量，相当于数组的<code>shape</code>中所有元素的乘积，例如矩阵的元素总量为行与列的乘积。</li>
<li><code>numpy.ndarray.dtype</code> <code>ndarray</code> 对象的元素类型。</li>
<li><code>numpy.ndarray.itemsize</code>以字节的形式返回数组中每一个元素的大小。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ndarray</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    shape = <span class="built_in">property</span>(<span class="keyword">lambda</span> self: <span class="built_in">object</span>(), <span class="keyword">lambda</span> self, v: <span class="literal">None</span>, <span class="keyword">lambda</span> self: <span class="literal">None</span>)</span><br><span class="line">    dtype = <span class="built_in">property</span>(<span class="keyword">lambda</span> self: <span class="built_in">object</span>(), <span class="keyword">lambda</span> self, v: <span class="literal">None</span>, <span class="keyword">lambda</span> self: <span class="literal">None</span>)</span><br><span class="line">    size = <span class="built_in">property</span>(<span class="keyword">lambda</span> self: <span class="built_in">object</span>(), <span class="keyword">lambda</span> self, v: <span class="literal">None</span>, <span class="keyword">lambda</span> self: <span class="literal">None</span>)</span><br><span class="line">    ndim = <span class="built_in">property</span>(<span class="keyword">lambda</span> self: <span class="built_in">object</span>(), <span class="keyword">lambda</span> self, v: <span class="literal">None</span>, <span class="keyword">lambda</span> self: <span class="literal">None</span>)</span><br><span class="line">    itemsize = <span class="built_in">property</span>(<span class="keyword">lambda</span> self: <span class="built_in">object</span>(), <span class="keyword">lambda</span> self, v: <span class="literal">None</span>, <span class="keyword">lambda</span> self: <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>在<code>ndarray</code>中所有元素必须是同一类型，否则会自动向下转换，<code>int-&gt;float-&gt;str</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/default-index/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/default-index/page/5/">5</a><a class="extend next" rel="next" href="/default-index/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Normal People"
      src="/images/posthead.jpg">
  <p class="site-author-name" itemprop="name">Normal People</p>
  <div class="site-description" itemprop="description">Get busy living or get busy dying</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/TheNormalPeople" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;TheNormalPeople" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1272481411@qq.com" title="E-Mail → mailto:1272481411@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5938927274" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5938927274" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/cy19970506" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;cy19970506" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Normal People</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'y8XFURQNCoQsprRTou9DiEJu-gzGzoHsz',
      appKey     : 'QfVpjKDtJQdJrnJNnWUbVvjH',
      placeholder: "留下邮箱,有空时间回复您！",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
