<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true,"scrollpercent":true,"b2t":true},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="支持向量机（support vector machines，SVM）是一种二类分类模型。它的基本模型是定义在特征空间上的间隔最大的线性分类器，间隔最大使它有别于感知机；支持向量机还包括核技巧，这使它成为实质上的非线性分类器。  支持向量机的学习策略就是间隔最大化，可形式化为一个求解凸二次规划（convex quadratic programming）的问题，也等价于正则化的合页损失函数的最小化问">
<meta property="og:type" content="article">
<meta property="og:title" content="第七章 支持向量机">
<meta property="og:url" content="http://example.com/2021/06/16/Statistical_Learning_Methods_Notes/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="支持向量机（support vector machines，SVM）是一种二类分类模型。它的基本模型是定义在特征空间上的间隔最大的线性分类器，间隔最大使它有别于感知机；支持向量机还包括核技巧，这使它成为实质上的非线性分类器。  支持向量机的学习策略就是间隔最大化，可形式化为一个求解凸二次规划（convex quadratic programming）的问题，也等价于正则化的合页损失函数的最小化问">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-06-16T12:46:39.901Z">
<meta property="article:modified_time" content="2021-06-16T12:46:21.681Z">
<meta property="article:author" content="Normal People">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2021/06/16/Statistical_Learning_Methods_Notes/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>第七章 支持向量机 | Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">by Normal People</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">6</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">25</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/16/Statistical_Learning_Methods_Notes/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/posthead.jpg">
      <meta itemprop="name" content="Normal People">
      <meta itemprop="description" content="Get busy living or get busy dying">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          第七章 支持向量机
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-06-16 20:46:39 / 修改时间：20:46:21" itemprop="dateCreated datePublished" datetime="2021-06-16T20:46:39+08:00">2021-06-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">统计学习方法</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/06/16/Statistical_Learning_Methods_Notes/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/06/16/Statistical_Learning_Methods_Notes/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <ul>
<li><p><strong>支持向量机（support vector machines，SVM）</strong>是一种二类分类模型。它的基本模型是定义在特征空间上的间隔最大的线性分类器，间隔最大使它有别于感知机；支持向量机还包括核技巧，这使它成为实质上的非线性分类器。</p>
</li>
<li><p>支持向量机的学习策略就是间隔最大化，可形式化为一个求解<strong>凸二次规划（convex quadratic programming）</strong>的问题，也等价于正则化的合页损失函数的最小化问题。</p>
</li>
<li><p>支持向量机的学习算法是求解凸二次规划的最优化算法。</p>
</li>
</ul>
<p>支持向量机学习方法包含构建由简至繁的模型：</p>
<ul>
<li><p><strong>线性可分支持向量机（linear support vector machine in linearly separable case）</strong></p>
<p>当训练数据线性可分时，通过<strong>硬间隔最大化（hard margin maximization）</strong>，学习一个线性分类器，即线性可分支持向量机，又称为硬间隔支持向量机。</p>
</li>
<li><p><strong>线性支持向量机（linear support vector machine）</strong></p>
<p>当训练数据近似线性可分时，通过<strong>软间隔最大化（soft margin maximization）</strong>，也学习一个线性的分类器，即线性支持向量机，又称为软间隔支持向量机。</p>
</li>
<li><p><strong>非线性支持向量机（non-linear support vector machine）</strong></p>
<p>当训练数据线性不可分时，通过使用<strong>核技巧（kernel trick）</strong>及软间隔最大化，学习非线性支持向量机。</p>
</li>
</ul>
<p>当输入空间为欧式空间或离散集合、特征空间为希尔伯特空间时，<strong>核函数（kernel function）</strong>表示将输入从输入空间映射到特征空间得到的特征向量之间的内积。通过使用核函数可以学习非线性支持向量机，等价于隐式地在高维的特征空间中学习线性支持向量机。</p>
<h1 id="7-1-线性可分支持向量机与硬间隔最大化"><a href="#7-1-线性可分支持向量机与硬间隔最大化" class="headerlink" title="7.1 线性可分支持向量机与硬间隔最大化"></a>7.1 线性可分支持向量机与硬间隔最大化</h1><h1 id="7-1-1-线性可分支持向量机"><a href="#7-1-1-线性可分支持向量机" class="headerlink" title="7.1.1 线性可分支持向量机"></a>7.1.1 线性可分支持向量机</h1><p>假设输入空间与特征空间为两个不同的空间。输入空间为欧式空间或离散集合，特征空间为欧式空间或希尔伯特空间。线性可分支持向量机、线性支持向量机假设这两个空间的元素一一对应，并将输入空间中的输入映射为特征空间中的特征向量。非线性支持向量机利用一个从输入到特征空间的非线性映射将输入映射为特征向量。所以，输入都由输入空间转换到特征空间，支持向量机的学习是在特征空间进行的。</p>
<p>假设给定一个特征空间上的训练数据集<br>$$<br>T = {(x_1,y_1),(x_2,y_2),…,(x_N,y_N)}<br>$$<br>其中，$x_i \in \chi = R^n, y \in \mathcal{Y} = {+1, -1}, i=1,2,…,N$；在假设训练数据集是线性可分的。</p>
<p>学习的目标是：在特征空间中找到一个分离超平面，能将实例分到不同的类。分离超平面对应于方程$\omega · x + b = 0$，它由法向量$\omega$和截距$b$决定，可用$(\omega,b)$来表示。分离超平面将特征空间划分为两部分，一部分是正类，一部分是负类。法向量指向一侧为正类，另一侧为负类。</p>
<p>一般地，当训练数据集线性可分时，存在无穷个分离超平面可将两类数据正确分开。感知机利用误分类最小的策略，求得分离超平面，不过这时的解有无穷多个。线性可分支持向量机利用间隔最大化求最优分离超平面，这时，解是唯一的。</p>
<p><strong>定义 7.1（线性可分支持向量机）</strong>  给定线性可分训练数据集，通过间隔最大化或等价地求解相应的凸二次规划问题学习得到的分离超平面为<br>$$<br>\omega^* · x + b^* = 0 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.1)<br>$$<br>以及相应的分类决策函数<br>$$<br>f(x) = sign(\omega^* · x + b^*)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.2)<br>$$<br>称为线性可分支持向量机。</p>
<h2 id="7-1-2-函数间隔和几何间隔"><a href="#7-1-2-函数间隔和几何间隔" class="headerlink" title="7.1.2 函数间隔和几何间隔"></a>7.1.2 函数间隔和几何间隔</h2><ul>
<li><p>一般来说，一个点距离分离超平面的远近可以表示分类预测的确信程度。在超平面$\omega · x + b = 0$确定的情况下，$|\omega · x + b|$能够相对地表示点$x$距离超平面的远近。而$\omega · x + b$的符号与类标记$y$的符号是否一致能够表示分类是否正确。所以可用量$y(\omega · x + b)$来表示分类的正确性及确信度，这就是<strong>函数间隔（functional margin）</strong>的概念。</p>
<p><strong>定义 7.2（函数间隔）</strong>  对于给定的训练数据集$T$和超平面$(\omega,b)$，定义超平面$(\omega,b)$关于样本点$(x_i,y_i)$的函数间隔为<br>$$<br>\hat \gamma_i = y_i(\omega·x_i+b)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.3)<br>$$<br>定义超平面$(\omega,b)$关于训练数据集$T$的函数间隔为超平面$(\omega,b)$关于$T$中所有样本点$(x_i,y_i)$的函数间隔之最小值，即<br>$$<br>\hat \gamma= \min\limits_{i=1,2,…,N}\hat\gamma_i\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.4)<br>$$<br>函数间隔可以表示分类预测的正确性及确信度。</p>
</li>
<li><p>但是选择分离超平面时，只有函数间隔还不够。因为只要成比例地改变$\omega$和$b$，超平面并没有改变，但函数间隔却成为原来的2倍。可以对分离超平面的法向量$\omega$加某些约束，如规范化，$||\omega|| = 1$，这使得间隔是确定的。这时函数间隔成为<strong>几何间隔（geometric margin）</strong>。</p>
<p><strong>定义 7.3（几何间隔）</strong>  对于给定的训练数据集$T$和超平面$(\omega,b)$，定义超平面$(\omega,b)$关于样本点$(x_i,y_i)$的几何间隔为<br>$$<br>\gamma_i = y_i(\frac{\omega}{||\omega||}·x_i + \frac{b}{||\omega||})\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.5)<br>$$<br>定义超平面$(\omega,b)$关于训练数据集$T$的几何间隔为超平面$(\omega,b)$关于$T$中所有样本点$(x_i,y_i)$的几何间隔之最小值，即<br>$$<br>\gamma= \min\limits_{i=1,2,…,N}\gamma_i\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.6)<br>$$<br>超平面$(\omega,b)$关于样本点$(x_i,y_i)$的几何间隔一般是实例点到超平面的<strong>带符号的距离（signed distance）</strong>，当样本点被超平面正确分类时就是实例点到超平面的距离。</p>
</li>
</ul>
<hr>
<p>从函数间隔和几何间隔的定义可知，函数间隔和几何间隔有下面的关系：<br>$$<br>\gamma_i = \frac{\hat\gamma_i}{||\omega||}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.7)<br>$$</p>
<p>$$<br>\gamma = \frac{\hat\gamma}{||\omega||}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.8)<br>$$</p>
<p>如果$||\omega|| = 1$，那么函数间隔和几何间隔相等。如果超平面参数$\omega$和$b$成比例地改变（超平面没有改变），函数间隔也按此比例改变，而几何间隔不变。</p>
<h2 id="7-1-3-间隔最大化"><a href="#7-1-3-间隔最大化" class="headerlink" title="7.1.3 间隔最大化"></a>7.1.3 间隔最大化</h2><p>支持向量机学习的基本想法是求解能够正确划分训练数据集并且几何间隔最大的分离超平面。</p>
<p>间隔最大化的直观解释是：对训练数据集找到几何间隔最大的超平面意味着以充分大的确信度对训练数据进行分类。也就是说，不仅将正负实例点分开，而且对最难分的实例点（离超平面最近的点）也有足够大的确信度将它们分开。</p>
<ol>
<li><strong>最大间隔分离超平面</strong></li>
</ol>
<p>考虑如何求得一个几何间隔最大的分离超平面，即最大间隔分离超平面。具体地，这个问题可以表示为下面的约束最优化问题：<br>$$<br>\max\limits_{\omega,b} \gamma\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.9)<br>$$</p>
<p>$$<br>s.t.\ \ \ y_i(\frac{\omega}{||\omega||}·x_i + \frac{b}{||\omega||}) \geq \gamma, \ \ \ i=1,2,…,N\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.10)<br>$$</p>
<p>即我们希望最大化超平面$(\omega,b)$关于训练数据集的几何间隔$\gamma$，约束条件表示的是超平面$(\omega,b)$关于每个训练样本点的几何间隔至少是$\gamma$。</p>
<p>考虑几何间隔和函数间隔的关系式，可将这个问题改写为<br>$$<br>\max\limits_{\omega,b} \frac{\hat\gamma}{||\omega||}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.11)<br>$$</p>
<p>$$<br>s.t.\ \ \ y_i(\omega·x_i+b) \geq \hat\gamma, \ \ \ i=1,2,…,N\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.12)<br>$$</p>
<p>函数间隔$\hat\gamma$的取值并不影响最优化问题的解。事实上，假设将$\omega$和$b$按比例改变为$\lambda\omega$和$\lambda b$，这时函数间隔成为$\lambda \hat\gamma$。函数间隔的这一改变对上面最优化问题的不等式约束没有影响，对目标函数的优化也没有影响，也就是说，它产生一个等价的最优化问题。这样，就可以取$\hat\gamma = 1$。将$\hat\gamma = 1$代入上面的最优化问题，注意到最大化$\frac{1}{||\omega||}$和最小化$\frac{1}{2}||\omega||^2$是等价的，于是就得到下面的线性可分支持向量机学习的最优化问题：<br>$$<br>\min\limits_{\omega,b}\frac{1}{2}||\omega||^2\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.13)<br>$$</p>
<p>$$<br>s.t.\ \ \ y_i(\omega·x_i+b) - 1 \geq 0, \ \ \ i=1,2,…,N\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.14)<br>$$</p>
<p>这是一个凸二次规划（convex quadratic programming）问题。</p>
<p>凸优化问题是指约束最优化问题<br>$$<br>\min f(\omega)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.15)<br>$$</p>
<p>$$<br>s.t.\ \ \ g_i(\omega) \leq 0, \ \ \ i=1,2,…,k\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.16)<br>$$</p>
<p>$$<br>h_i(\omega) = 0, \ \ \ i=1,2,…,l\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.17)<br>$$</p>
<p>其中，目标函数$f(\omega)$和约束函数$g_i(\omega)$都是$R^n$上的连续可微的凸函数，约束函数$h_i(\omega)$是$R^n$上的仿射函数。</p>
<p>注：$f(x)$称为仿射函数，如果它满足$f(x) = a·x +b,a\in R^n,b \in R^n,x\in R^n$。</p>
<p>当目标函数$f(\omega)$是二次函数且约束函数$g_i(\omega)$是仿射函数时，上述凸最优化问题称为凸二次规划问题。</p>
<p><strong>算法 7.1（线性可分支持向量机学习算法——最大间隔法）</strong></p>
<p><strong>输入</strong>：线性可分训练数据集$T = {(x_1,y_1),(x_2,y_2),…,(x_N,y_N)}$，其中，$x_i \in \chi = R^n, y \in \mathcal{Y} = {+1, -1}, i=1,2,…,N$；</p>
<p><strong>输出</strong>：最大间隔分离超平面和分类决策函数。</p>
<p>​    （1）构造并求解约束最优化问题：<br>$$<br>\min\limits_{\omega,b}\frac{1}{2}||\omega||^2<br>$$</p>
<p>$$<br>s.t.\ \ \ y_i(\omega·x_i+b) - 1 \geq 0, \ \ \ i=1,2,…,N<br>$$</p>
<p>求得最优解$\omega^*,b^*$。</p>
<p>​    （2）由此得到分离超平面：<br>$$<br>\omega ^* ·x + b^* = 0<br>$$<br>分类决策函数<br>$$<br>f(x) = sign(\omega ^* ·x + b^*)<br>$$</p>
<ol start="2">
<li><strong>最大间隔分离超平面的存在唯一性</strong></li>
</ol>
<p><strong>定理 7.1（最大间隔分离超平面的存在唯一性）</strong>  若训练数据集$T$线性可分，则可将训练数据集中的样本点完全正确分开的最大间隔分离超平面存在且唯一。</p>
<ol start="3">
<li><strong>支持向量和间隔边界</strong></li>
</ol>
<p>在线性可分情况下，训练数据集的样本点中与分离超平面距离最近的样本点的实例称为支持向量（support vector）。支持向量是使约束条件式（7.14）等号成立的点，即<br>$$<br>y_i(\omega·x_i+ b) -1 = 0<br>$$<br>对$y_i = +1$的正例点，支持向量在超平面<br>$$<br>H_1 ：\omega ·x +b = 1<br>$$<br>上，对$y_i = -1$的正例点，支持向量在超平面<br>$$<br>H_1 ：\omega ·x +b = -1<br>$$<br>上。</p>
<p>c，并且没有实例点落在它们中间。在$H_1$与$H_2$之间形成一条长带，分离超平面与它们平行且位于它们中央。长带的宽度，即$H_1$与$H_2$之间的距离称为<strong>间隔（margin）</strong>。间隔依赖于分离超平面的法向量$\omega$，等于$\frac{2}{||\omega||}$。$H_1$和$H_2$称为间隔边界。</p>
<p>在决定分离超平面时只有支持向量起作用，而其他实例点并不起作用。</p>
<p>支持向量的个数一般很少，所以支持向量机由很少的“重要的”训练样本确定。</p>
<h2 id="7-1-4-学习的对偶算法"><a href="#7-1-4-学习的对偶算法" class="headerlink" title="7.1.4 学习的对偶算法"></a>7.1.4 学习的对偶算法</h2><p>通过求解<strong>对偶问题（dual problem）</strong>得到<strong>原始问题（primal problem）</strong>的最优解，这就是线性可分支持向量机的<strong>对偶算法（dual algorithm）</strong>。</p>
<p>这样做的优点：</p>
<ul>
<li>对偶问题往往更容易求解；</li>
<li>自然引入核函数，进而推广到非线性分类问题。</li>
</ul>
<p>首先构建拉格朗日函数（Lagrange function）。为此，对每一个不等式约束$(7.14)$引进拉格朗日乘子（Lagrange multiplier）$\alpha_i \geq 0,\ \ \ i = 1,2,…,N$，定义拉格朗日函数：<br>$$<br>L(\omega,b,\alpha) = \frac{1}{2}||\omega||^2 - \sum\limits_{i=1}^{N}\alpha_i y_i (\omega·x_i + b) + \sum\limits_{i=1}^{N}\alpha_i\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.18)<br>$$<br>其中，$\alpha = (\alpha_1,\alpha_2,…,\alpha_N)^T$为拉格朗日乘子向量。</p>
<p>根据拉格朗日对偶性，原始为题的对偶问题是极大极小问题：<br>$$<br>\max\limits_{\alpha} \min\limits_{\omega,b}L(\omega,b,\alpha)<br>$$<br>所以，为了得到对偶问题的解，需要先求$L(\omega,b,\alpha)$对$\omega,b$的极小，再求对$\alpha$的极大。</p>
<p>对偶最优化问题：<br>$$<br>\min\limits_{\alpha} \ \ \ \frac{1}{2}\sum\limits_{i=1}^{N}\sum\limits_{j=1}^{N}\alpha_i \alpha_j y_i y_j (x_i·x_j)\ - \ \sum\limits_{i=1}^{N}\alpha_i\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.22)<br>$$</p>
<p>$$<br>s.t. \ \ \ \sum\limits_{i=1}^{N}\alpha_i y_i = 0\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.23)<br>$$</p>
<p>$$<br>\alpha_i \geq 0, \ \ \ i = 1,2,…,N\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.24)<br>$$</p>
<p><strong>定理 7.2</strong>  设$\alpha^* = (\alpha^*_1,\alpha^*_2,…,\alpha^*<em>l)^T$是对偶最优化问题$(7.22)$ ~ $(7.24)$的解，则存在下标$j$，使得$\alpha_j^* &gt; 0$，并可按下式求得原始最优化问题$(7.13)$ ~ $(7.14)$的解$\omega^*,b^*$<br>$$<br>\omega^* =\sum\limits</em>{i=1}^{N}\alpha_i y_i x_i\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.25)<br>$$</p>
<p>$$<br>b^* = y_j - \sum\limits_{i=1}^{N}\alpha_i y_i (x_i·x_j)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.26)<br>$$</p>
<p>由此定理可知，分离超平面可以写成<br>$$<br>\sum\limits_{i=1}^{N}\alpha_i^* y_i (x·x_i) + b^* = 0\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.29)<br>$$<br>分类决策函数可以写成<br>$$<br>f(x) = sign(\sum\limits_{i=1}^{N}\alpha_i^* y_i (x·x_i) + b^*)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.30)<br>$$<br>这就是说，分类决策函数只依赖于输入$x$和训练样本输入的内积。式$(7.30)$称为线性可分支持向量机的对偶形式。</p>
<p>综上所述，对于给定的线性可分训练数据集，可以首先求对偶问题$(7.22)$ ~ $(7.24)$的解$\alpha^*$；再利用式$(7.25)$ ~ $(7.26)$求得原始问题的解$\omega^*,b^*$；从而得到分离超平面及分类决策函数。这种算法称为线性可分支持向量机的对偶学习算法，是线性可分支持向量机学习的基本算法。</p>
<p><strong>算法 7.2（线性可分支持向量机学习算法）</strong></p>
<p><strong>输入</strong>：线性可分训练数据集$T = {(x_1,y_1),(x_2,y_2),…,(x_N,y_N)}$，其中，$x_i \in \chi = R^n, y \in \mathcal{Y} = {+1, -1}, i=1,2,…,N$；</p>
<p><strong>输出</strong>：分离超平面和分类决策函数。</p>
<p>​    （1）构造并求约束最优化问题<br>$$<br>\min\limits_{\alpha} \ \ \ \frac{1}{2}\sum\limits_{i=1}^{N}\sum\limits_{j=1}^{N}\alpha_i \alpha_j y_i y_j (x_i·x_j)\ + \ \sum\limits_{i=1}^{N}\alpha_i<br>$$</p>
<p>$$<br>s.t. \ \ \ \sum\limits_{i=1}^{N}\alpha_i y_i = 0<br>$$</p>
<p>$$<br>\alpha_i \geq 0, \ \ \ i = 1,2,…,N<br>$$</p>
<p>求得最优解$\alpha^* = (\alpha^*_1,\alpha^*_2,…,\alpha^*_N)^T$。</p>
<p>​    （2）计算<br>$$<br>\omega^* =\sum\limits_{i=1}^{N}\alpha_i y_i x_i<br>$$<br>并选择$\alpha^*$的一个正分量$\alpha_j^* &gt; 0 $，计算<br>$$<br>b^* = y_j - \sum\limits_{i=1}^{N}\alpha_i y_i (x_i·x_j)<br>$$<br>​    （3）求得分离超平面<br>$$<br>\omega^<em>·x +b^</em> = 0<br>$$<br>分类决策函数：<br>$$<br>f(x) = sign(\omega^<em>·x +b^</em>)<br>$$<br>由式$(7.25)$、式$(7.26)$可知，$\omega^*$和$b^*$只依赖于训练数据中对应于$\alpha_i^* &gt; 0$的样本点$(x_i,y_i)$，而其他样本点对$\omega^*$和$b^*$没有影响。我们将训练数据中对应于$\alpha_i^* &gt; 0$的实例点$x_i \in R^n$称为支持向量。</p>
<p><strong>定义 7.4（支持向量）</strong>  考虑原始最优化问题$(7.13)$ ~ $(7.14)$及对偶最优化问题$(7.22)$ ~ $(7.24)$，将训练数据集中对应于$\alpha_i^* &gt; 0$的样本点$(x_i,y_i)$的实例$x_i \in R^n$称为支持向量。</p>
<h1 id="7-2-线性支持向量机与软间隔最大化"><a href="#7-2-线性支持向量机与软间隔最大化" class="headerlink" title="7.2 线性支持向量机与软间隔最大化"></a>7.2 线性支持向量机与软间隔最大化</h1><h2 id="7-2-1-线性支持向量机"><a href="#7-2-1-线性支持向量机" class="headerlink" title="7.2.1 线性支持向量机"></a>7.2.1 线性支持向量机</h2><p>假设给定一个特征空间上的训练数据集<br>$$<br>T = {(x_1,y_1),(x_2,y_2),…,(x_N,y_N)}<br>$$<br>其中，$x_i \in \chi = R^n, y \in Y = {+1, -1}, i=1,2,…,N$，$x_i$为第$i$个特征向量，$y_i$为$x_i$的类标记。再假设训练数据集不是线性可分的。通常情况是，训练数据中有一些<strong>特异点（outlier）</strong>，将这些特异点出去后，剩下大部分的样本点组成的集合是线性可分的。</p>
<p>线性不可分意味着某些样本点$(x_i,y_i)$不能满足函数间隔大于等于1的约束条件$(7.14)$。为了解决这个问题，可以对每个样本点$(x_i,y_i)$引进一个松弛变量$\xi_i \geq 0$，使函数间隔加上松弛变量大于等于1。这样，约束条件变为<br>$$<br>y_i(\omega·x_i+b) \geq 1 - \xi_i<br>$$<br>同时，对每个松弛变量$\xi_i$，支付一个代价$\xi_i$。目标函数由原来的$\frac{1}{2}||\omega||^2$变成<br>$$<br>\frac{1}{2}||\omega||^2 \ + \ C\sum\limits_{i=1}^N \xi_i\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.31)<br>$$<br>这里，$C&gt;0$称为惩罚参数，一般由应用问题决定，$C$值大时对误分类的惩罚增大，$C$值小时对误分类的惩罚减小。最小化目标函数$(7.31)$包含两层含义：使$\frac{1}{2}||\omega||^2 $尽量小即间隔尽量大，同时使误分类点的个数尽量小，$C$是调和二者的系数。</p>
<p>线性不可分的支持向量机的学习问题变成如下凸二次规划（convex quadratic programming）问题（原始问题）：<br>$$<br>\min\limits_{\omega,b,\xi} \ \ \ \frac{1}{2}||\omega||^2 \ + \ C\sum\limits_{i=1}^N \xi_i\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.32)<br>$$</p>
<p>$$<br>s.t.\ \ \ y_i(\omega·x_i+b) \geq 1 - \xi_i \ \ \ i = 1,2,…,N\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.33)<br>$$</p>
<p>$$<br>\xi_i \geq 0,\ \ \ i = 1,2,…,N\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.34)<br>$$</p>
<p>原始问题$(7.32)$ ~ $(7.34)$是一个凸二次规划问题，因而关于$(\omega,b,\xi)$的解是存在的。可以证明$\omega$的解是唯一的，但$b$的解可能不唯一，而是存在于一个区间。</p>
<p><strong>定义 7.5（线性支持向量机）</strong>  对于给定的线性不可分的训练数据集，通过求解凸二次规划问题，即软间隔最大化问题$(7.32)$ ~ $(7.34)$，得到的分离超平面为<br>$$<br>\omega^* · x + b^* =0\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.35)<br>$$<br>以及相应的分类决策函数<br>$$<br>f(x) = sign(\omega^* · x + b^*)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.36)<br>$$<br>称为线性支持向量机。</p>
<p>显然，线性支持向量机包含线性可分支持向量机。</p>
<h2 id="7-2-2-学习的对偶算法"><a href="#7-2-2-学习的对偶算法" class="headerlink" title="7.2.2 学习的对偶算法"></a>7.2.2 学习的对偶算法</h2><p>原始问题$(7.32)$ ~ $(7.34)$的对偶问题是<br>$$<br>\min\limits_{\alpha} \ \ \ \frac{1}{2}\sum\limits_{i=1}^{N}\sum\limits_{j=1}^{N}\alpha_i \alpha_j y_i y_j (x_i·x_j)\ - \ \sum\limits_{i=1}^{N}\alpha_i\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.37)<br>$$</p>
<p>$$<br>s.t. \ \ \ \sum\limits_{i=1}^{N}\alpha_i y_i = 0\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.38)<br>$$</p>
<p>$$<br>0 \leq \alpha_i \leq C, \ \ \ i = 1,2,…,N\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.39)<br>$$</p>
<p><strong>定理 7.3</strong>  设$\alpha^* = (\alpha^*_1,\alpha^*_2,…,\alpha^*<em>N)^T$是对偶问题$(7.37)$<del>$(7.39)$的一个解，若存在$\alpha^*$的一个分量$\alpha_j^*$，$0&lt; \alpha_j^*&lt;C$ ，则原始问题$(7.32)$</del>$(7.34)$的解$\omega^*,b^*$可按下式求得：<br>$$<br>\omega^* =\sum\limits</em>{i=1}^{N}\alpha_i^* y_i x_i\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.50)<br>$$</p>
<p>$$<br>b^* = y_j - \sum\limits_{i=1}^{N}\alpha_i^* y_i (x_i·x_j)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.51)<br>$$</p>
<p>由此定理可知，分离超平面可以写成<br>$$<br>\sum\limits_{i=1}^{N}\alpha_i^* y_i (x·x_j) + b^* = 0\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.55)<br>$$<br>分类决策函数可以写成<br>$$<br>f(x)= sign(\sum\limits_{i=1}^{N}\alpha_i^* y_i (x·x_j) + b^*)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.56)<br>$$<br><strong>算法 7.3（线性支持向量机学习算法）</strong></p>
<p><strong>输入</strong>：线性可分训练数据集$T = {(x_1,y_1),(x_2,y_2),…,(x_N,y_N)}$，其中，$x_i \in \chi = R^n, y \in \mathcal{Y} = {+1, -1}, i=1,2,…,N$；</p>
<p><strong>输出</strong>：分离超平面和分类决策函数。</p>
<p>​    （1）选择惩罚参数$C&gt;0$，构造并求解凸二次规划问题<br>$$<br>\min\limits_{\alpha} \ \ \ \frac{1}{2}\sum\limits_{i=1}^{N}\sum\limits_{j=1}^{N}\alpha_i \alpha_j y_i y_j (x_i·x_j)\ - \ \sum\limits_{i=1}^{N}\alpha_i<br>$$</p>
<p>$$<br>s.t. \ \ \ \sum\limits_{i=1}^{N}\alpha_i y_i = 0<br>$$</p>
<p>$$<br>0 \leq \alpha_i \leq C, \ \ \ i = 1,2,…,N<br>$$</p>
<p>求得最优解$\alpha^* = (\alpha^*_1,\alpha^*_2,…,\alpha^*_N)^T$。</p>
<p>​    （2）计算$\omega^* = \sum\limits_{i=1}^{N}\alpha_i^* y_i x_i$</p>
<p>选择$\alpha^*$的一个分量$\alpha_j^*$适合条件$0&lt;\alpha_j^* &lt;C$，计算<br>$$<br>b^* = y_j - \sum\limits_{i=1}^{N}\alpha_i^* y_i (x_i·x_j)<br>$$<br>​    （3）求得分离超平面<br>$$<br>\omega^<em>·x+b^</em> = 0<br>$$<br>分类决策函数<br>$$<br>f(x)=sign(\omega^<em>·x+b^</em>)<br>$$</p>
<h2 id="7-2-3-支持向量"><a href="#7-2-3-支持向量" class="headerlink" title="7.2.3 支持向量"></a>7.2.3 支持向量</h2><p>在线性不可分的情况下，将对偶问题$(7.37)$~$(7.39)$的解$\alpha^* = (\alpha^*_1,\alpha^*_2,…,\alpha^*_N)^T$中对应于$\alpha^*_i &gt; 0$的样本点$(x_i,y_i)$的实例$x_i$称为支持向量（软间隔的支持向量）。</p>
<p>软间隔的支持向量$x_i$或者在间隔边界上，或者在间隔边界与分离超平面之间，或者在分离超平面误分一侧。</p>
<ul>
<li>若$\alpha_i^* &lt;C$，则$\xi_i = 0$，支持向量$x_i$恰好落在间隔边界上；</li>
<li>若$\alpha_i^* = C$，$0&lt;\xi_i &lt;1$，则分类正确，$x_i$在间隔边界与分离超平面之间；</li>
<li>若$\alpha_i^* = C$，$\xi_i = 1$，则$x_i$在分离超平面上；</li>
<li>若$\alpha_i^* = C$，$\xi_i &gt; 1$，则$x_i$位于分离超平面误分类一侧。</li>
</ul>
<h2 id="7-2-4-合页损失函数"><a href="#7-2-4-合页损失函数" class="headerlink" title="7.2.4 合页损失函数"></a>7.2.4 合页损失函数</h2><p>线性支持向量机学习还有另外一种解释，就是最小化以下目标函数：<br>$$<br>\sum\limits_{i=1}^{N}[1-y_i(\omega·x +b)]_{+} + \lambda||\omega||^2\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.57)<br>$$</p>
<ul>
<li><p>目标函数的第1项是经验损失或经验风险，函数<br>$$<br>L(y(\omega·x + b)) = [1-y(\omega·x+b)]<em>{+}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.58)<br>$$<br>称为<strong>合页损失函数（hinge loss function）</strong>。下标“+”表示以下去正值的函数。<br>$$<br>[z]</em>{+} = \lbrace_{0,\ \ \ z \leq 0}^{z, \ \ \ z &gt;0}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.59)<br>$$<br>这就是说，当样本点$(x_i,y_i)$被正确分类且函数间隔（确信度）$y_i(\omega·x_i+b)$大于1时，损失是0，否则损失是$1-y_i(\omega·x_i+b)$。</p>
</li>
<li><p>目标函数的第2项是系数为$\lambda$的$\omega$的$L_2$范数，是正则化项。</p>
</li>
</ul>
<p><strong>定理 7.4</strong>  线性支持向量机原始最优化问题：<br>$$<br>\min\limits_{\omega,b,\xi} \ \ \ \frac{1}{2}||\omega||^2 \ + \ C\sum\limits_{i=1}^N \xi_i<br>$$</p>
<p>$$<br>s.t.\ \ \ y_i(\omega·x_i+b) \geq 1 - \xi_i \ \ \ i = 1,2,…,N<br>$$</p>
<p>$$<br>\xi_i \geq 0,\ \ \ i = 1,2,…,N<br>$$</p>
<p>等价于最优化问题<br>$$<br>\min\limits_{\omega,b}\ \ \ \sum\limits_{i=1}^{N}[1-y_i(\omega·x +b)]_{+} + \lambda||\omega||^2\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.63)<br>$$<br>合页损失函数横轴是函数间隔$y(\omega·x +b)$，纵轴是损失。由于函数形状像一个合页，故名合页损失函数。</p>
<p>0-1损失函数，可以认为它是二分类问题的真正的损失函数，而合页损失函数是0-1损失函数的上界。由于0-1损失函数不是连续可导的，直接优化由其构成的目标函数比较困难，可以认为线性支持向量机是优化由0-1损失函数的上界（合页损失函数）构成的目标函数。这时的上界损失函数又称为<strong>代理损失函数（surrogate loss function）</strong>。</p>
<p>合页损失函数不仅要分类正确，而且确信度足够高时损失才是0。也就是说，合页损失函数对学习有更高的要求。</p>
<h1 id="7-3-非线性支持向量机与核函数"><a href="#7-3-非线性支持向量机与核函数" class="headerlink" title="7.3 非线性支持向量机与核函数"></a>7.3 非线性支持向量机与核函数</h1><p>非线性支持向量机主要特点是利用核技巧（kernel trick）。</p>
<h2 id="7-3-1-核技巧"><a href="#7-3-1-核技巧" class="headerlink" title="7.3.1 核技巧"></a>7.3.1 核技巧</h2><ol>
<li><strong>非线性分类问题</strong></li>
</ol>
<p>一般来说，对给定的一个训练数据集$T = {(x_1,y_1),(x_2,y_2),…,(x_N,y_N)}$，其中，$x_i \in \chi = R^n, y \in Y = {+1, -1}, i=1,2,…,N$。如果能用$R^n$中的一个超曲面将正负例正确分开，则称这个问题为非线性可分问题。</p>
<p>非线性问题往往不好求解，所以希望能用解线性分类问题的方法解决这个问题。所采取的方法是进行一个非线性变换，将非线性问题变换为线性问题，通过解变换后的线性问题的方法求解原来的非线性问题。</p>
<p>用线性分类方法求解非线性分类问题分为两步：</p>
<ul>
<li>使用一个变换将原空间的数据映射到新空间；</li>
<li>在新空间里用线性分类学习方法从训练数据中学习分类模型。</li>
</ul>
<hr>
<ol start="2">
<li><strong>核函数的定义</strong></li>
</ol>
<p><strong>定义 7.6 （核函数）</strong>  设$\chi$是输入空间（欧式空间$R^n$的子集或离散集合），又设$\mathcal{H}$为特征空间（希尔伯特空间），如果存在一个从$\mathcal{X}$到$\mathcal{H}$的映射<br>$$<br>\phi(x) : \mathcal{X} \longrightarrow \mathcal{H}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.65)<br>$$<br>使得对所有$x,z \in \mathcal{X}$，函数$K(x,z)$满足条件<br>$$<br>K(x,z) = \phi(x)·\phi(z)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.66)<br>$$<br>则称$K(x,z)$为核函数，$\phi(x)$为映射函数，式中$\phi(x)·\phi(z)$为$\phi(x)$和$\phi(z)$的内积。</p>
<hr>
<p>核技巧想法是，在学习与预测中只定义核函数$K(x,z)$，而不显示地定义映射函数$\phi$。通常，直接计算$K(x,z)$比较容易，而通过$\phi(x)$和$\phi(z)$计算$K(x,z)$并不容易。</p>
<p>对于给定的核$K(x,z)$，特征空间$\mathcal{H}$和映射函数$\phi$的取法并不唯一，可以取不同的特征空间，即便是在同一特征空间里也可以取不同的映射。</p>
<hr>
<ol start="3">
<li><strong>核技巧在支持向量机中的应用</strong></li>
</ol>
<p>在线性支持向量机的对偶问题中，无论是目标函数还是决策函数（分离超平面）都只涉及输入实例与实例之间的内积。在对偶问题的目标函数$(7.37)$中内积$x_i·x_j$可以用核函数$K(x_i,x_j) = \phi(x_i)·\phi(x_j)$来代替。此时对偶问题的目标函数成为<br>$$<br>W(\alpha) = \frac{1}{2}\sum\limits_{i=1}^{N}\sum\limits_{j=1}^{N}\alpha_i \alpha_j y_i y_j K(x_i,x_j)\ - \ \sum\limits_{i=1}^{N}\alpha_i\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.67)<br>$$<br>同样，分类决策函数中的内积也可以用核函数代替，而分类决策函数式成为<br>$$<br>f(x)= sign(\sum\limits_{i=1}^{N}\alpha_i^* y_i \phi(x)·\phi(x_j) + b^*)<br>$$</p>
<p>$$<br>\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ =sign(\sum\limits_{i=1}^{N}\alpha_i^* y_i K(x_i,x) + b^*)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.68)<br>$$</p>
<p>这等价于经过映射函数$\phi$将原来的输入空间变换到一个新的特征空间，将输入空间中的内积$x_i·x_j$变换为特征空间中的内积$\phi(x_i)·\phi(x_j)$，在新的特征空间里从训练样本中学习线性支持向量机。当映射函数是非线性函数时，学习到的含有核函数的支持向量机是非线性分类模型。</p>
<p>在核函数$K(x,z)$给定的条件下，可以利用解线性分类问题的方法来求解非线性分类问题的支持向量机。学习是隐式地在特征空间进行的，不需要显式地定义特征空间和映射函数。这样的技巧称为核技巧，它是巧妙地利用线性分类学习方法与核函数解决非线性问题的技术。</p>
<h2 id="7-3-2-正定核"><a href="#7-3-2-正定核" class="headerlink" title="7.3.2 正定核"></a>7.3.2 正定核</h2><p>通常所说的核函数就是<strong>正定核函数（positive definite kernel function）</strong>。</p>
<p>假设$K(x,z)$是定义在$\mathcal{X} \times \mathcal{X}$上的对称函数，并且对任意的$x_i,x_2,…,x_m \in \mathcal{X}$，$K(x,z)$关于$x_i,x_2,…,x_m$的$Gram$矩阵是半正定的。可以依据函数$K(x,z)$，构成一个希尔伯特空间(Hilbert space)，其步骤是：首先定义映射$\phi$并构成向量空间$\mathcal{S}$；然后在$\mathcal{S}$上定义内积构成内积空间；最后将$\mathcal{S}$完备化构成希尔伯特空间。</p>
<ol>
<li><strong>定义映射，构成向量空间$\mathcal{S}$</strong></li>
</ol>
<p>先定义映射<br>$$<br>\phi : x \longrightarrow K(·,x)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.69)<br>$$<br>根据这一映射，对任意$x_i \in \mathcal{X},\alpha_i \in R,i=1,2,…,m$，定义线性组合<br>$$<br>f(·)=\sum\limits_{i=1}^{m}\alpha_i K(·,x_i)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.70)<br>$$<br>考虑由线性组合为元素的集合$\mathcal{S}$。由于集合$\mathcal{S}$对加法和数乘运算是封闭的，所以$\mathcal{S}$构成一个向量空间。</p>
<ol start="2">
<li><strong>在$\mathcal{S}$上定义内积，使其成为内积空间</strong></li>
</ol>
<p>在$\mathcal{S}$上定义一个运算$*$：对任意$f,g \in \mathcal{S}$,<br>$$<br>f(·)=\sum\limits_{i=1}^{m}\alpha_i K(·,x_i)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.71)<br>$$</p>
<p>$$<br>g(·)=\sum\limits_{j=1}^{l}\beta_j K(·,z_j)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.72)<br>$$</p>
<p>定义运算$<em>$<br>$$<br>f * g = \sum\limits_{i=1}^{m}\sum\limits_{j=1}^{l}\alpha_i\beta_j K(x_i,z_j)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.73)<br>$$<br>赋予内积的向量空间为内积空间。因此$\mathcal{S}$是一个内积空间。既然$</em>$为$\mathcal{S}$的内积运算，那么仍然用$·$表示，即<br>$$<br>f · g = \sum\limits_{i=1}^{m}\sum\limits_{j=1}^{l}\alpha_i\beta_j K(x_i,z_j)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.74)<br>$$</p>
<ol start="3">
<li><strong>将内积空间</strong>$\mathcal{S}$<strong>完备化为希尔伯特空间</strong></li>
</ol>
<p>现将内积空间$\mathcal{S}$完备化。由式$(7.81)$定义的内积可以得到范数<br>$$<br>||f|| = \sqrt{f·f}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.82)<br>$$<br>因此，$\mathcal{S}$是一个赋范向量空间。根据泛函分析理论，对于不完备的赋范向量空间$\mathcal{S}$，一定可以使之完备化，得到完备的赋范向量空间$\mathcal{H}$。一个内积空间，当作为一个赋范向量空间是完备的时候，就是希尔伯特空间。这样，就得到了希尔伯特空间$\mathcal{H}$。</p>
<p>这一希尔伯特空间$\mathcal{H}$称为<strong>再生核希尔伯特空间（reproducing kernel Hilbert space，RKHS）</strong>。这是由于核$K$具有再生性，即满足<br>$$<br>K(·,x)·f = f(x)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.83)<br>$$<br>及<br>$$<br>K(·,x) · K(·,z) = K(x,z)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.84)<br>$$<br>称为再生核。</p>
<ol start="4">
<li><strong>正定核的充要条件</strong></li>
</ol>
<p><strong>定理 7.5（正定核的充要条件）</strong>  设$K:\mathcal{X} \times \mathcal{X} \longrightarrow R$是对称函数，则$K(x,z)$为正定核函数的充要条件是对任意$x_i \in \mathcal{X},i=1,2,…,m$，$K(x,z)$对应的$Gram$矩阵：<br>$$<br>K = [K(x_i,x_j)]_{m \times m}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.85)<br>$$<br>是半正定矩阵。</p>
<p><strong>定义 7.7（正定核的等价定义）</strong>  设$\mathcal{X} \subset R^n$，$K(x,z)$是定义在$\mathcal{X} \times \mathcal{X}$上的对称函数，如果对任意$x_i \in \mathcal{X},i=1,2,…,m$，$K(x,z)$对应的$Gram$矩阵<br>$$<br>K = [K(x_i,x_j)]_{m \times m}<br>$$<br>是半正定矩阵，则称$K(x,z)$是正定核。</p>
<h2 id="7-3-3-常用核函数"><a href="#7-3-3-常用核函数" class="headerlink" title="7.3.3 常用核函数"></a>7.3.3 常用核函数</h2><ol>
<li><strong>多项式核函数（polynomial kernel function）</strong></li>
</ol>
<p>$$<br>K(x,z) = (x·z + 1 )^p\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.88)<br>$$</p>
<p>对应的支持向量机是一个$p$次多项式分类器。在此情形下，分类决策函数成为<br>$$<br>f(x) = sign(\sum\limits_{i=1}^{N_\mathcal{S}}a_i^* y_i(x_i·x + 1)^p + b^*)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.89)<br>$$</p>
<ol start="2">
<li><strong>高斯核函数（Gaussian kernel function）</strong></li>
</ol>
<p>$$<br>K(x,z) = exp(-\frac{||x-z||^2}{2\sigma^2})\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.90)<br>$$</p>
<p>对应的支持向量机是<strong>高斯径向基函数（radial basis function）</strong>分类器。在此情形下，分类决策函数成为<br>$$<br>f(x) = sign(\sum\limits_{i=1}^{N_\mathcal{S}}a_i^* y_iexp(-\frac{||x-x_i||^2}{2\sigma^2}) + b^*)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.91)<br>$$</p>
<ol start="3">
<li><strong>字符串核函数（string kernel function）</strong></li>
</ol>
<p>核函数不仅可以定义在欧式空间上，还可以定义在离散数据的集合上。</p>
<p>两个字符串$s$和$t$上的字符串核函数是基于映射$\phi$的特征空间中的内积：<br>$$<br>k_n(s,t) = \sum\limits_{u\in \sum^n}[\phi_n(s)]_u [\phi_n(t)]_u<br>$$</p>
<p>$$<br>= \sum\limits_{u\in \sum^n}\sum\limits_{(i,j):s(i)=t(j)=u}\lambda^{l(i)}\lambda^{l(j)}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.93)<br>$$</p>
<p>字符串核函数$k_n(s,t)$给出了字符串$s$和$t$中长度等于$n$的所有子串组成的特征向量的<strong>余弦相似度（cosine similarity）</strong>。直观上，两个字符串相同的子串越多，他们就越相似，字符串核函数的值就越大。</p>
<h2 id="7-3-4-非线性支持向量分类机"><a href="#7-3-4-非线性支持向量分类机" class="headerlink" title="7.3.4 非线性支持向量分类机"></a>7.3.4 非线性支持向量分类机</h2><p>将线性支持向量机扩展到非线性支持向量机，只需将线性支持向量机对偶形式中的内积换成核函数。</p>
<p><strong>定义 7.8（非线性支持向量机）</strong>  从非线性分类训练集，通过核函数与软间隔最大化，或凸二次规划$(7.95)$~$(7.97)$，学习得到的分类决策函数<br>$$<br>f(x) = sign(\sum\limits_{i=1}^{N}\alpha_i^* y_i K(x,x_i) + b^*)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.94)<br>$$<br>称为非线性支持向量机，$K(x,z)$是正定核函数。</p>
<hr>
<p>算法 7.4 （非线性支持向量机学习算法）</p>
<p><strong>输入</strong>：训练数据集$T = {(x_1,y_1),(x_2,y_2),…,(x_N,y_N)}$，其中，$x_i \in \chi = R^n, y \in \mathcal{Y} = {+1, -1}, i=1,2,…,N$；</p>
<p><strong>输出</strong>：分类决策函数。</p>
<p>​    （1）选取适当的核函数$K(x,z)$和适当的参数$C$，构造并求解最优化问题<br>$$<br>\min\limits_{\alpha}\ \ \  \frac{1}{2}\sum\limits_{i=1}^{N}\sum\limits_{j=1}^{N}\alpha_i \alpha_j y_i y_j K(x_i,x_j)\ - \ \sum\limits_{i=1}^{N}\alpha_i\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.95)<br>$$</p>
<p>$$<br>s.t. \ \ \ \ \sum\limits_{i=1}^{N}\alpha_iy_i = 0\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.96)<br>$$</p>
<p>$$<br>0 \leq \alpha_i \leq C,\ \ \ i = 1,2,…,N\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7.97)<br>$$</p>
<p>求得最优解$\alpha^* = (\alpha^*_1,\alpha^*_2,…,\alpha^*_N)^T$。</p>
<p>​    （2）选择$\alpha^*$的一个正分量$0&lt;\alpha_j^* &lt; C$，计算<br>$$<br>b^* = y_j - \sum\limits_{i=1}^{N}\alpha_i^* y_i K(x_i·x_j)<br>$$<br>​    （3）构造决策函数：<br>$$<br>f(x) = sign(\sum\limits_{i=1}^{N}\alpha_i^* y_i K(x,x_i) + b^*)<br>$$<br>当$K(x,z)$是正定核函数时，问题$(7.95)$~$(7.97)$是凸二次规划问题，解是存在的。</p>
<h1 id="7-4-序列最小最优化算法"><a href="#7-4-序列最小最优化算法" class="headerlink" title="7.4 序列最小最优化算法"></a>7.4 序列最小最优化算法</h1>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/06/11/Python_Notes/%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E7%B1%BB/" rel="prev" title="第九章 类">
      <i class="fa fa-chevron-left"></i> 第九章 类
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#7-1-%E7%BA%BF%E6%80%A7%E5%8F%AF%E5%88%86%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E4%B8%8E%E7%A1%AC%E9%97%B4%E9%9A%94%E6%9C%80%E5%A4%A7%E5%8C%96"><span class="nav-number">1.</span> <span class="nav-text">7.1 线性可分支持向量机与硬间隔最大化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-1-1-%E7%BA%BF%E6%80%A7%E5%8F%AF%E5%88%86%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA"><span class="nav-number">2.</span> <span class="nav-text">7.1.1 线性可分支持向量机</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-2-%E5%87%BD%E6%95%B0%E9%97%B4%E9%9A%94%E5%92%8C%E5%87%A0%E4%BD%95%E9%97%B4%E9%9A%94"><span class="nav-number">2.1.</span> <span class="nav-text">7.1.2 函数间隔和几何间隔</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-3-%E9%97%B4%E9%9A%94%E6%9C%80%E5%A4%A7%E5%8C%96"><span class="nav-number">2.2.</span> <span class="nav-text">7.1.3 间隔最大化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-4-%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AF%B9%E5%81%B6%E7%AE%97%E6%B3%95"><span class="nav-number">2.3.</span> <span class="nav-text">7.1.4 学习的对偶算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-2-%E7%BA%BF%E6%80%A7%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E4%B8%8E%E8%BD%AF%E9%97%B4%E9%9A%94%E6%9C%80%E5%A4%A7%E5%8C%96"><span class="nav-number">3.</span> <span class="nav-text">7.2 线性支持向量机与软间隔最大化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-1-%E7%BA%BF%E6%80%A7%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA"><span class="nav-number">3.1.</span> <span class="nav-text">7.2.1 线性支持向量机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-2-%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AF%B9%E5%81%B6%E7%AE%97%E6%B3%95"><span class="nav-number">3.2.</span> <span class="nav-text">7.2.2 学习的对偶算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-3-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F"><span class="nav-number">3.3.</span> <span class="nav-text">7.2.3 支持向量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-4-%E5%90%88%E9%A1%B5%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0"><span class="nav-number">3.4.</span> <span class="nav-text">7.2.4 合页损失函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-3-%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E4%B8%8E%E6%A0%B8%E5%87%BD%E6%95%B0"><span class="nav-number">4.</span> <span class="nav-text">7.3 非线性支持向量机与核函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-1-%E6%A0%B8%E6%8A%80%E5%B7%A7"><span class="nav-number">4.1.</span> <span class="nav-text">7.3.1 核技巧</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-2-%E6%AD%A3%E5%AE%9A%E6%A0%B8"><span class="nav-number">4.2.</span> <span class="nav-text">7.3.2 正定核</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-3-%E5%B8%B8%E7%94%A8%E6%A0%B8%E5%87%BD%E6%95%B0"><span class="nav-number">4.3.</span> <span class="nav-text">7.3.3 常用核函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-4-%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E5%88%86%E7%B1%BB%E6%9C%BA"><span class="nav-number">4.4.</span> <span class="nav-text">7.3.4 非线性支持向量分类机</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-4-%E5%BA%8F%E5%88%97%E6%9C%80%E5%B0%8F%E6%9C%80%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95"><span class="nav-number">5.</span> <span class="nav-text">7.4 序列最小最优化算法</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Normal People"
      src="/images/posthead.jpg">
  <p class="site-author-name" itemprop="name">Normal People</p>
  <div class="site-description" itemprop="description">Get busy living or get busy dying</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/TheNormalPeople" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;TheNormalPeople" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1272481411@qq.com" title="E-Mail → mailto:1272481411@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5938927274" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5938927274" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/cy19970506" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;cy19970506" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Normal People</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'y8XFURQNCoQsprRTou9DiEJu-gzGzoHsz',
      appKey     : 'QfVpjKDtJQdJrnJNnWUbVvjH',
      placeholder: "留下邮箱,有空时间回复您！",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
